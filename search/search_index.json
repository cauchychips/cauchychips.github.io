{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"\u6b22\u8fce\u6765\u5230 OI Wiki \uff01 \u00b6 OI \uff08Olympiad in Informatics\uff0c\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\uff09\u5728\u4e2d\u56fd\u8d77\u6e90\u4e8e 1984 \u5e74\uff0c\u662f\u4e94\u5927\u9ad8\u4e2d\u5b66\u79d1\u7ade\u8d5b\u4e4b\u4e00\u3002 ICPC \uff08International Collegiate Programming Contest\uff0c\u56fd\u9645\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff09\u7531 ICPC \u57fa\u91d1\u4f1a\uff08ICPC Foundation\uff09\u4e3e\u529e\uff0c\u662f\u6700\u5177\u5f71\u54cd\u529b\u7684\u5927\u5b66\u751f\u8ba1\u7b97\u673a\u7ade\u8d5b\u3002\u7531\u4e8e\u4ee5\u524d ACM \u8d5e\u52a9\u8fd9\u4e2a\u7ade\u8d5b\uff0c\u4e5f\u6709\u5f88\u591a\u4eba\u4e60\u60ef\u53eb\u5b83 ACM \u7ade\u8d5b\u3002 OI Wiki \u81f4\u529b\u4e8e\u6210\u4e3a\u4e00\u4e2a\u514d\u8d39\u5f00\u653e\u4e14\u6301\u7eed\u66f4\u65b0\u7684 \u7f16\u7a0b\u7ade\u8d5b\uff08competitive programming\uff09 \u77e5\u8bc6\u6574\u5408\u7ad9\u70b9\uff0c\u5927\u5bb6\u53ef\u4ee5\u5728\u8fd9\u91cc\u83b7\u53d6\u4e0e\u7ade\u8d5b\u76f8\u5173\u7684\u3001\u6709\u8da3\u53c8\u5b9e\u7528\u7684\u77e5\u8bc6\u3002\u6211\u4eec\u4e3a\u5927\u5bb6\u51c6\u5907\u4e86\u7ade\u8d5b\u4e2d\u7684\u57fa\u7840\u77e5\u8bc6\u3001\u5e38\u89c1\u9898\u578b\u3001\u89e3\u9898\u601d\u8def\u4ee5\u53ca\u5e38\u7528\u5de5\u5177\u7b49\u5185\u5bb9\uff0c\u5e2e\u52a9\u5927\u5bb6\u66f4\u5feb\u901f\u6df1\u5165\u5730\u5b66\u4e60\u7f16\u7a0b\u7ade\u8d5b\u4e2d\u6d89\u53ca\u5230\u7684\u77e5\u8bc6\u3002 \u672c\u9879\u76ee\u53d7 CTF Wiki \u7684\u542f\u53d1\uff0c\u5728\u7f16\u5199\u8fc7\u7a0b\u4e2d\u53c2\u8003\u4e86\u8bf8\u591a\u8d44\u6599\uff0c\u5728\u6b64\u4e00\u5e76\u81f4\u8c22\u3002 // #758 document.getElementsByClassName('md-nav__title')[1].click()","title":"Main Page"},{"location":"index.html#oi-wiki","text":"OI \uff08Olympiad in Informatics\uff0c\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\uff09\u5728\u4e2d\u56fd\u8d77\u6e90\u4e8e 1984 \u5e74\uff0c\u662f\u4e94\u5927\u9ad8\u4e2d\u5b66\u79d1\u7ade\u8d5b\u4e4b\u4e00\u3002 ICPC \uff08International Collegiate Programming Contest\uff0c\u56fd\u9645\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff09\u7531 ICPC \u57fa\u91d1\u4f1a\uff08ICPC Foundation\uff09\u4e3e\u529e\uff0c\u662f\u6700\u5177\u5f71\u54cd\u529b\u7684\u5927\u5b66\u751f\u8ba1\u7b97\u673a\u7ade\u8d5b\u3002\u7531\u4e8e\u4ee5\u524d ACM \u8d5e\u52a9\u8fd9\u4e2a\u7ade\u8d5b\uff0c\u4e5f\u6709\u5f88\u591a\u4eba\u4e60\u60ef\u53eb\u5b83 ACM \u7ade\u8d5b\u3002 OI Wiki \u81f4\u529b\u4e8e\u6210\u4e3a\u4e00\u4e2a\u514d\u8d39\u5f00\u653e\u4e14\u6301\u7eed\u66f4\u65b0\u7684 \u7f16\u7a0b\u7ade\u8d5b\uff08competitive programming\uff09 \u77e5\u8bc6\u6574\u5408\u7ad9\u70b9\uff0c\u5927\u5bb6\u53ef\u4ee5\u5728\u8fd9\u91cc\u83b7\u53d6\u4e0e\u7ade\u8d5b\u76f8\u5173\u7684\u3001\u6709\u8da3\u53c8\u5b9e\u7528\u7684\u77e5\u8bc6\u3002\u6211\u4eec\u4e3a\u5927\u5bb6\u51c6\u5907\u4e86\u7ade\u8d5b\u4e2d\u7684\u57fa\u7840\u77e5\u8bc6\u3001\u5e38\u89c1\u9898\u578b\u3001\u89e3\u9898\u601d\u8def\u4ee5\u53ca\u5e38\u7528\u5de5\u5177\u7b49\u5185\u5bb9\uff0c\u5e2e\u52a9\u5927\u5bb6\u66f4\u5feb\u901f\u6df1\u5165\u5730\u5b66\u4e60\u7f16\u7a0b\u7ade\u8d5b\u4e2d\u6d89\u53ca\u5230\u7684\u77e5\u8bc6\u3002 \u672c\u9879\u76ee\u53d7 CTF Wiki \u7684\u542f\u53d1\uff0c\u5728\u7f16\u5199\u8fc7\u7a0b\u4e2d\u53c2\u8003\u4e86\u8bf8\u591a\u8d44\u6599\uff0c\u5728\u6b64\u4e00\u5e76\u81f4\u8c22\u3002 // #758 document.getElementsByClassName('md-nav__title')[1].click()","title":"\u6b22\u8fce\u6765\u5230 OI Wiki\uff01"},{"location":"navigation.html","text":"Home Main Page Navigation Tag index How to Contribute Code of conduct Preview Algebra Fundamentals Binary Exponentiation Euclidean algorithm for computing the greatest common divisor Extended Euclidean Algorithm Linear Diophantine Equations Fibonacci Numbers Prime numbers Sieve of Eratosthenes Linear Sieve Primality tests Integer factorization Number-theoretic functions Euler's totient function Number of divisors / sum of divisors Modular arithmetic Modular Inverse Linear Congruence Equation Chinese Remainder Theorem Garner's Algorithm Factorial modulo p Discrete Log Primitive Root Discrete Root Montgomery Multiplication Number systems Balanced Ternary Gray code Miscellaneous Bit manipulation Enumerating submasks of a bitmask Arbitrary-Precision Arithmetic Fast Fourier transform Operations on polynomials and series Continued fractions Factoring Exponentiation Data Structures Fundamentals Minimum Stack / Minimum Queue Sparse Table Trees Disjoint Set Union Fenwick Tree Sqrt Decomposition Segment Tree Treap Sqrt Tree Randomized Heap Advanced Deleting from a data structure in O(T(n) log n) Dynamic Programming Introduction to Dynamic Programming Knapsack Problem DP optimizations Divide and Conquer DP Knuth's Optimization Tasks Dynamic Programming on Broken Profile. Problem \"Parquet\" Finding the largest zero submatrix String Processing Fundamentals String Hashing Rabin-Karp for String Matching Prefix function - Knuth-Morris-Pratt Z-function Suffix Array Aho-Corasick algorithm Advanced Suffix Tree Suffix Automaton Lyndon factorization Tasks Expression parsing Manacher's Algorithm - Finding all sub-palindromes in O(N) Finding repetitions Linear Algebra Matrices Gauss & System of Linear Equations Gauss & Determinant Kraut & Determinant Rank of a matrix Combinatorics Fundamentals Finding Power of Factorial Divisor Binomial Coefficients Catalan Numbers Techniques The Inclusion-Exclusion Principle Burnside's lemma / P\u00f3lya enumeration theorem Stars and bars Generating all K-combinations Tasks Placing Bishops on a Chessboard Balanced bracket sequences Counting labeled graphs Numerical Methods Search Binary Search Ternary Search Newton's method for finding roots Integration Integration by Simpson's formula Geometry Elementary operations Basic Geometry Finding the equation of a line for a segment Intersection Point of Lines Check if two segments intersect Intersection of Segments Circle-Line Intersection Circle-Circle Intersection Common tangents to two circles Length of the union of segments Polygons Oriented area of a triangle Area of simple polygon Check if points belong to the convex polygon in O(log N) Minkowski sum of convex polygons Pick's Theorem - area of lattice polygons Lattice points of non-lattice polygon Convex hull Convex hull construction Convex hull trick and Li Chao tree Sweep-line Search for a pair of intersecting segments Planar graphs Finding faces of a planar graph Point location in O(log N) Miscellaneous Finding the nearest pair of points Delaunay triangulation and Voronoi diagram Vertical decomposition Half-plane intersection - S&I Algorithm in O(N log N) Manhattan Distance Graphs Graph traversal Breadth First Search Depth First Search Connected components, bridges, articulations points Finding Connected Components Finding Bridges in O(N+M) Finding Bridges Online Finding Articulation Points in O(N+M) Strongly Connected Components and Condensation Graph Strong Orientation Single-source shortest paths Dijkstra - finding shortest paths from given vertex Dijkstra on sparse graphs Bellman-Ford - finding shortest paths with negative weights 0-1 BFS D\u00b4Esopo-Pape algorithm All-pairs shortest paths Floyd-Warshall - finding all shortest paths Number of paths of fixed length / Shortest paths of fixed length Spanning trees Minimum Spanning Tree - Prim's Algorithm Minimum Spanning Tree - Kruskal Minimum Spanning Tree - Kruskal with Disjoint Set Union Second best Minimum Spanning Tree - Using Kruskal and Lowest Common Ancestor Kirchhoff Theorem Pr\u00fcfer code Cycles Checking a graph for acyclicity and finding a cycle in O(M) Finding a Negative Cycle in the Graph Eulerian Path Lowest common ancestor Lowest Common Ancestor Lowest Common Ancestor - Binary Lifting Lowest Common Ancestor - Farach-Colton and Bender algorithm Solve RMQ by finding LCA Lowest Common Ancestor - Tarjan's off-line algorithm Flows and related problems Maximum flow - Ford-Fulkerson and Edmonds-Karp Maximum flow - Push-relabel algorithm Maximum flow - Push-relabel algorithm improved Maximum flow - Dinic's algorithm Maximum flow - MPM algorithm Flows with demands Minimum-cost flow Assignment problem Matchings and related problems Bipartite Graph Check Kuhn's Algorithm - Maximum Bipartite Matching Hungarian Algorithm Miscellaneous Topological Sorting Edge connectivity / Vertex connectivity Tree painting 2-SAT Heavy-light decomposition Miscellaneous Sequences RMQ task (Range Minimum Query - the smallest element in an interval) Longest increasing subsequence Search the subsegment with the maximum/minimum sum K-th order statistic in O(N) MEX task (Minimal Excluded element in an array) Game Theory Games on arbitrary graphs Sprague-Grundy theorem. Nim Schedules Scheduling jobs on one machine Scheduling jobs on two machines Optimal schedule of jobs given their deadlines and durations Miscellaneous Tortoise and Hare Algorithm (Linked List cycle detection) Josephus problem 15 Puzzle Game: Existence Of The Solution The Stern-Brocot Tree and Farey Sequences","title":"Navigation"},{"location":"preview.html","text":"$(document).ready(function(){ $(\"#previewBtn\").click(function(){ var markdown = $(\"#markdownInput\").val(); var URL = \"https://us-central1-cp-algorithms.cloudfunctions.net/convert-markdown-mkdocs\"; var data = {\"markdown\": markdown}; var refresh_script = `<scr` + `ipt>MathJax.typeset();</scr` + `ipt>`; $(\"#previewBtn\").html(\"Loading...\"); $.ajax({ url: URL, contentType: \"application/json\", method: 'POST', data: JSON.stringify(data), success: function(data) { $(\"#previewArea\").html(data + \"\\n\" + refresh_script); $(\"#previewBtn\").html(\"Preview (Ctrl + Enter)\"); }, error: function() {$(\"#previewArea\").html(\"Internal error!\")} }); }); $('form').keydown(function(event) { if (event.ctrlKey && event.keyCode === 13) { $(\"#previewBtn\").click(); } }) }); Article Preview \u00b6 Information for contributors # Example article $$a^2 + b^2 = c^2$$ ```cpp int gcd (int a, int b) { if (b == 0) return a; else return gcd (b, a % b); } ``` Preview (Ctrl + Enter)","title":"Preview"},{"location":"preview.html#article-preview","text":"Information for contributors # Example article $$a^2 + b^2 = c^2$$ ```cpp int gcd (int a, int b) { if (b == 0) return a; else return gcd (b, a % b); } ``` Preview (Ctrl + Enter)","title":"Article Preview"},{"location":"tags.html","text":"Tags \u00b6 This file contains a global index of all tags used on the pages. [TAGS]","title":"Tag index"},{"location":"tags.html#tags","text":"This file contains a global index of all tags used on the pages. [TAGS]","title":"Tags"},{"location":"algebra/all-submasks.html","text":"Submask Enumeration \u00b6 Enumerating all submasks of a given mask \u00b6 Given a bitmask $m$ , you want to efficiently iterate through all of its submasks, that is, masks $s$ in which only bits that were included in mask $m$ are set. Consider the implementation of this algorithm, based on tricks with bit operations: int s = m ; while ( s > 0 ) { ... you can use s ... s = ( s -1 ) & m ; } or, using a more compact for statement: for ( int s = m ; s ; s = ( s -1 ) & m ) ... you can use s ... In both variants of the code, the submask equal to zero will not be processed. We can either process it outside the loop, or use a less elegant design, for example: for ( int s = m ; ; s = ( s -1 ) & m ) { ... you can use s ... if ( s == 0 ) break ; } Let us examine why the above code visits all submasks of $m$ , without repetition, and in descending order. Suppose we have a current bitmask $s$ , and we want to move on to the next bitmask. By subtracting from the mask $s$ one unit, we will remove the rightmost set bit and all bits to the right of it will become 1. Then we remove all the \"extra\" one bits that are not included in the mask $m$ and therefore can't be a part of a submask. We do this removal by using the bitwise operation (s-1) & m . As a result, we \"cut\" mask $s-1$ to determine the highest value that it can take, that is, the next submask after $s$ in descending order. Thus, this algorithm generates all submasks of this mask in descending order, performing only two operations per iteration. A special case is when $s = 0$ . After executing $s-1$ we get a mask where all bits are set (bit representation of -1), and after (s-1) & m we will have that $s$ will be equal to $m$ . Therefore, with the mask $s = 0$ be careful \u2014 if the loop does not end at zero, the algorithm may enter an infinite loop. Iterating through all masks with their submasks. Complexity $O(3^n)$ \u00b6 In many problems, especially those that use bitmask dynamic programming, you want to iterate through all bitmasks and for each mask, iterate through all of its submasks: for ( int m = 0 ; m < ( 1 << n ); ++ m ) for ( int s = m ; s ; s = ( s -1 ) & m ) ... s and m ... Let's prove that the inner loop will execute a total of $O(3^n)$ iterations. First proof : Consider the $i$ -th bit. There are exactly three options for it: it is not included in the mask $m$ (and therefore not included in submask $s$ ), it is included in $m$ , but not included in $s$ , or it is included in both $m$ and $s$ . As there are a total of $n$ bits, there will be $3^n$ different combinations. Second proof : Note that if mask $m$ has $k$ enabled bits, then it will have $2^k$ submasks. As we have a total of $\\binom{n}{k}$ masks with $k$ enabled bits (see binomial coefficients ), then the total number of combinations for all masks will be: $$\\sum_{k=0}^n \\binom{n}{k} \\cdot 2^k$$ To calculate this number, note that the sum above is equal to the expansion of $(1+2)^n$ using the binomial theorem. Therefore, we have $3^n$ combinations, as we wanted to prove. Practice Problems \u00b6 Atcoder - Close Group Codeforces - Nuclear Fusion Codeforces - Sandy and Nuts Uva 1439 - Exclusive Access 2 UVa 11825 - Hackers' Crackdown","title":"Enumerating submasks of a bitmask"},{"location":"algebra/all-submasks.html#submask-enumeration","text":"","title":"Submask Enumeration"},{"location":"algebra/all-submasks.html#enumerating-all-submasks-of-a-given-mask","text":"Given a bitmask $m$ , you want to efficiently iterate through all of its submasks, that is, masks $s$ in which only bits that were included in mask $m$ are set. Consider the implementation of this algorithm, based on tricks with bit operations: int s = m ; while ( s > 0 ) { ... you can use s ... s = ( s -1 ) & m ; } or, using a more compact for statement: for ( int s = m ; s ; s = ( s -1 ) & m ) ... you can use s ... In both variants of the code, the submask equal to zero will not be processed. We can either process it outside the loop, or use a less elegant design, for example: for ( int s = m ; ; s = ( s -1 ) & m ) { ... you can use s ... if ( s == 0 ) break ; } Let us examine why the above code visits all submasks of $m$ , without repetition, and in descending order. Suppose we have a current bitmask $s$ , and we want to move on to the next bitmask. By subtracting from the mask $s$ one unit, we will remove the rightmost set bit and all bits to the right of it will become 1. Then we remove all the \"extra\" one bits that are not included in the mask $m$ and therefore can't be a part of a submask. We do this removal by using the bitwise operation (s-1) & m . As a result, we \"cut\" mask $s-1$ to determine the highest value that it can take, that is, the next submask after $s$ in descending order. Thus, this algorithm generates all submasks of this mask in descending order, performing only two operations per iteration. A special case is when $s = 0$ . After executing $s-1$ we get a mask where all bits are set (bit representation of -1), and after (s-1) & m we will have that $s$ will be equal to $m$ . Therefore, with the mask $s = 0$ be careful \u2014 if the loop does not end at zero, the algorithm may enter an infinite loop.","title":"Enumerating all submasks of a given mask"},{"location":"algebra/all-submasks.html#iterating-through-all-masks-with-their-submasks-complexity-o3n","text":"In many problems, especially those that use bitmask dynamic programming, you want to iterate through all bitmasks and for each mask, iterate through all of its submasks: for ( int m = 0 ; m < ( 1 << n ); ++ m ) for ( int s = m ; s ; s = ( s -1 ) & m ) ... s and m ... Let's prove that the inner loop will execute a total of $O(3^n)$ iterations. First proof : Consider the $i$ -th bit. There are exactly three options for it: it is not included in the mask $m$ (and therefore not included in submask $s$ ), it is included in $m$ , but not included in $s$ , or it is included in both $m$ and $s$ . As there are a total of $n$ bits, there will be $3^n$ different combinations. Second proof : Note that if mask $m$ has $k$ enabled bits, then it will have $2^k$ submasks. As we have a total of $\\binom{n}{k}$ masks with $k$ enabled bits (see binomial coefficients ), then the total number of combinations for all masks will be: $$\\sum_{k=0}^n \\binom{n}{k} \\cdot 2^k$$ To calculate this number, note that the sum above is equal to the expansion of $(1+2)^n$ using the binomial theorem. Therefore, we have $3^n$ combinations, as we wanted to prove.","title":"Iterating through all masks with their submasks. Complexity $O(3^n)$"},{"location":"algebra/all-submasks.html#practice-problems","text":"Atcoder - Close Group Codeforces - Nuclear Fusion Codeforces - Sandy and Nuts Uva 1439 - Exclusive Access 2 UVa 11825 - Hackers' Crackdown","title":"Practice Problems"},{"location":"algebra/balanced-ternary.html","text":"Balanced Ternary \u00b6 This is a non-standard but still positional numeral system . Its feature is that digits can have one of the values -1 , 0 and 1 . Nevertheless, its base is still 3 (because there are three possible values). Since it is not convenient to write -1 as a digit, we'll use letter Z further for this purpose. If you think it is quite a strange system - look at the picture - here is one of the computers utilizing it. So here are few first numbers written in balanced ternary: 0 0 1 1 2 1Z 3 10 4 11 5 1ZZ 6 1Z0 7 1Z1 8 10Z 9 100 This system allows you to write negative values without leading minus sign: you can simply invert digits in any positive number. -1 Z -2 Z1 -3 Z0 -4 ZZ -5 Z11 Note that a negative number starts with Z and positive with 1 . Conversion algorithm \u00b6 It is easy to represent a given number in balanced ternary via temporary representing it in normal ternary number system. When value is in standard ternary, its digits are either 0 or 1 or 2 . Iterating from the lowest digit we can safely skip any 0 s and 1 s, however 2 should be turned into Z with adding 1 to the next digit. Digits 3 should be turned into 0 on the same terms - such digits are not present in the number initially but they can be encountered after increasing some 2 s. Example 1: Let us convert 64 to balanced ternary. At first we use normal ternary to rewrite the number: $$ 64_{10} = 02101_{3} $$ Let us process it from the least significant (rightmost) digit: 1 , 0 and 1 are skipped as it is.( Because 0 and 1 are allowed in balanced ternary ) 2 is turned into Z increasing the digit to its left, so we get 1Z101 . The final result is 1Z101 . Let us convert it back to the decimal system by adding the weighted positional values: $$ 1Z101 = 81 \\cdot 1 + 27 \\cdot (-1) + 9 \\cdot 1 + 3 \\cdot 0 + 1 \\cdot 1 = 64_{10} $$ Example 2: Let us convert 237 to balanced ternary. At first we use normal ternary to rewrite the number: $$ 237_{10} = 22210_{3} $$ Let us process it from the least significant (rightmost) digit: 0 and 1 are skipped as it is.( Because 0 and 1 are allowed in balanced ternary ) 2 is turned into Z increasing the digit to its left, so we get 23Z10 . 3 is turned into 0 increasing the digit to its left, so we get 30Z10 . 3 is turned into 0 increasing the digit to its left( which is by default 0 ), and so we get 100Z10 . The final result is 100Z10 . Let us convert it back to the decimal system by adding the weighted positional values: $$ 100Z10 = 243 \\cdot 1 + 81 \\cdot 0 + 27 \\cdot 0 + 9 \\cdot (-1) + 3 \\cdot 1 + 1 \\cdot 0 = 237_{10} $$ Practice Problems \u00b6 Topcoder SRM 604, Div1-250","title":"Balanced Ternary"},{"location":"algebra/balanced-ternary.html#balanced-ternary","text":"This is a non-standard but still positional numeral system . Its feature is that digits can have one of the values -1 , 0 and 1 . Nevertheless, its base is still 3 (because there are three possible values). Since it is not convenient to write -1 as a digit, we'll use letter Z further for this purpose. If you think it is quite a strange system - look at the picture - here is one of the computers utilizing it. So here are few first numbers written in balanced ternary: 0 0 1 1 2 1Z 3 10 4 11 5 1ZZ 6 1Z0 7 1Z1 8 10Z 9 100 This system allows you to write negative values without leading minus sign: you can simply invert digits in any positive number. -1 Z -2 Z1 -3 Z0 -4 ZZ -5 Z11 Note that a negative number starts with Z and positive with 1 .","title":"Balanced Ternary"},{"location":"algebra/balanced-ternary.html#conversion-algorithm","text":"It is easy to represent a given number in balanced ternary via temporary representing it in normal ternary number system. When value is in standard ternary, its digits are either 0 or 1 or 2 . Iterating from the lowest digit we can safely skip any 0 s and 1 s, however 2 should be turned into Z with adding 1 to the next digit. Digits 3 should be turned into 0 on the same terms - such digits are not present in the number initially but they can be encountered after increasing some 2 s. Example 1: Let us convert 64 to balanced ternary. At first we use normal ternary to rewrite the number: $$ 64_{10} = 02101_{3} $$ Let us process it from the least significant (rightmost) digit: 1 , 0 and 1 are skipped as it is.( Because 0 and 1 are allowed in balanced ternary ) 2 is turned into Z increasing the digit to its left, so we get 1Z101 . The final result is 1Z101 . Let us convert it back to the decimal system by adding the weighted positional values: $$ 1Z101 = 81 \\cdot 1 + 27 \\cdot (-1) + 9 \\cdot 1 + 3 \\cdot 0 + 1 \\cdot 1 = 64_{10} $$ Example 2: Let us convert 237 to balanced ternary. At first we use normal ternary to rewrite the number: $$ 237_{10} = 22210_{3} $$ Let us process it from the least significant (rightmost) digit: 0 and 1 are skipped as it is.( Because 0 and 1 are allowed in balanced ternary ) 2 is turned into Z increasing the digit to its left, so we get 23Z10 . 3 is turned into 0 increasing the digit to its left, so we get 30Z10 . 3 is turned into 0 increasing the digit to its left( which is by default 0 ), and so we get 100Z10 . The final result is 100Z10 . Let us convert it back to the decimal system by adding the weighted positional values: $$ 100Z10 = 243 \\cdot 1 + 81 \\cdot 0 + 27 \\cdot 0 + 9 \\cdot (-1) + 3 \\cdot 1 + 1 \\cdot 0 = 237_{10} $$","title":"Conversion algorithm"},{"location":"algebra/balanced-ternary.html#practice-problems","text":"Topcoder SRM 604, Div1-250","title":"Practice Problems"},{"location":"algebra/big-integer.html","text":"Arbitrary-Precision Arithmetic \u00b6 Arbitrary-Precision arithmetic, also known as \"bignum\" or simply \"long arithmetic\" is a set of data structures and algorithms which allows to process much greater numbers than can be fit in standard data types. Here are several types of arbitrary-precision arithmetic. Classical Integer Long Arithmetic \u00b6 The main idea is that the number is stored as an array of its \"digits\" in some base. Several most frequently used bases are decimal, powers of decimal ( $10^4$ or $10^9$ ) and binary. Operations on numbers in this form are performed using \"school\" algorithms of column addition, subtraction, multiplication and division. It's also possible to use fast multiplication algorithms: fast Fourier transform and Karatsuba algorithm. Here we describe long arithmetic for only non-negative integers. To extend the algorithms to handle negative integers one has to introduce and maintain additional \"negative number\" flag or use two's complement integer representation. Data Structure \u00b6 We'll store numbers as a vector<int> , in which each element is a single \"digit\" of the number. typedef vector < int > lnum ; To improve performance we'll use $10^9$ as the base, so that each \"digit\" of the long number contains 9 decimal digits at once. const int base = 1000 * 1000 * 1000 ; Digits will be stored in order from least to most significant. All operations will be implemented so that after each of them the result doesn't have any leading zeros, as long as operands didn't have any leading zeros either. All operations which might result in a number with leading zeros should be followed by code which removes them. Note that in this representation there are two valid notations for number zero: and empty vector, and a vector with a single zero digit. Output \u00b6 Printing the long integer is the easiest operation. First we print the last element of the vector (or 0 if the vector is empty), followed by the rest of the elements padded with leading zeros if necessary so that they are exactly 9 digits long. printf ( \"%d\" , a . empty () ? 0 : a . back ()); for ( int i = ( int ) a . size () -2 ; i >= 0 ; -- i ) printf ( \"%09d\" , a [ i ]); Note that we cast a.size() to integer to avoid unsigned integer underflow if vector contains less than 2 elements. Input \u00b6 To read a long integer, read its notation into a string and then convert it to \"digits\": for ( int i = ( int ) s . length (); i > 0 ; i -= 9 ) if ( i < 9 ) a . push_back ( atoi ( s . substr ( 0 , i ). c_str ())); else a . push_back ( atoi ( s . substr ( i -9 , 9 ). c_str ())); If we use an array of char instead of a string , the code will be even shorter: for ( int i = ( int ) strlen ( s ); i > 0 ; i -= 9 ) { s [ i ] = 0 ; a . push_back ( atoi ( i >= 9 ? s + i -9 : s )); } If the input can contain leading zeros, they can be removed as follows: while ( a . size () > 1 && a . back () == 0 ) a . pop_back (); Addition \u00b6 Increment long integer $a$ by $b$ and store result in $a$ : int carry = 0 ; for ( size_t i = 0 ; i < max ( a . size (), b . size ()) || carry ; ++ i ) { if ( i == a . size ()) a . push_back ( 0 ); a [ i ] += carry + ( i < b . size () ? b [ i ] : 0 ); carry = a [ i ] >= base ; if ( carry ) a [ i ] -= base ; } Subtraction \u00b6 Decrement long integer $a$ by $b$ ( $a \\ge b$ ) and store result in $a$ : int carry = 0 ; for ( size_t i = 0 ; i < b . size () || carry ; ++ i ) { a [ i ] -= carry + ( i < b . size () ? b [ i ] : 0 ); carry = a [ i ] < 0 ; if ( carry ) a [ i ] += base ; } while ( a . size () > 1 && a . back () == 0 ) a . pop_back (); Note that after performing subtraction we remove leading zeros to keep up with the premise that our long integers don't have leading zeros. Multiplication by short integer \u00b6 Multiply long integer $a$ by short integer $b$ ( $b < base$ ) and store result in $a$ : int carry = 0 ; for ( size_t i = 0 ; i < a . size () || carry ; ++ i ) { if ( i == a . size ()) a . push_back ( 0 ); long long cur = carry + a [ i ] * 1l l * b ; a [ i ] = int ( cur % base ); carry = int ( cur / base ); } while ( a . size () > 1 && a . back () == 0 ) a . pop_back (); Additional optimization: If runtime is extremely important, you can try to replace two divisions with one by finding only integer result of division (variable carry ) and then use it to find modulo using multiplication. This usually makes the code faster, though not dramatically. Multiplication by long integer \u00b6 Multiply long integers $a$ and $b$ and store result in $c$ : lnum c ( a . size () + b . size ()); for ( size_t i = 0 ; i < a . size (); ++ i ) for ( int j = 0 , carry = 0 ; j < ( int ) b . size () || carry ; ++ j ) { long long cur = c [ i + j ] + a [ i ] * 1l l * ( j < ( int ) b . size () ? b [ j ] : 0 ) + carry ; c [ i + j ] = int ( cur % base ); carry = int ( cur / base ); } while ( c . size () > 1 && c . back () == 0 ) c . pop_back (); Division by short integer \u00b6 Divide long integer $a$ by short integer $b$ ( $b < base$ ), store integer result in $a$ and remainder in carry : int carry = 0 ; for ( int i = ( int ) a . size () -1 ; i >= 0 ; -- i ) { long long cur = a [ i ] + carry * 1l l * base ; a [ i ] = int ( cur / b ); carry = int ( cur % b ); } while ( a . size () > 1 && a . back () == 0 ) a . pop_back (); Long Integer Arithmetic for Factorization Representation \u00b6 The idea is to store the integer as its factorization, i.e. the powers of primes which divide it. This approach is very easy to implement, and allows to do multiplication and division easily (asymptotically faster than the classical method), but not addition or subtraction. It is also very memory-efficient compared to the classical approach. This method is often used for calculations modulo non-prime number M; in this case a number is stored as powers of divisors of M which divide the number, plus the remainder modulo M. Long Integer Arithmetic in prime modulos (Garner Algorithm) \u00b6 The idea is to choose a set of prime numbers (typically they are small enough to fit into standard integer data type) and to store an integer as a vector of remainders from division of the integer by each of those primes. Chinese remainder theorem states that this representation is sufficient to uniquely restore any number from 0 to product of these primes minus one. Garner algorithm allows to restore the number from such representation to normal integer. This method allows to save memory compared to the classical approach (though the savings are not as dramatic as in factorization representation). Besides, it allows to perform fast addition, subtraction and multiplication in time proportional to the number of prime numbers used as modulos (see Chinese remainder theorem article for implementation). The tradeoff is that converting the integer back to normal form is rather laborious and requires implementing classical arbitrary-precision arithmetic with multiplication. Besides, this method doesn't support division. Fractional Arbitrary-Precision Arithmetic \u00b6 Fractions occur in programming competitions less frequently than integers, and long arithmetic is much trickier to implement for fractions, so programming competitions feature only a small subset of fractional long arithmetic. Arithmetic in Irreducible Fractions \u00b6 A number is represented as an irreducible fraction $\\frac{a}{b}$ , where $a$ and $b$ are integers. All operations on fractions can be represented as operations on integer numerators and denominators of these fractions. Usually this requires using classical arbitrary-precision arithmetic for storing numerator and denominator, but sometimes a built-in 64-bit integer data type suffices. Storing Floating Point Position as Separate Type \u00b6 Sometimes a problem requires handling very small or very large numbers without allowing overflow or underflow. Built-in double data type uses 8-10 bytes and allows values of the exponent in $[-308; 308]$ range, which sometimes might be insufficient. The approach is very simple: a separate integer variable is used to store the value of the exponent, and after each operation the floating-point number is normalized, i.e. returned to $[0.1; 1)$ interval by adjusting the exponent accordingly. When two such numbers are multiplied or divided, their exponents should be added or subtracted, respectively. When numbers are added or subtracted, they have to be brought to common exponent first by multiplying one of them by 10 raised to the power equal to the difference of exponent values. As a final note, the exponent base doesn't have to equal 10. Based on the internal representation of floating-point numbers, it makes most sense to use 2 as the exponent base. Practice Problems \u00b6 UVA - How Many Fibs? UVA - Product UVA - Maximum Sub-sequence Product SPOJ - Fast Multiplication SPOJ - GCD2 UVA - Division UVA - Fibonacci Freeze UVA - Krakovia UVA - Simplifying Fractions UVA - 500! Hackerrank - Factorial digit sum UVA - Immortal Rabbits SPOJ - 0110SS Codeforces - Notepad","title":"Arbitrary-Precision Arithmetic"},{"location":"algebra/big-integer.html#arbitrary-precision-arithmetic","text":"Arbitrary-Precision arithmetic, also known as \"bignum\" or simply \"long arithmetic\" is a set of data structures and algorithms which allows to process much greater numbers than can be fit in standard data types. Here are several types of arbitrary-precision arithmetic.","title":"Arbitrary-Precision Arithmetic"},{"location":"algebra/big-integer.html#classical-integer-long-arithmetic","text":"The main idea is that the number is stored as an array of its \"digits\" in some base. Several most frequently used bases are decimal, powers of decimal ( $10^4$ or $10^9$ ) and binary. Operations on numbers in this form are performed using \"school\" algorithms of column addition, subtraction, multiplication and division. It's also possible to use fast multiplication algorithms: fast Fourier transform and Karatsuba algorithm. Here we describe long arithmetic for only non-negative integers. To extend the algorithms to handle negative integers one has to introduce and maintain additional \"negative number\" flag or use two's complement integer representation.","title":"Classical Integer Long Arithmetic"},{"location":"algebra/big-integer.html#data-structure","text":"We'll store numbers as a vector<int> , in which each element is a single \"digit\" of the number. typedef vector < int > lnum ; To improve performance we'll use $10^9$ as the base, so that each \"digit\" of the long number contains 9 decimal digits at once. const int base = 1000 * 1000 * 1000 ; Digits will be stored in order from least to most significant. All operations will be implemented so that after each of them the result doesn't have any leading zeros, as long as operands didn't have any leading zeros either. All operations which might result in a number with leading zeros should be followed by code which removes them. Note that in this representation there are two valid notations for number zero: and empty vector, and a vector with a single zero digit.","title":"Data Structure"},{"location":"algebra/big-integer.html#output","text":"Printing the long integer is the easiest operation. First we print the last element of the vector (or 0 if the vector is empty), followed by the rest of the elements padded with leading zeros if necessary so that they are exactly 9 digits long. printf ( \"%d\" , a . empty () ? 0 : a . back ()); for ( int i = ( int ) a . size () -2 ; i >= 0 ; -- i ) printf ( \"%09d\" , a [ i ]); Note that we cast a.size() to integer to avoid unsigned integer underflow if vector contains less than 2 elements.","title":"Output"},{"location":"algebra/big-integer.html#input","text":"To read a long integer, read its notation into a string and then convert it to \"digits\": for ( int i = ( int ) s . length (); i > 0 ; i -= 9 ) if ( i < 9 ) a . push_back ( atoi ( s . substr ( 0 , i ). c_str ())); else a . push_back ( atoi ( s . substr ( i -9 , 9 ). c_str ())); If we use an array of char instead of a string , the code will be even shorter: for ( int i = ( int ) strlen ( s ); i > 0 ; i -= 9 ) { s [ i ] = 0 ; a . push_back ( atoi ( i >= 9 ? s + i -9 : s )); } If the input can contain leading zeros, they can be removed as follows: while ( a . size () > 1 && a . back () == 0 ) a . pop_back ();","title":"Input"},{"location":"algebra/big-integer.html#addition","text":"Increment long integer $a$ by $b$ and store result in $a$ : int carry = 0 ; for ( size_t i = 0 ; i < max ( a . size (), b . size ()) || carry ; ++ i ) { if ( i == a . size ()) a . push_back ( 0 ); a [ i ] += carry + ( i < b . size () ? b [ i ] : 0 ); carry = a [ i ] >= base ; if ( carry ) a [ i ] -= base ; }","title":"Addition"},{"location":"algebra/big-integer.html#subtraction","text":"Decrement long integer $a$ by $b$ ( $a \\ge b$ ) and store result in $a$ : int carry = 0 ; for ( size_t i = 0 ; i < b . size () || carry ; ++ i ) { a [ i ] -= carry + ( i < b . size () ? b [ i ] : 0 ); carry = a [ i ] < 0 ; if ( carry ) a [ i ] += base ; } while ( a . size () > 1 && a . back () == 0 ) a . pop_back (); Note that after performing subtraction we remove leading zeros to keep up with the premise that our long integers don't have leading zeros.","title":"Subtraction"},{"location":"algebra/big-integer.html#multiplication-by-short-integer","text":"Multiply long integer $a$ by short integer $b$ ( $b < base$ ) and store result in $a$ : int carry = 0 ; for ( size_t i = 0 ; i < a . size () || carry ; ++ i ) { if ( i == a . size ()) a . push_back ( 0 ); long long cur = carry + a [ i ] * 1l l * b ; a [ i ] = int ( cur % base ); carry = int ( cur / base ); } while ( a . size () > 1 && a . back () == 0 ) a . pop_back (); Additional optimization: If runtime is extremely important, you can try to replace two divisions with one by finding only integer result of division (variable carry ) and then use it to find modulo using multiplication. This usually makes the code faster, though not dramatically.","title":"Multiplication by short integer"},{"location":"algebra/big-integer.html#multiplication-by-long-integer","text":"Multiply long integers $a$ and $b$ and store result in $c$ : lnum c ( a . size () + b . size ()); for ( size_t i = 0 ; i < a . size (); ++ i ) for ( int j = 0 , carry = 0 ; j < ( int ) b . size () || carry ; ++ j ) { long long cur = c [ i + j ] + a [ i ] * 1l l * ( j < ( int ) b . size () ? b [ j ] : 0 ) + carry ; c [ i + j ] = int ( cur % base ); carry = int ( cur / base ); } while ( c . size () > 1 && c . back () == 0 ) c . pop_back ();","title":"Multiplication by long integer"},{"location":"algebra/big-integer.html#division-by-short-integer","text":"Divide long integer $a$ by short integer $b$ ( $b < base$ ), store integer result in $a$ and remainder in carry : int carry = 0 ; for ( int i = ( int ) a . size () -1 ; i >= 0 ; -- i ) { long long cur = a [ i ] + carry * 1l l * base ; a [ i ] = int ( cur / b ); carry = int ( cur % b ); } while ( a . size () > 1 && a . back () == 0 ) a . pop_back ();","title":"Division by short integer"},{"location":"algebra/big-integer.html#long-integer-arithmetic-for-factorization-representation","text":"The idea is to store the integer as its factorization, i.e. the powers of primes which divide it. This approach is very easy to implement, and allows to do multiplication and division easily (asymptotically faster than the classical method), but not addition or subtraction. It is also very memory-efficient compared to the classical approach. This method is often used for calculations modulo non-prime number M; in this case a number is stored as powers of divisors of M which divide the number, plus the remainder modulo M.","title":"Long Integer Arithmetic for Factorization Representation"},{"location":"algebra/big-integer.html#long-integer-arithmetic-in-prime-modulos-garner-algorithm","text":"The idea is to choose a set of prime numbers (typically they are small enough to fit into standard integer data type) and to store an integer as a vector of remainders from division of the integer by each of those primes. Chinese remainder theorem states that this representation is sufficient to uniquely restore any number from 0 to product of these primes minus one. Garner algorithm allows to restore the number from such representation to normal integer. This method allows to save memory compared to the classical approach (though the savings are not as dramatic as in factorization representation). Besides, it allows to perform fast addition, subtraction and multiplication in time proportional to the number of prime numbers used as modulos (see Chinese remainder theorem article for implementation). The tradeoff is that converting the integer back to normal form is rather laborious and requires implementing classical arbitrary-precision arithmetic with multiplication. Besides, this method doesn't support division.","title":"Long Integer Arithmetic in prime modulos (Garner Algorithm)"},{"location":"algebra/big-integer.html#fractional-arbitrary-precision-arithmetic","text":"Fractions occur in programming competitions less frequently than integers, and long arithmetic is much trickier to implement for fractions, so programming competitions feature only a small subset of fractional long arithmetic.","title":"Fractional Arbitrary-Precision Arithmetic"},{"location":"algebra/big-integer.html#arithmetic-in-irreducible-fractions","text":"A number is represented as an irreducible fraction $\\frac{a}{b}$ , where $a$ and $b$ are integers. All operations on fractions can be represented as operations on integer numerators and denominators of these fractions. Usually this requires using classical arbitrary-precision arithmetic for storing numerator and denominator, but sometimes a built-in 64-bit integer data type suffices.","title":"Arithmetic in Irreducible Fractions"},{"location":"algebra/big-integer.html#storing-floating-point-position-as-separate-type","text":"Sometimes a problem requires handling very small or very large numbers without allowing overflow or underflow. Built-in double data type uses 8-10 bytes and allows values of the exponent in $[-308; 308]$ range, which sometimes might be insufficient. The approach is very simple: a separate integer variable is used to store the value of the exponent, and after each operation the floating-point number is normalized, i.e. returned to $[0.1; 1)$ interval by adjusting the exponent accordingly. When two such numbers are multiplied or divided, their exponents should be added or subtracted, respectively. When numbers are added or subtracted, they have to be brought to common exponent first by multiplying one of them by 10 raised to the power equal to the difference of exponent values. As a final note, the exponent base doesn't have to equal 10. Based on the internal representation of floating-point numbers, it makes most sense to use 2 as the exponent base.","title":"Storing Floating Point Position as Separate Type"},{"location":"algebra/big-integer.html#practice-problems","text":"UVA - How Many Fibs? UVA - Product UVA - Maximum Sub-sequence Product SPOJ - Fast Multiplication SPOJ - GCD2 UVA - Division UVA - Fibonacci Freeze UVA - Krakovia UVA - Simplifying Fractions UVA - 500! Hackerrank - Factorial digit sum UVA - Immortal Rabbits SPOJ - 0110SS Codeforces - Notepad","title":"Practice Problems"},{"location":"algebra/binary-exp.html","text":"Binary Exponentiation \u00b6 Binary exponentiation (also known as exponentiation by squaring) is a trick which allows to calculate $a^n$ using only $O(\\log n)$ multiplications (instead of $O(n)$ multiplications required by the naive approach). It also has important applications in many tasks unrelated to arithmetic, since it can be used with any operations that have the property of associativity : $$(X \\cdot Y) \\cdot Z = X \\cdot (Y \\cdot Z)$$ Most obviously this applies to modular multiplication, to multiplication of matrices and to other problems which we will discuss below. Algorithm \u00b6 Raising $a$ to the power of $n$ is expressed naively as multiplication by $a$ done $n - 1$ times: $a^{n} = a \\cdot a \\cdot \\ldots \\cdot a$ . However, this approach is not practical for large $a$ or $n$ . $a^{b+c} = a^b \\cdot a^c$ and $a^{2b} = a^b \\cdot a^b = (a^b)^2$ . The idea of binary exponentiation is, that we split the work using the binary representation of the exponent. Let's write $n$ in base 2, for example: $$3^{13} = 3^{1101_2} = 3^8 \\cdot 3^4 \\cdot 3^1$$ Since the number $n$ has exactly $\\lfloor \\log_2 n \\rfloor + 1$ digits in base 2, we only need to perform $O(\\log n)$ multiplications, if we know the powers $a^1, a^2, a^4, a^8, \\dots, a^{2^{\\lfloor \\log n \\rfloor}}$ . So we only need to know a fast way to compute those. Luckily this is very easy, since an element in the sequence is just the square of the previous element. $$\\begin{align} 3^1 &= 3 \\\\ 3^2 &= \\left(3^1\\right)^2 = 3^2 = 9 \\\\ 3^4 &= \\left(3^2\\right)^2 = 9^2 = 81 \\\\ 3^8 &= \\left(3^4\\right)^2 = 81^2 = 6561 \\end{align}$$ So to get the final answer for $3^{13}$ , we only need to multiply three of them (skipping $3^2$ because the corresponding bit in $n$ is not set): $3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323$ The final complexity of this algorithm is $O(\\log n)$ : we have to compute $\\log n$ powers of $a$ , and then have to do at most $\\log n$ multiplications to get the final answer from them. The following recursive approach expresses the same idea: $$a^n = \\begin{cases} 1 &\\text{if } n == 0 \\\\ \\left(a^{\\frac{n}{2}}\\right)^2 &\\text{if } n > 0 \\text{ and } n \\text{ even}\\\\ \\left(a^{\\frac{n - 1}{2}}\\right)^2 \\cdot a &\\text{if } n > 0 \\text{ and } n \\text{ odd}\\\\ \\end{cases}$$ Implementation \u00b6 First the recursive approach, which is a direct translation of the recursive formula: long long binpow ( long long a , long long b ) { if ( b == 0 ) return 1 ; long long res = binpow ( a , b / 2 ); if ( b % 2 ) return res * res * a ; else return res * res ; } The second approach accomplishes the same task without recursion. It computes all the powers in a loop, and multiplies the ones with the corresponding set bit in $n$ . Although the complexity of both approaches is identical, this approach will be faster in practice since we don't have the overhead of the recursive calls. long long binpow ( long long a , long long b ) { long long res = 1 ; while ( b > 0 ) { if ( b & 1 ) res = res * a ; a = a * a ; b >>= 1 ; } return res ; } Applications \u00b6 Effective computation of large exponents modulo a number \u00b6 Problem: Compute $x^n \\bmod m$ . This is a very common operation. For instance it is used in computing the modular multiplicative inverse . Solution: Since we know that the modulo operator doesn't interfere with multiplications ( $a \\cdot b \\equiv (a \\bmod m) \\cdot (b \\bmod m) \\pmod m$ ), we can directly use the same code, and just replace every multiplication with a modular multiplication: long long binpow ( long long a , long long b , long long m ) { a %= m ; long long res = 1 ; while ( b > 0 ) { if ( b & 1 ) res = res * a % m ; a = a * a % m ; b >>= 1 ; } return res ; } Note: It's possible to speed this algorithm for large $b >> m$ . If $m$ is a prime number $x^n \\equiv x^{n \\bmod (m-1)} \\pmod{m}$ for prime $m$ , and $x^n \\equiv x^{n \\bmod{\\phi(m)}} \\pmod{m}$ for composite $m$ . This follows directly from Fermat's little theorem and Euler's theorem, see the article about Modular Inverses for more details. Effective computation of Fibonacci numbers \u00b6 Problem: Compute $n$ -th Fibonacci number $F_n$ . Solution: For more details, see the Fibonacci Number article . We will only go through an overview of the algorithm. To compute the next Fibonacci number, only the two previous ones are needed, as $F_n = F_{n-1} + F_{n-2}$ . We can build a $2 \\times 2$ matrix that describes this transformation: the transition from $F_i$ and $F_{i+1}$ to $F_{i+1}$ and $F_{i+2}$ . For example, applying this transformation to the pair $F_0$ and $F_1$ would change it into $F_1$ and $F_2$ . Therefore, we can raise this transformation matrix to the $n$ -th power to find $F_n$ in time complexity $O(\\log n)$ . Applying a permutation $k$ times \u00b6 Problem: You are given a sequence of length $n$ . Apply to it a given permutation $k$ times. Solution: Simply raise the permutation to $k$ -th power using binary exponentiation, and then apply it to the sequence. This will give you a time complexity of $O(n \\log k)$ . vector < int > applyPermutation ( vector < int > sequence , vector < int > permutation ) { vector < int > newSequence ( sequence . size ()); for ( int i = 0 ; i < sequence . size (); i ++ ) { newSequence [ i ] = sequence [ permutation [ i ]]; } return newSequence ; } vector < int > permute ( vector < int > sequence , vector < int > permutation , long long k ) { while ( k > 0 ) { if ( k & 1 ) { sequence = applyPermutation ( sequence , permutation ); } permutation = applyPermutation ( permutation , permutation ); k >>= 1 ; } return sequence ; } Note: This task can be solved more efficiently in linear time by building the permutation graph and considering each cycle independently. You could then compute $k$ modulo the size of the cycle and find the final position for each number which is part of this cycle. Fast application of a set of geometric operations to a set of points \u00b6 Problem: Given $n$ points $p_i$ , apply $m$ transformations to each of these points. Each transformation can be a shift, a scaling or a rotation around a given axis by a given angle. There is also a \"loop\" operation which applies a given list of transformations $k$ times (\"loop\" operations can be nested). You should apply all transformations faster than $O(n \\cdot length)$ , where $length$ is the total number of transformations to be applied (after unrolling \"loop\" operations). Solution: Let's look at how the different types of transformations change the coordinates: Shift operation: adds a different constant to each of the coordinates. Scaling operation: multiplies each of the coordinates by a different constant. Rotation operation: the transformation is more complicated (we won't go in details here), but each of the new coordinates still can be represented as a linear combination of the old ones. As you can see, each of the transformations can be represented as a linear operation on the coordinates. Thus, a transformation can be written as a $4 \\times 4$ matrix of the form: $$\\begin{pmatrix} a_{11} & a_ {12} & a_ {13} & a_ {14} \\\\ a_{21} & a_ {22} & a_ {23} & a_ {24} \\\\ a_{31} & a_ {32} & a_ {33} & a_ {34} \\\\ a_{41} & a_ {42} & a_ {43} & a_ {44} \\end{pmatrix}$$ that, when multiplied by a vector with the old coordinates and an unit gives a new vector with the new coordinates and an unit: $$\\begin{pmatrix} x & y & z & 1 \\end{pmatrix} \\cdot \\begin{pmatrix} a_{11} & a_ {12} & a_ {13} & a_ {14} \\\\ a_{21} & a_ {22} & a_ {23} & a_ {24} \\\\ a_{31} & a_ {32} & a_ {33} & a_ {34} \\\\ a_{41} & a_ {42} & a_ {43} & a_ {44} \\end{pmatrix} = \\begin{pmatrix} x' & y' & z' & 1 \\end{pmatrix}$$ (Why introduce a fictitious fourth coordinate, you ask? That is the beauty of homogeneous coordinates , which find great application in computer graphics. Without this, it would not be possible to implement affine operations like the shift operation as a single matrix multiplication, as it requires us to add a constant to the coordinates. The affine transformation becomes a linear transformation in the higher dimension!) Here are some examples of how transformations are represented in matrix form: Shift operation: shift $x$ coordinate by $5$ , $y$ coordinate by $7$ and $z$ coordinate by $9$ . $$\\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 5 & 7 & 9 & 1 \\end{pmatrix}$$ Scaling operation: scale the $x$ coordinate by $10$ and the other two by $5$ . $$\\begin{pmatrix} 10 & 0 & 0 & 0 \\\\ 0 & 5 & 0 & 0 \\\\ 0 & 0 & 5 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$ Rotation operation: rotate $\\theta$ degrees around the $x$ axis following the right-hand rule (counter-clockwise direction). $$\\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & \\cos \\theta & -\\sin \\theta & 0 \\\\ 0 & \\sin \\theta & \\cos \\theta & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$ Now, once every transformation is described as a matrix, the sequence of transformations can be described as a product of these matrices, and a \"loop\" of $k$ repetitions can be described as the matrix raised to the power of $k$ (which can be calculated using binary exponentiation in $O(\\log{k})$ ). This way, the matrix which represents all transformations can be calculated first in $O(m \\log{k})$ , and then it can be applied to each of the $n$ points in $O(n)$ for a total complexity of $O(n + m \\log{k})$ . Number of paths of length $k$ in a graph \u00b6 Problem: Given a directed unweighted graph of $n$ vertices, find the number of paths of length $k$ from any vertex $u$ to any other vertex $v$ . Solution: This problem is considered in more detail in a separate article . The algorithm consists of raising the adjacency matrix $M$ of the graph (a matrix where $m_{ij} = 1$ if there is an edge from $i$ to $j$ , or $0$ otherwise) to the $k$ -th power. Now $m_{ij}$ will be the number of paths of length $k$ from $i$ to $j$ . The time complexity of this solution is $O(n^3 \\log k)$ . Note: In that same article, another variation of this problem is considered: when the edges are weighted and it is required to find the minimum weight path containing exactly $k$ edges. As shown in that article, this problem is also solved by exponentiation of the adjacency matrix. The matrix would have the weight of the edge from $i$ to $j$ , or $\\infty$ if there is no such edge. Instead of the usual operation of multiplying two matrices, a modified one should be used: instead of multiplication, both values are added, and instead of a summation, a minimum is taken. That is: $result_{ij} = \\min\\limits_{1\\ \\leq\\ k\\ \\leq\\ n}(a_{ik} + b_{kj})$ . Variation of binary exponentiation: multiplying two numbers modulo $m$ \u00b6 Problem: Multiply two numbers $a$ and $b$ modulo $m$ . $a$ and $b$ fit in the built-in data types, but their product is too big to fit in a 64-bit integer. The idea is to compute $a \\cdot b \\pmod m$ without using bignum arithmetics. Solution: We simply apply the binary construction algorithm described above, only performing additions instead of multiplications. In other words, we have \"expanded\" the multiplication of two numbers to $O (\\log m)$ operations of addition and multiplication by two (which, in essence, is an addition). $$a \\cdot b = \\begin{cases} 0 &\\text{if }a = 0 \\\\ 2 \\cdot \\frac{a}{2} \\cdot b &\\text{if }a > 0 \\text{ and }a \\text{ even} \\\\ 2 \\cdot \\frac{a-1}{2} \\cdot b + b &\\text{if }a > 0 \\text{ and }a \\text{ odd} \\end{cases}$$ Note: You can solve this task in a different way by using floating-point operations. First compute the expression $\\frac{a \\cdot b}{m}$ using floating-point numbers and cast it to an unsigned integer $q$ . Subtract $q \\cdot m$ from $a \\cdot b$ using unsigned integer arithmetics and take it modulo $m$ to find the answer. This solution looks rather unreliable, but it is very fast, and very easy to implement. See here for more information. Practice Problems \u00b6 UVa 1230 - MODEX UVa 374 - Big Mod UVa 11029 - Leading and Trailing Codeforces - Parking Lot leetcode - Count good numbers Codechef - Chef and Riffles Codeforces - Decoding Genome Codeforces - Neural Network Country Codeforces - Magic Gems SPOJ - The last digit SPOJ - Locker LA - 3722 Jewel-eating Monsters SPOJ - Just add it Codeforces - Stairs and Lines","title":"Binary Exponentiation"},{"location":"algebra/binary-exp.html#binary-exponentiation","text":"Binary exponentiation (also known as exponentiation by squaring) is a trick which allows to calculate $a^n$ using only $O(\\log n)$ multiplications (instead of $O(n)$ multiplications required by the naive approach). It also has important applications in many tasks unrelated to arithmetic, since it can be used with any operations that have the property of associativity : $$(X \\cdot Y) \\cdot Z = X \\cdot (Y \\cdot Z)$$ Most obviously this applies to modular multiplication, to multiplication of matrices and to other problems which we will discuss below.","title":"Binary Exponentiation"},{"location":"algebra/binary-exp.html#algorithm","text":"Raising $a$ to the power of $n$ is expressed naively as multiplication by $a$ done $n - 1$ times: $a^{n} = a \\cdot a \\cdot \\ldots \\cdot a$ . However, this approach is not practical for large $a$ or $n$ . $a^{b+c} = a^b \\cdot a^c$ and $a^{2b} = a^b \\cdot a^b = (a^b)^2$ . The idea of binary exponentiation is, that we split the work using the binary representation of the exponent. Let's write $n$ in base 2, for example: $$3^{13} = 3^{1101_2} = 3^8 \\cdot 3^4 \\cdot 3^1$$ Since the number $n$ has exactly $\\lfloor \\log_2 n \\rfloor + 1$ digits in base 2, we only need to perform $O(\\log n)$ multiplications, if we know the powers $a^1, a^2, a^4, a^8, \\dots, a^{2^{\\lfloor \\log n \\rfloor}}$ . So we only need to know a fast way to compute those. Luckily this is very easy, since an element in the sequence is just the square of the previous element. $$\\begin{align} 3^1 &= 3 \\\\ 3^2 &= \\left(3^1\\right)^2 = 3^2 = 9 \\\\ 3^4 &= \\left(3^2\\right)^2 = 9^2 = 81 \\\\ 3^8 &= \\left(3^4\\right)^2 = 81^2 = 6561 \\end{align}$$ So to get the final answer for $3^{13}$ , we only need to multiply three of them (skipping $3^2$ because the corresponding bit in $n$ is not set): $3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323$ The final complexity of this algorithm is $O(\\log n)$ : we have to compute $\\log n$ powers of $a$ , and then have to do at most $\\log n$ multiplications to get the final answer from them. The following recursive approach expresses the same idea: $$a^n = \\begin{cases} 1 &\\text{if } n == 0 \\\\ \\left(a^{\\frac{n}{2}}\\right)^2 &\\text{if } n > 0 \\text{ and } n \\text{ even}\\\\ \\left(a^{\\frac{n - 1}{2}}\\right)^2 \\cdot a &\\text{if } n > 0 \\text{ and } n \\text{ odd}\\\\ \\end{cases}$$","title":"Algorithm"},{"location":"algebra/binary-exp.html#implementation","text":"First the recursive approach, which is a direct translation of the recursive formula: long long binpow ( long long a , long long b ) { if ( b == 0 ) return 1 ; long long res = binpow ( a , b / 2 ); if ( b % 2 ) return res * res * a ; else return res * res ; } The second approach accomplishes the same task without recursion. It computes all the powers in a loop, and multiplies the ones with the corresponding set bit in $n$ . Although the complexity of both approaches is identical, this approach will be faster in practice since we don't have the overhead of the recursive calls. long long binpow ( long long a , long long b ) { long long res = 1 ; while ( b > 0 ) { if ( b & 1 ) res = res * a ; a = a * a ; b >>= 1 ; } return res ; }","title":"Implementation"},{"location":"algebra/binary-exp.html#applications","text":"","title":"Applications"},{"location":"algebra/binary-exp.html#effective-computation-of-large-exponents-modulo-a-number","text":"Problem: Compute $x^n \\bmod m$ . This is a very common operation. For instance it is used in computing the modular multiplicative inverse . Solution: Since we know that the modulo operator doesn't interfere with multiplications ( $a \\cdot b \\equiv (a \\bmod m) \\cdot (b \\bmod m) \\pmod m$ ), we can directly use the same code, and just replace every multiplication with a modular multiplication: long long binpow ( long long a , long long b , long long m ) { a %= m ; long long res = 1 ; while ( b > 0 ) { if ( b & 1 ) res = res * a % m ; a = a * a % m ; b >>= 1 ; } return res ; } Note: It's possible to speed this algorithm for large $b >> m$ . If $m$ is a prime number $x^n \\equiv x^{n \\bmod (m-1)} \\pmod{m}$ for prime $m$ , and $x^n \\equiv x^{n \\bmod{\\phi(m)}} \\pmod{m}$ for composite $m$ . This follows directly from Fermat's little theorem and Euler's theorem, see the article about Modular Inverses for more details.","title":"Effective computation of large exponents modulo a number"},{"location":"algebra/binary-exp.html#effective-computation-of-fibonacci-numbers","text":"Problem: Compute $n$ -th Fibonacci number $F_n$ . Solution: For more details, see the Fibonacci Number article . We will only go through an overview of the algorithm. To compute the next Fibonacci number, only the two previous ones are needed, as $F_n = F_{n-1} + F_{n-2}$ . We can build a $2 \\times 2$ matrix that describes this transformation: the transition from $F_i$ and $F_{i+1}$ to $F_{i+1}$ and $F_{i+2}$ . For example, applying this transformation to the pair $F_0$ and $F_1$ would change it into $F_1$ and $F_2$ . Therefore, we can raise this transformation matrix to the $n$ -th power to find $F_n$ in time complexity $O(\\log n)$ .","title":"Effective computation of Fibonacci numbers"},{"location":"algebra/binary-exp.html#applying-a-permutation-k-times","text":"Problem: You are given a sequence of length $n$ . Apply to it a given permutation $k$ times. Solution: Simply raise the permutation to $k$ -th power using binary exponentiation, and then apply it to the sequence. This will give you a time complexity of $O(n \\log k)$ . vector < int > applyPermutation ( vector < int > sequence , vector < int > permutation ) { vector < int > newSequence ( sequence . size ()); for ( int i = 0 ; i < sequence . size (); i ++ ) { newSequence [ i ] = sequence [ permutation [ i ]]; } return newSequence ; } vector < int > permute ( vector < int > sequence , vector < int > permutation , long long k ) { while ( k > 0 ) { if ( k & 1 ) { sequence = applyPermutation ( sequence , permutation ); } permutation = applyPermutation ( permutation , permutation ); k >>= 1 ; } return sequence ; } Note: This task can be solved more efficiently in linear time by building the permutation graph and considering each cycle independently. You could then compute $k$ modulo the size of the cycle and find the final position for each number which is part of this cycle.","title":"Applying a permutation k times"},{"location":"algebra/binary-exp.html#fast-application-of-a-set-of-geometric-operations-to-a-set-of-points","text":"Problem: Given $n$ points $p_i$ , apply $m$ transformations to each of these points. Each transformation can be a shift, a scaling or a rotation around a given axis by a given angle. There is also a \"loop\" operation which applies a given list of transformations $k$ times (\"loop\" operations can be nested). You should apply all transformations faster than $O(n \\cdot length)$ , where $length$ is the total number of transformations to be applied (after unrolling \"loop\" operations). Solution: Let's look at how the different types of transformations change the coordinates: Shift operation: adds a different constant to each of the coordinates. Scaling operation: multiplies each of the coordinates by a different constant. Rotation operation: the transformation is more complicated (we won't go in details here), but each of the new coordinates still can be represented as a linear combination of the old ones. As you can see, each of the transformations can be represented as a linear operation on the coordinates. Thus, a transformation can be written as a $4 \\times 4$ matrix of the form: $$\\begin{pmatrix} a_{11} & a_ {12} & a_ {13} & a_ {14} \\\\ a_{21} & a_ {22} & a_ {23} & a_ {24} \\\\ a_{31} & a_ {32} & a_ {33} & a_ {34} \\\\ a_{41} & a_ {42} & a_ {43} & a_ {44} \\end{pmatrix}$$ that, when multiplied by a vector with the old coordinates and an unit gives a new vector with the new coordinates and an unit: $$\\begin{pmatrix} x & y & z & 1 \\end{pmatrix} \\cdot \\begin{pmatrix} a_{11} & a_ {12} & a_ {13} & a_ {14} \\\\ a_{21} & a_ {22} & a_ {23} & a_ {24} \\\\ a_{31} & a_ {32} & a_ {33} & a_ {34} \\\\ a_{41} & a_ {42} & a_ {43} & a_ {44} \\end{pmatrix} = \\begin{pmatrix} x' & y' & z' & 1 \\end{pmatrix}$$ (Why introduce a fictitious fourth coordinate, you ask? That is the beauty of homogeneous coordinates , which find great application in computer graphics. Without this, it would not be possible to implement affine operations like the shift operation as a single matrix multiplication, as it requires us to add a constant to the coordinates. The affine transformation becomes a linear transformation in the higher dimension!) Here are some examples of how transformations are represented in matrix form: Shift operation: shift $x$ coordinate by $5$ , $y$ coordinate by $7$ and $z$ coordinate by $9$ . $$\\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 5 & 7 & 9 & 1 \\end{pmatrix}$$ Scaling operation: scale the $x$ coordinate by $10$ and the other two by $5$ . $$\\begin{pmatrix} 10 & 0 & 0 & 0 \\\\ 0 & 5 & 0 & 0 \\\\ 0 & 0 & 5 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$ Rotation operation: rotate $\\theta$ degrees around the $x$ axis following the right-hand rule (counter-clockwise direction). $$\\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & \\cos \\theta & -\\sin \\theta & 0 \\\\ 0 & \\sin \\theta & \\cos \\theta & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$ Now, once every transformation is described as a matrix, the sequence of transformations can be described as a product of these matrices, and a \"loop\" of $k$ repetitions can be described as the matrix raised to the power of $k$ (which can be calculated using binary exponentiation in $O(\\log{k})$ ). This way, the matrix which represents all transformations can be calculated first in $O(m \\log{k})$ , and then it can be applied to each of the $n$ points in $O(n)$ for a total complexity of $O(n + m \\log{k})$ .","title":"Fast application of a set of geometric operations to a set of points"},{"location":"algebra/binary-exp.html#number-of-paths-of-length-k-in-a-graph","text":"Problem: Given a directed unweighted graph of $n$ vertices, find the number of paths of length $k$ from any vertex $u$ to any other vertex $v$ . Solution: This problem is considered in more detail in a separate article . The algorithm consists of raising the adjacency matrix $M$ of the graph (a matrix where $m_{ij} = 1$ if there is an edge from $i$ to $j$ , or $0$ otherwise) to the $k$ -th power. Now $m_{ij}$ will be the number of paths of length $k$ from $i$ to $j$ . The time complexity of this solution is $O(n^3 \\log k)$ . Note: In that same article, another variation of this problem is considered: when the edges are weighted and it is required to find the minimum weight path containing exactly $k$ edges. As shown in that article, this problem is also solved by exponentiation of the adjacency matrix. The matrix would have the weight of the edge from $i$ to $j$ , or $\\infty$ if there is no such edge. Instead of the usual operation of multiplying two matrices, a modified one should be used: instead of multiplication, both values are added, and instead of a summation, a minimum is taken. That is: $result_{ij} = \\min\\limits_{1\\ \\leq\\ k\\ \\leq\\ n}(a_{ik} + b_{kj})$ .","title":"Number of paths of length k in a graph"},{"location":"algebra/binary-exp.html#variation-of-binary-exponentiation-multiplying-two-numbers-modulo-m","text":"Problem: Multiply two numbers $a$ and $b$ modulo $m$ . $a$ and $b$ fit in the built-in data types, but their product is too big to fit in a 64-bit integer. The idea is to compute $a \\cdot b \\pmod m$ without using bignum arithmetics. Solution: We simply apply the binary construction algorithm described above, only performing additions instead of multiplications. In other words, we have \"expanded\" the multiplication of two numbers to $O (\\log m)$ operations of addition and multiplication by two (which, in essence, is an addition). $$a \\cdot b = \\begin{cases} 0 &\\text{if }a = 0 \\\\ 2 \\cdot \\frac{a}{2} \\cdot b &\\text{if }a > 0 \\text{ and }a \\text{ even} \\\\ 2 \\cdot \\frac{a-1}{2} \\cdot b + b &\\text{if }a > 0 \\text{ and }a \\text{ odd} \\end{cases}$$ Note: You can solve this task in a different way by using floating-point operations. First compute the expression $\\frac{a \\cdot b}{m}$ using floating-point numbers and cast it to an unsigned integer $q$ . Subtract $q \\cdot m$ from $a \\cdot b$ using unsigned integer arithmetics and take it modulo $m$ to find the answer. This solution looks rather unreliable, but it is very fast, and very easy to implement. See here for more information.","title":"Variation of binary exponentiation: multiplying two numbers modulo m"},{"location":"algebra/binary-exp.html#practice-problems","text":"UVa 1230 - MODEX UVa 374 - Big Mod UVa 11029 - Leading and Trailing Codeforces - Parking Lot leetcode - Count good numbers Codechef - Chef and Riffles Codeforces - Decoding Genome Codeforces - Neural Network Country Codeforces - Magic Gems SPOJ - The last digit SPOJ - Locker LA - 3722 Jewel-eating Monsters SPOJ - Just add it Codeforces - Stairs and Lines","title":"Practice Problems"},{"location":"algebra/bit-manipulation.html","text":"Bit manipulation \u00b6 Binary number \u00b6 A binary number is a number expressed in the base-2 numeral system or binary numeral system, it is a method of mathematical expression which uses only two symbols: typically \"0\" (zero) and \"1\" (one). We say that a certain bit is set , if it is one, and cleared if it is zero. The binary number $(a_k a_{k-1} \\dots a_1 a_0)_2$ represents the number: $$(a_k a_{k-1} \\dots a_1 a_0)_2 = a_k \\cdot 2^k + a_{k-1} \\cdot 2^{k-1} + \\dots + a_1 \\cdot 2^1 + a_0 \\cdot 2^0.$$ For instance the binary number $1101_2$ represents the number $13$ : $$\\begin{align} 1101_2 &= 1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 \\\\ &= 1\\cdot 8 + 1 \\cdot 4 + 0 \\cdot 2 + 1 \\cdot 1 = 13 \\end{align}$$ Computers represent integers as binary numbers. Positive integers (both signed and unsigned) are just represented with their binary digits, and negative signed numbers (which can be positive and negative) are usually represented with the Two's complement . unsigned int unsigned_number = 13 ; assert ( unsigned_number == 0b1101 ); int positive_signed_number = 13 ; assert ( positive_signed_number == 0b1101 ); int negative_signed_number = -13 ; assert ( negative_signed_number == 0b1111'1111'1111'1111'1111'1111'1111'0011 ); CPUs are very fast manipulating those bits with specific operations. For some problems we can take these binary number representations to our advantage, and speed up the execution time. And for some problems (typically in combinatorics or dynamic programming) where we want to track which objects we already picked from a given set of objects, we can just use an large enough integer where each digit represents an object and depending on if we pick or drop the object we set or clear the digit. Bit operators \u00b6 All those introduced operators are instant (same speed as an addition) on a CPU for fixed-length integers. Bitwise operators \u00b6 $\\&$ : The bitwise AND operator compares each bit of its first operand with the corresponding bit of its second operand. If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0. $|$ : The bitwise inclusive OR operator compares each bit of its first operand with the corresponding bit of its second operand. If one of the two bits is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0. $\\wedge$ : The bitwise exclusive OR (XOR) operator compares each bit of its first operand with the corresponding bit of its second operand. If one bit is 0 and the other bit is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0. $\\sim$ : The bitwise complement (NOT) operator flips each bit of a number, if a bit is set the operator will clear it, if it is cleared the operator sets it. Examples: n = 01011000 n-1 = 01010111 -------------------- n & (n-1) = 01010000 n = 01011000 n-1 = 01010111 -------------------- n | (n-1) = 01011111 n = 01011000 n-1 = 01010111 -------------------- n ^ (n-1) = 00001111 n = 01011000 -------------------- ~n = 10100111 Shift operators \u00b6 There are two operators for shifting bits. $\\gg$ Shifts a number to the right by removing the last few binary digits of the number. Each shift by one represents an integer division by 2, so a right shift by $k$ represents an integer division by $2^k$ . E.g. $5 \\gg 2 = 101_2 \\gg 2 = 1_2 = 1$ which is the same as $\\frac{5}{2^2} = \\frac{5}{4} = 1$ . For a computer though shifting some bits is a lot faster than doing divisions. $\\ll$ Shifts a number to left by appending zero digits. In similar fashion to a right shift by $k$ , a left shift by $k$ represents a multiplication by $2^k$ . E.g. $5 \\ll 3 = 101_2 \\ll 3 = 101000_2 = 40$ which is the same as $5 \\cdot 2^3 = 5 \\cdot 8 = 40$ . Notice however that for a fixed-length integer that means dropping the most left digits, and if you shift too much you end up with the number $0$ . Useful tricks \u00b6 Set/flip/clear a bit \u00b6 Using bitwise shifts and some basic bitwise operations we can easily set, flip or clear a bit. $1 \\ll x$ is a number with only the $x$ -th bit set, while $\\sim(1 \\ll x)$ is a number with all bits set except the $x$ -th bit. $n ~|~ (1 \\ll x)$ sets the $x$ -th bit in the number $n$ $n ~\\wedge~ (1 \\ll x)$ flips the $x$ -th bit in the number $n$ $n ~\\&~ \\sim(1 \\ll x)$ clears the $x$ -th bit in the number $n$ Check if a bit is set \u00b6 The value of the $x$ -th bit can be checked by shifting the number $x$ positions to the right, so that the $x$ -th bit is at the unit place, after which we can extract it by performing a bitwise & with 1. bool is_set ( unsigned int number , int x ) { return ( number >> x ) & 1 ; } Check if the number is divisible by a power of 2 \u00b6 Using the and operation, we can check if a number $n$ is even because $n ~\\&~ 1 = 0$ if $n$ is even, and $n ~\\&~ 1 = 1$ if $n$ is odd. More generally, $n$ is divisible by $2^{k}$ exactly when $n ~\\&~ (2^{k} \u2212 1) = 0$ . bool isDivisibleByPowerOf2 ( int n , int k ) { int powerOf2 = 1 << k ; return ( n & ( powerOf2 - 1 )) == 0 ; } We can calculate $2^{k}$ by left shifting 1 by $k$ positions. The trick works, because $2^k - 1$ is a number that consists of exactly $k$ ones. And a number that is divisible by $2^k$ must have zero digits in those places. Check if an integer is a power of 2 \u00b6 A power of two is a number that has only a single bit in it (e.g. $32 = 0010~0000_2$ ), while the predecessor of that number has that digit not set and all the digits after it set ( $31 = 0001~1111_2$ ). So the bitwise AND of a number with it's predecessor will always be 0, as they don't have any common digits set. You can easily check that this only happens for the the power of twos and for the number $0$ which already has no digit set. bool isPowerOfTwo ( unsigned int n ) { return n && ! ( n & ( n - 1 )); } Clear the right-most set bit \u00b6 The expression $n ~\\&~ (n-1)$ can be used to turn off the rightmost set bit of a number $n$ . This works because the expression $n-1$ flips all bits after the rightmost set bit of $n$ , including the rightmost set bit. So all those digits are different from the original number, and by doing a bitwise AND they are all set to 0, giving you the original number $n$ with the rightmost set bit flipped. For example, consider the number $52 = 0011~0100_2$ : n = 00110100 n-1 = 00110011 -------------------- n & (n-1) = 00110000 Brian Kernighan's algorithm \u00b6 We can count the number of bits set with the above expression. The idea is to consider only the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the Next Rightmost bit. int countSetBits ( int n ) { int count = 0 ; while ( n ) { n = n & ( n - 1 ); count ++ ; } return count ; } Count set bits upto $n$ \u00b6 To count the number of set bits of all numbers upto the number $n$ (inclusive), we can run the Brian Kernighan's algorithm on all numbers upto $n$ . But this will result in a \"Time Limit Exceeded\" in contest submissions. We can use the fact that for numbers upto $2^x$ (i.e. from $1$ to $2^x - 1$ ) there are $x \\cdot 2^{x-1}$ set bits. This can be visualised as follows. 0 -> 0 0 0 0 1 -> 0 0 0 1 2 -> 0 0 1 0 3 -> 0 0 1 1 4 -> 0 1 0 0 5 -> 0 1 0 1 6 -> 0 1 1 0 7 -> 0 1 1 1 8 -> 1 0 0 0 We can see that the all the columns except the leftmost have $4$ (i.e. $2^2$ ) set bits each, i.e. upto the number $2^3 - 1$ , the number of set bits is $3 \\cdot 2^{3-1}$ . With the new knowledge in hand we can come up with the following algorithm: Find the highest power of $2$ that is lesser than or equal to the given number. Let this number be $x$ . Calculate the number of set bits from $1$ to $2^x - 1$ by using the formua $x \\cdot 2^{x-1}$ . Count the no. of set bits in the most significant bit from $2^x$ to $n$ and add it. Subtract $2^x$ from $n$ and repeat the above steps using the new $n$ . int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { int x = std :: bit_width ( n ) - 1 ; count += x << ( x - 1 ); n -= 1 << x ; count += n + 1 ; } return count ; } Additional tricks \u00b6 $n ~\\&~ (n + 1)$ clears all trailing ones: $0011~0111_2 \\rightarrow 0011~0000_2$ . $n ~|~ (n + 1)$ sets the last cleared bit: $0011~0101_2 \\rightarrow 0011~0111_2$ . $n ~\\&~ -n$ extracts the last set bit: $0011~0100_2 \\rightarrow 0000~0100_2$ . Many more can be found in the book Hacker's Delight . Language and compiler support \u00b6 C++ supports some of those operations since C++20 via the bit standard library: has_single_bit : checks if the number is a power of two bit_ceil / bit_floor : round up/down to the next power of two rotl / rotr : rotate the bits in the number countl_zero / countr_zero / countl_one / countr_one : count the leading/trailing zeros/ones popcount : count the number of set bits Additionally, there are also predefined functions in some compilers that help working with bits. E.g. GCC defines a list at Built-in Functions Provided by GCC that also work in older versions of C++: __builtin_popcount(unsigned int) returns the number of set bits ( __builtin_popcount(0b0001'0010'1100) == 4 ) __builtin_ffs(int) finds the index of the first (most right) set bit ( __builtin_ffs(0b0001'0010'1100) == 3 ) __builtin_clz(unsigned int) the count of leading zeros ( __builtin_clz(0b0001'0010'1100) == 23 ) __builtin_ctz(unsigned int) the count of trailing zeros ( __builtin_ctz(0b0001'0010'1100) == 2 ) __builtin_parity(x) the parity (even or odd) of the number of ones in the bit representation Note that some of the operations (both the C++20 functions and the Compiler Built-in ones) might be quite slow in GCC if you don't enable a specific compiler target with #pragma GCC target(\"popcnt\") . Practice Problems \u00b6 Codeforces - Raising Bacteria Codeforces - Fedor and New Game Codeforces - And Then There Were K","title":"Bit manipulation"},{"location":"algebra/bit-manipulation.html#bit-manipulation","text":"","title":"Bit manipulation"},{"location":"algebra/bit-manipulation.html#binary-number","text":"A binary number is a number expressed in the base-2 numeral system or binary numeral system, it is a method of mathematical expression which uses only two symbols: typically \"0\" (zero) and \"1\" (one). We say that a certain bit is set , if it is one, and cleared if it is zero. The binary number $(a_k a_{k-1} \\dots a_1 a_0)_2$ represents the number: $$(a_k a_{k-1} \\dots a_1 a_0)_2 = a_k \\cdot 2^k + a_{k-1} \\cdot 2^{k-1} + \\dots + a_1 \\cdot 2^1 + a_0 \\cdot 2^0.$$ For instance the binary number $1101_2$ represents the number $13$ : $$\\begin{align} 1101_2 &= 1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 \\\\ &= 1\\cdot 8 + 1 \\cdot 4 + 0 \\cdot 2 + 1 \\cdot 1 = 13 \\end{align}$$ Computers represent integers as binary numbers. Positive integers (both signed and unsigned) are just represented with their binary digits, and negative signed numbers (which can be positive and negative) are usually represented with the Two's complement . unsigned int unsigned_number = 13 ; assert ( unsigned_number == 0b1101 ); int positive_signed_number = 13 ; assert ( positive_signed_number == 0b1101 ); int negative_signed_number = -13 ; assert ( negative_signed_number == 0b1111'1111'1111'1111'1111'1111'1111'0011 ); CPUs are very fast manipulating those bits with specific operations. For some problems we can take these binary number representations to our advantage, and speed up the execution time. And for some problems (typically in combinatorics or dynamic programming) where we want to track which objects we already picked from a given set of objects, we can just use an large enough integer where each digit represents an object and depending on if we pick or drop the object we set or clear the digit.","title":"Binary number"},{"location":"algebra/bit-manipulation.html#bit-operators","text":"All those introduced operators are instant (same speed as an addition) on a CPU for fixed-length integers.","title":"Bit operators"},{"location":"algebra/bit-manipulation.html#bitwise-operators","text":"$\\&$ : The bitwise AND operator compares each bit of its first operand with the corresponding bit of its second operand. If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0. $|$ : The bitwise inclusive OR operator compares each bit of its first operand with the corresponding bit of its second operand. If one of the two bits is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0. $\\wedge$ : The bitwise exclusive OR (XOR) operator compares each bit of its first operand with the corresponding bit of its second operand. If one bit is 0 and the other bit is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0. $\\sim$ : The bitwise complement (NOT) operator flips each bit of a number, if a bit is set the operator will clear it, if it is cleared the operator sets it. Examples: n = 01011000 n-1 = 01010111 -------------------- n & (n-1) = 01010000 n = 01011000 n-1 = 01010111 -------------------- n | (n-1) = 01011111 n = 01011000 n-1 = 01010111 -------------------- n ^ (n-1) = 00001111 n = 01011000 -------------------- ~n = 10100111","title":"Bitwise operators"},{"location":"algebra/bit-manipulation.html#shift-operators","text":"There are two operators for shifting bits. $\\gg$ Shifts a number to the right by removing the last few binary digits of the number. Each shift by one represents an integer division by 2, so a right shift by $k$ represents an integer division by $2^k$ . E.g. $5 \\gg 2 = 101_2 \\gg 2 = 1_2 = 1$ which is the same as $\\frac{5}{2^2} = \\frac{5}{4} = 1$ . For a computer though shifting some bits is a lot faster than doing divisions. $\\ll$ Shifts a number to left by appending zero digits. In similar fashion to a right shift by $k$ , a left shift by $k$ represents a multiplication by $2^k$ . E.g. $5 \\ll 3 = 101_2 \\ll 3 = 101000_2 = 40$ which is the same as $5 \\cdot 2^3 = 5 \\cdot 8 = 40$ . Notice however that for a fixed-length integer that means dropping the most left digits, and if you shift too much you end up with the number $0$ .","title":"Shift operators"},{"location":"algebra/bit-manipulation.html#useful-tricks","text":"","title":"Useful tricks"},{"location":"algebra/bit-manipulation.html#setflipclear-a-bit","text":"Using bitwise shifts and some basic bitwise operations we can easily set, flip or clear a bit. $1 \\ll x$ is a number with only the $x$ -th bit set, while $\\sim(1 \\ll x)$ is a number with all bits set except the $x$ -th bit. $n ~|~ (1 \\ll x)$ sets the $x$ -th bit in the number $n$ $n ~\\wedge~ (1 \\ll x)$ flips the $x$ -th bit in the number $n$ $n ~\\&~ \\sim(1 \\ll x)$ clears the $x$ -th bit in the number $n$","title":"Set/flip/clear a bit"},{"location":"algebra/bit-manipulation.html#check-if-a-bit-is-set","text":"The value of the $x$ -th bit can be checked by shifting the number $x$ positions to the right, so that the $x$ -th bit is at the unit place, after which we can extract it by performing a bitwise & with 1. bool is_set ( unsigned int number , int x ) { return ( number >> x ) & 1 ; }","title":"Check if a bit is set"},{"location":"algebra/bit-manipulation.html#check-if-the-number-is-divisible-by-a-power-of-2","text":"Using the and operation, we can check if a number $n$ is even because $n ~\\&~ 1 = 0$ if $n$ is even, and $n ~\\&~ 1 = 1$ if $n$ is odd. More generally, $n$ is divisible by $2^{k}$ exactly when $n ~\\&~ (2^{k} \u2212 1) = 0$ . bool isDivisibleByPowerOf2 ( int n , int k ) { int powerOf2 = 1 << k ; return ( n & ( powerOf2 - 1 )) == 0 ; } We can calculate $2^{k}$ by left shifting 1 by $k$ positions. The trick works, because $2^k - 1$ is a number that consists of exactly $k$ ones. And a number that is divisible by $2^k$ must have zero digits in those places.","title":"Check if the number is divisible by a power of 2"},{"location":"algebra/bit-manipulation.html#check-if-an-integer-is-a-power-of-2","text":"A power of two is a number that has only a single bit in it (e.g. $32 = 0010~0000_2$ ), while the predecessor of that number has that digit not set and all the digits after it set ( $31 = 0001~1111_2$ ). So the bitwise AND of a number with it's predecessor will always be 0, as they don't have any common digits set. You can easily check that this only happens for the the power of twos and for the number $0$ which already has no digit set. bool isPowerOfTwo ( unsigned int n ) { return n && ! ( n & ( n - 1 )); }","title":"Check if an integer is a power of 2"},{"location":"algebra/bit-manipulation.html#clear-the-right-most-set-bit","text":"The expression $n ~\\&~ (n-1)$ can be used to turn off the rightmost set bit of a number $n$ . This works because the expression $n-1$ flips all bits after the rightmost set bit of $n$ , including the rightmost set bit. So all those digits are different from the original number, and by doing a bitwise AND they are all set to 0, giving you the original number $n$ with the rightmost set bit flipped. For example, consider the number $52 = 0011~0100_2$ : n = 00110100 n-1 = 00110011 -------------------- n & (n-1) = 00110000","title":"Clear the right-most set bit"},{"location":"algebra/bit-manipulation.html#brian-kernighans-algorithm","text":"We can count the number of bits set with the above expression. The idea is to consider only the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the Next Rightmost bit. int countSetBits ( int n ) { int count = 0 ; while ( n ) { n = n & ( n - 1 ); count ++ ; } return count ; }","title":"Brian Kernighan's algorithm"},{"location":"algebra/bit-manipulation.html#count-set-bits-upto-n","text":"To count the number of set bits of all numbers upto the number $n$ (inclusive), we can run the Brian Kernighan's algorithm on all numbers upto $n$ . But this will result in a \"Time Limit Exceeded\" in contest submissions. We can use the fact that for numbers upto $2^x$ (i.e. from $1$ to $2^x - 1$ ) there are $x \\cdot 2^{x-1}$ set bits. This can be visualised as follows. 0 -> 0 0 0 0 1 -> 0 0 0 1 2 -> 0 0 1 0 3 -> 0 0 1 1 4 -> 0 1 0 0 5 -> 0 1 0 1 6 -> 0 1 1 0 7 -> 0 1 1 1 8 -> 1 0 0 0 We can see that the all the columns except the leftmost have $4$ (i.e. $2^2$ ) set bits each, i.e. upto the number $2^3 - 1$ , the number of set bits is $3 \\cdot 2^{3-1}$ . With the new knowledge in hand we can come up with the following algorithm: Find the highest power of $2$ that is lesser than or equal to the given number. Let this number be $x$ . Calculate the number of set bits from $1$ to $2^x - 1$ by using the formua $x \\cdot 2^{x-1}$ . Count the no. of set bits in the most significant bit from $2^x$ to $n$ and add it. Subtract $2^x$ from $n$ and repeat the above steps using the new $n$ . int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { int x = std :: bit_width ( n ) - 1 ; count += x << ( x - 1 ); n -= 1 << x ; count += n + 1 ; } return count ; }","title":"Count set bits upto $n$"},{"location":"algebra/bit-manipulation.html#additional-tricks","text":"$n ~\\&~ (n + 1)$ clears all trailing ones: $0011~0111_2 \\rightarrow 0011~0000_2$ . $n ~|~ (n + 1)$ sets the last cleared bit: $0011~0101_2 \\rightarrow 0011~0111_2$ . $n ~\\&~ -n$ extracts the last set bit: $0011~0100_2 \\rightarrow 0000~0100_2$ . Many more can be found in the book Hacker's Delight .","title":"Additional tricks"},{"location":"algebra/bit-manipulation.html#language-and-compiler-support","text":"C++ supports some of those operations since C++20 via the bit standard library: has_single_bit : checks if the number is a power of two bit_ceil / bit_floor : round up/down to the next power of two rotl / rotr : rotate the bits in the number countl_zero / countr_zero / countl_one / countr_one : count the leading/trailing zeros/ones popcount : count the number of set bits Additionally, there are also predefined functions in some compilers that help working with bits. E.g. GCC defines a list at Built-in Functions Provided by GCC that also work in older versions of C++: __builtin_popcount(unsigned int) returns the number of set bits ( __builtin_popcount(0b0001'0010'1100) == 4 ) __builtin_ffs(int) finds the index of the first (most right) set bit ( __builtin_ffs(0b0001'0010'1100) == 3 ) __builtin_clz(unsigned int) the count of leading zeros ( __builtin_clz(0b0001'0010'1100) == 23 ) __builtin_ctz(unsigned int) the count of trailing zeros ( __builtin_ctz(0b0001'0010'1100) == 2 ) __builtin_parity(x) the parity (even or odd) of the number of ones in the bit representation Note that some of the operations (both the C++20 functions and the Compiler Built-in ones) might be quite slow in GCC if you don't enable a specific compiler target with #pragma GCC target(\"popcnt\") .","title":"Language and compiler support"},{"location":"algebra/bit-manipulation.html#practice-problems","text":"Codeforces - Raising Bacteria Codeforces - Fedor and New Game Codeforces - And Then There Were K","title":"Practice Problems"},{"location":"algebra/chinese-remainder-theorem.html","text":"Chinese Remainder Theorem \u00b6 The Chinese Remainder Theorem (which will be referred to as CRT in the rest of this article) was discovered by Chinese mathematician Sun Zi. Formulation \u00b6 Let $m = m_1 \\cdot m_2 \\cdots m_k$ , where $m_i$ are pairwise coprime. In addition to $m_i$ , we are also given a system of congruences $$\\left\\{\\begin{array}{rcl} a & \\equiv & a_1 \\pmod{m_1} \\\\ a & \\equiv & a_2 \\pmod{m_2} \\\\ & \\vdots & \\\\ a & \\equiv & a_k \\pmod{m_k} \\end{array}\\right.$$ where $a_i$ are some given constants. The original form of CRT then states that the given system of congruences always has one and exactly one solution modulo $m$ . E.g. the system of congruences $$\\left\\{\\begin{array}{rcl} a & \\equiv & 2 \\pmod{3} \\\\ a & \\equiv & 3 \\pmod{5} \\\\ a & \\equiv & 2 \\pmod{7} \\end{array}\\right.$$ has the solution $23$ modulo $105$ , because $23 \\bmod{3} = 2$ , $23 \\bmod{5} = 3$ , and $23 \\bmod{7} = 2$ . We can write down every solution as $23 + 105\\cdot k$ for $k \\in \\mathbb{Z}$ . Corollary \u00b6 A consequence of the CRT is that the equation $$x \\equiv a \\pmod{m}$$ is equivalent to the system of equations $$\\left\\{\\begin{array}{rcl} x & \\equiv & a_1 \\pmod{m_1} \\\\ & \\vdots & \\\\ x & \\equiv & a_k \\pmod{m_k} \\end{array}\\right.$$ (As above, assume that $m = m_1 m_2 \\cdots m_k$ and $m_i$ are pairwise coprime). Solution for Two Moduli \u00b6 Consider a system of two equations for coprime $m_1, m_2$ : $$ \\left\\{\\begin{align} a &\\equiv a_1 \\pmod{m_1} \\\\ a &\\equiv a_2 \\pmod{m_2} \\\\ \\end{align}\\right. $$ We want to find a solution for $a \\pmod{m_1 m_2}$ . Using the Extended Euclidean Algorithm we can find B\u00e9zout coefficients $n_1, n_2$ such that $$n_1 m_1 + n_2 m_2 = 1.$$ In fact $n_1$ and $n_2$ are just the modular inverses of $m_1$ and $m_2$ modulo $m_2$ and $m_1$ . We have $n_1 m_1 \\equiv 1 \\pmod{m_2}$ so $n_1 \\equiv m_1^{-1} \\pmod{m_2}$ , and vice versa $n_2 \\equiv m_2^{-1} \\pmod{m_1}$ . With those two coefficients we can define a solution: $$a = a_1 n_2 m_2 + a_2 n_1 m_1 \\bmod{m_1 m_2}$$ It's easy to verify that this is indeed a solution by computing $a \\bmod{m_1}$ and $a \\bmod{m_2}$ . $$ \\begin{array}{rcll} a & \\equiv & a_1 n_2 m_2 + a_2 n_1 m_1 & \\pmod{m_1}\\\\ & \\equiv & a_1 (1 - n_1 m_1) + a_2 n_1 m_1 & \\pmod{m_1}\\\\ & \\equiv & a_1 - a_1 n_1 m_1 + a_2 n_1 m_1 & \\pmod{m_1}\\\\ & \\equiv & a_1 & \\pmod{m_1} \\end{array} $$ Notice, that the Chinese Remainder Theorem also guarantees, that only 1 solution exists modulo $m_1 m_2$ . This is also easy to prove. Lets assume that you have two different solutions $x$ and $y$ . Because $x \\equiv a_i \\pmod{m_i}$ and $y \\equiv a_i \\pmod{m_i}$ , it follows that $x \u2212 y \\equiv 0 \\pmod{m_i}$ and therefore $x \u2212 y \\equiv 0 \\pmod{m_1 m_2}$ or equivalently $x \\equiv y \\pmod{m_1 m_2}$ . So $x$ and $y$ are actually the same solution. Solution for General Case \u00b6 Inductive Solution \u00b6 As $m_1 m_2$ is coprime to $m_3$ , we can inductively repeatedly apply the solution for two moduli for any number of moduli. First you compute $b_2 := a \\pmod{m_1 m_2}$ using the first two congruences, then you can compute $b_3 := a \\pmod{m_1 m_2 m_3}$ using the congruences $a \\equiv b_2 \\pmod{m_1 m_2}$ and $a \\equiv a_3 \\pmod {m_3}$ , etc. Direct Construction \u00b6 A direct construction similar to Lagrange interpolation is possible. Let $M_i := \\prod_{i \\neq j} m_j$ , the product of all moduli but $m_i$ , and $N_i$ the modular inverses $N_i := M_i^{-1} \\bmod{m_i}$ . Then a solution to the system of congruences is: $$a \\equiv \\sum_{i=1}^k a_i M_i N_i \\pmod{m_1 m_2 \\cdots m_k}$$ We can check this is indeed a solution, by computing $a \\bmod{m_i}$ for all $i$ . Because $M_j$ is a multiple of $m_i$ for $i \\neq j$ we have $$\\begin{array}{rcll} a & \\equiv & \\sum_{j=1}^k a_j M_j N_j & \\pmod{m_i} \\\\ & \\equiv & a_i M_i N_i & \\pmod{m_i} \\\\ & \\equiv & a_i M_i M_i^{-1} & \\pmod{m_i} \\\\ & \\equiv & a_i & \\pmod{m_i} \\end{array}$$ Implementation \u00b6 struct Congruence { long long a , m ; }; long long chinese_remainder_theorem ( vector < Congruence > const & congruences ) { long long M = 1 ; for ( auto const & congruence : congruences ) { M *= congruence . m ; } long long solution = 0 ; for ( auto const & congruence : congruences ) { long long a_i = congruence . a ; long long M_i = M / congruence . m ; long long N_i = mod_inv ( M_i , congruence . m ); solution = ( solution + a_i * M_i % M * N_i ) % M ; } return solution ; } Solution for not coprime moduli \u00b6 As mentioned, the algorithm above only works for coprime moduli $m_1, m_2, \\dots m_k$ . In the not coprime case, a system of congruences has exactly one solution modulo $\\text{lcm}(m_1, m_2, \\dots, m_k)$ , or has no solution at all. E.g. in the following system, the first congruence implies that the solution is odd, and the second congruence implies that the solution is even. It's not possible that a number is both odd and even, therefore there is clearly no solution. $$\\left\\{\\begin{align} a & \\equiv 1 \\pmod{4} \\\\ a & \\equiv 2 \\pmod{6} \\end{align}\\right.$$ It is pretty simple to determine is a system has a solution. And if it has one, we can use the original algorithm to solve a slightly modified system of congruences. A single congruence $a \\equiv a_i \\pmod{m_i}$ is equivalent to the system of congruences $a \\equiv a_i \\pmod{p_j^{n_j}}$ where $p_1^{n_1} p_2^{n_2}\\cdots p_k^{n_k}$ is the prime factorization of $m_i$ . With this fact, we can modify the system of congruences into a system, that only has prime powers as moduli. E.g. the above system of congruences is equivalent to: $$\\left\\{\\begin{array}{ll} a \\equiv 1 & \\pmod{4} \\\\ a \\equiv 2 \\equiv 0 & \\pmod{2} \\\\ a \\equiv 2 & \\pmod{3} \\end{array}\\right.$$ Because originally some moduli had common factors, we will get some congruences moduli based on the same prime, however possibly with different prime powers. You can observe, that the congruence with the highest prime power modulus will be the strongest congruence of all congruences based on the same prime number. Either it will give a contradiction with some other congruence, or it will imply already all other congruences. In our case, the first congruence $a \\equiv 1 \\pmod{4}$ implies $a \\equiv 1 \\pmod{2}$ , and therefore contradicts the second congruence $a \\equiv 0 \\pmod{2}$ . Therefore this system of congruences has no solution. If there are no contradictions, then the system of equation has a solution. We can ignore all congruences except the ones with the highest prime power moduli. These moduli are now coprime, and therefore we can solve this one with the algorithm discussed in the sections above. E.g. the following system has a solution modulo $\\text{lcm}(10, 12) = 60$ . $$\\left\\{\\begin{align} a & \\equiv 3 \\pmod{10} \\\\ a & \\equiv 5 \\pmod{12} \\end{align}\\right.$$ The system of congruence is equivalent to the system of congruences: $$\\left\\{\\begin{align} a & \\equiv 3 \\equiv 1 \\pmod{2} \\\\ a & \\equiv 3 \\equiv 3 \\pmod{5} \\\\ a & \\equiv 5 \\equiv 1 \\pmod{4} \\\\ a & \\equiv 5 \\equiv 2 \\pmod{3} \\end{align}\\right.$$ The only congruence with same prime modulo are $a \\equiv 1 \\pmod{4}$ and $a \\equiv 1 \\pmod{2}$ . The first one already implies the second one, so we can ignore the second one, and solve the following system with coprime moduli instead: $$\\left\\{\\begin{align} a & \\equiv 3 \\equiv 3 \\pmod{5} \\\\ a & \\equiv 5 \\equiv 1 \\pmod{4} \\\\ a & \\equiv 5 \\equiv 2 \\pmod{3} \\end{align}\\right.$$ It has the solution $53 \\pmod{60}$ , and indeed $53 \\bmod{10} = 3$ and $53 \\bmod{12} = 5$ . Garner's Algorithm \u00b6 Another consequence of the CRT is that we can represent big numbers using an array of small integers. Instead of doing a lot of computations with very large numbers numbers, which might be expensive (think of doing divisions with 1000-digit numbers), you can pick a couple of coprime moduli and represent the large number as a system of congruences, and perform all operations on the system of equations. Any number $a$ less than $m_1 m_2 \\cdots m_k$ can be represented as an array $a_1, \\ldots, a_k$ , where $a \\equiv a_i \\pmod{m_i}$ . By using the above algorithm, you can again reconstruct the large number whenever you need it. Alternatively you can represent the number in the mixed radix representation: $$a = x_1 + x_2 m_1 + x_3 m_1 m_2 + \\ldots + x_k m_1 \\cdots m_{k-1} \\text{ with }x_i \\in [0, m_i)$$ Garner's algorithm, which is discussed in the dedicated article Garner's algorithm , computes the coefficients $x_i$ . And with those coefficients you can restore the full number. Practice Problems: \u00b6 Google Code Jam - Golf Gophers Hackerrank - Number of sequences Codeforces - Remainders Game","title":"Chinese Remainder Theorem"},{"location":"algebra/chinese-remainder-theorem.html#chinese-remainder-theorem","text":"The Chinese Remainder Theorem (which will be referred to as CRT in the rest of this article) was discovered by Chinese mathematician Sun Zi.","title":"Chinese Remainder Theorem"},{"location":"algebra/chinese-remainder-theorem.html#formulation","text":"Let $m = m_1 \\cdot m_2 \\cdots m_k$ , where $m_i$ are pairwise coprime. In addition to $m_i$ , we are also given a system of congruences $$\\left\\{\\begin{array}{rcl} a & \\equiv & a_1 \\pmod{m_1} \\\\ a & \\equiv & a_2 \\pmod{m_2} \\\\ & \\vdots & \\\\ a & \\equiv & a_k \\pmod{m_k} \\end{array}\\right.$$ where $a_i$ are some given constants. The original form of CRT then states that the given system of congruences always has one and exactly one solution modulo $m$ . E.g. the system of congruences $$\\left\\{\\begin{array}{rcl} a & \\equiv & 2 \\pmod{3} \\\\ a & \\equiv & 3 \\pmod{5} \\\\ a & \\equiv & 2 \\pmod{7} \\end{array}\\right.$$ has the solution $23$ modulo $105$ , because $23 \\bmod{3} = 2$ , $23 \\bmod{5} = 3$ , and $23 \\bmod{7} = 2$ . We can write down every solution as $23 + 105\\cdot k$ for $k \\in \\mathbb{Z}$ .","title":"Formulation"},{"location":"algebra/chinese-remainder-theorem.html#corollary","text":"A consequence of the CRT is that the equation $$x \\equiv a \\pmod{m}$$ is equivalent to the system of equations $$\\left\\{\\begin{array}{rcl} x & \\equiv & a_1 \\pmod{m_1} \\\\ & \\vdots & \\\\ x & \\equiv & a_k \\pmod{m_k} \\end{array}\\right.$$ (As above, assume that $m = m_1 m_2 \\cdots m_k$ and $m_i$ are pairwise coprime).","title":"Corollary"},{"location":"algebra/chinese-remainder-theorem.html#solution-for-two-moduli","text":"Consider a system of two equations for coprime $m_1, m_2$ : $$ \\left\\{\\begin{align} a &\\equiv a_1 \\pmod{m_1} \\\\ a &\\equiv a_2 \\pmod{m_2} \\\\ \\end{align}\\right. $$ We want to find a solution for $a \\pmod{m_1 m_2}$ . Using the Extended Euclidean Algorithm we can find B\u00e9zout coefficients $n_1, n_2$ such that $$n_1 m_1 + n_2 m_2 = 1.$$ In fact $n_1$ and $n_2$ are just the modular inverses of $m_1$ and $m_2$ modulo $m_2$ and $m_1$ . We have $n_1 m_1 \\equiv 1 \\pmod{m_2}$ so $n_1 \\equiv m_1^{-1} \\pmod{m_2}$ , and vice versa $n_2 \\equiv m_2^{-1} \\pmod{m_1}$ . With those two coefficients we can define a solution: $$a = a_1 n_2 m_2 + a_2 n_1 m_1 \\bmod{m_1 m_2}$$ It's easy to verify that this is indeed a solution by computing $a \\bmod{m_1}$ and $a \\bmod{m_2}$ . $$ \\begin{array}{rcll} a & \\equiv & a_1 n_2 m_2 + a_2 n_1 m_1 & \\pmod{m_1}\\\\ & \\equiv & a_1 (1 - n_1 m_1) + a_2 n_1 m_1 & \\pmod{m_1}\\\\ & \\equiv & a_1 - a_1 n_1 m_1 + a_2 n_1 m_1 & \\pmod{m_1}\\\\ & \\equiv & a_1 & \\pmod{m_1} \\end{array} $$ Notice, that the Chinese Remainder Theorem also guarantees, that only 1 solution exists modulo $m_1 m_2$ . This is also easy to prove. Lets assume that you have two different solutions $x$ and $y$ . Because $x \\equiv a_i \\pmod{m_i}$ and $y \\equiv a_i \\pmod{m_i}$ , it follows that $x \u2212 y \\equiv 0 \\pmod{m_i}$ and therefore $x \u2212 y \\equiv 0 \\pmod{m_1 m_2}$ or equivalently $x \\equiv y \\pmod{m_1 m_2}$ . So $x$ and $y$ are actually the same solution.","title":"Solution for Two Moduli"},{"location":"algebra/chinese-remainder-theorem.html#solution-for-general-case","text":"","title":"Solution for General Case"},{"location":"algebra/chinese-remainder-theorem.html#inductive-solution","text":"As $m_1 m_2$ is coprime to $m_3$ , we can inductively repeatedly apply the solution for two moduli for any number of moduli. First you compute $b_2 := a \\pmod{m_1 m_2}$ using the first two congruences, then you can compute $b_3 := a \\pmod{m_1 m_2 m_3}$ using the congruences $a \\equiv b_2 \\pmod{m_1 m_2}$ and $a \\equiv a_3 \\pmod {m_3}$ , etc.","title":"Inductive Solution"},{"location":"algebra/chinese-remainder-theorem.html#direct-construction","text":"A direct construction similar to Lagrange interpolation is possible. Let $M_i := \\prod_{i \\neq j} m_j$ , the product of all moduli but $m_i$ , and $N_i$ the modular inverses $N_i := M_i^{-1} \\bmod{m_i}$ . Then a solution to the system of congruences is: $$a \\equiv \\sum_{i=1}^k a_i M_i N_i \\pmod{m_1 m_2 \\cdots m_k}$$ We can check this is indeed a solution, by computing $a \\bmod{m_i}$ for all $i$ . Because $M_j$ is a multiple of $m_i$ for $i \\neq j$ we have $$\\begin{array}{rcll} a & \\equiv & \\sum_{j=1}^k a_j M_j N_j & \\pmod{m_i} \\\\ & \\equiv & a_i M_i N_i & \\pmod{m_i} \\\\ & \\equiv & a_i M_i M_i^{-1} & \\pmod{m_i} \\\\ & \\equiv & a_i & \\pmod{m_i} \\end{array}$$","title":"Direct Construction"},{"location":"algebra/chinese-remainder-theorem.html#implementation","text":"struct Congruence { long long a , m ; }; long long chinese_remainder_theorem ( vector < Congruence > const & congruences ) { long long M = 1 ; for ( auto const & congruence : congruences ) { M *= congruence . m ; } long long solution = 0 ; for ( auto const & congruence : congruences ) { long long a_i = congruence . a ; long long M_i = M / congruence . m ; long long N_i = mod_inv ( M_i , congruence . m ); solution = ( solution + a_i * M_i % M * N_i ) % M ; } return solution ; }","title":"Implementation"},{"location":"algebra/chinese-remainder-theorem.html#solution-for-not-coprime-moduli","text":"As mentioned, the algorithm above only works for coprime moduli $m_1, m_2, \\dots m_k$ . In the not coprime case, a system of congruences has exactly one solution modulo $\\text{lcm}(m_1, m_2, \\dots, m_k)$ , or has no solution at all. E.g. in the following system, the first congruence implies that the solution is odd, and the second congruence implies that the solution is even. It's not possible that a number is both odd and even, therefore there is clearly no solution. $$\\left\\{\\begin{align} a & \\equiv 1 \\pmod{4} \\\\ a & \\equiv 2 \\pmod{6} \\end{align}\\right.$$ It is pretty simple to determine is a system has a solution. And if it has one, we can use the original algorithm to solve a slightly modified system of congruences. A single congruence $a \\equiv a_i \\pmod{m_i}$ is equivalent to the system of congruences $a \\equiv a_i \\pmod{p_j^{n_j}}$ where $p_1^{n_1} p_2^{n_2}\\cdots p_k^{n_k}$ is the prime factorization of $m_i$ . With this fact, we can modify the system of congruences into a system, that only has prime powers as moduli. E.g. the above system of congruences is equivalent to: $$\\left\\{\\begin{array}{ll} a \\equiv 1 & \\pmod{4} \\\\ a \\equiv 2 \\equiv 0 & \\pmod{2} \\\\ a \\equiv 2 & \\pmod{3} \\end{array}\\right.$$ Because originally some moduli had common factors, we will get some congruences moduli based on the same prime, however possibly with different prime powers. You can observe, that the congruence with the highest prime power modulus will be the strongest congruence of all congruences based on the same prime number. Either it will give a contradiction with some other congruence, or it will imply already all other congruences. In our case, the first congruence $a \\equiv 1 \\pmod{4}$ implies $a \\equiv 1 \\pmod{2}$ , and therefore contradicts the second congruence $a \\equiv 0 \\pmod{2}$ . Therefore this system of congruences has no solution. If there are no contradictions, then the system of equation has a solution. We can ignore all congruences except the ones with the highest prime power moduli. These moduli are now coprime, and therefore we can solve this one with the algorithm discussed in the sections above. E.g. the following system has a solution modulo $\\text{lcm}(10, 12) = 60$ . $$\\left\\{\\begin{align} a & \\equiv 3 \\pmod{10} \\\\ a & \\equiv 5 \\pmod{12} \\end{align}\\right.$$ The system of congruence is equivalent to the system of congruences: $$\\left\\{\\begin{align} a & \\equiv 3 \\equiv 1 \\pmod{2} \\\\ a & \\equiv 3 \\equiv 3 \\pmod{5} \\\\ a & \\equiv 5 \\equiv 1 \\pmod{4} \\\\ a & \\equiv 5 \\equiv 2 \\pmod{3} \\end{align}\\right.$$ The only congruence with same prime modulo are $a \\equiv 1 \\pmod{4}$ and $a \\equiv 1 \\pmod{2}$ . The first one already implies the second one, so we can ignore the second one, and solve the following system with coprime moduli instead: $$\\left\\{\\begin{align} a & \\equiv 3 \\equiv 3 \\pmod{5} \\\\ a & \\equiv 5 \\equiv 1 \\pmod{4} \\\\ a & \\equiv 5 \\equiv 2 \\pmod{3} \\end{align}\\right.$$ It has the solution $53 \\pmod{60}$ , and indeed $53 \\bmod{10} = 3$ and $53 \\bmod{12} = 5$ .","title":"Solution for not coprime moduli"},{"location":"algebra/chinese-remainder-theorem.html#garners-algorithm","text":"Another consequence of the CRT is that we can represent big numbers using an array of small integers. Instead of doing a lot of computations with very large numbers numbers, which might be expensive (think of doing divisions with 1000-digit numbers), you can pick a couple of coprime moduli and represent the large number as a system of congruences, and perform all operations on the system of equations. Any number $a$ less than $m_1 m_2 \\cdots m_k$ can be represented as an array $a_1, \\ldots, a_k$ , where $a \\equiv a_i \\pmod{m_i}$ . By using the above algorithm, you can again reconstruct the large number whenever you need it. Alternatively you can represent the number in the mixed radix representation: $$a = x_1 + x_2 m_1 + x_3 m_1 m_2 + \\ldots + x_k m_1 \\cdots m_{k-1} \\text{ with }x_i \\in [0, m_i)$$ Garner's algorithm, which is discussed in the dedicated article Garner's algorithm , computes the coefficients $x_i$ . And with those coefficients you can restore the full number.","title":"Garner's Algorithm"},{"location":"algebra/chinese-remainder-theorem.html#practice-problems","text":"Google Code Jam - Golf Gophers Hackerrank - Number of sequences Codeforces - Remainders Game","title":"Practice Problems:"},{"location":"algebra/continued-fractions.html","text":"Continued fractions \u00b6 Continued fraction is a representation of a real number as a specific convergent sequence of rational numbers. They are useful in competitive programming because they are easy to compute and can be efficiently used to find the best possible rational approximation of the underlying real number (among all numbers whose denominator doesn't exceed a given value). Besides that, continued fractions are closely related to Euclidean algorithm which makes them useful in a bunch of number-theoretical problems. Continued fraction representation \u00b6 Definition Let $a_0, a_1, \\dots, a_k \\in \\mathbb Z$ and $a_1, a_2, \\dots, a_k \\geq 1$ . Then the expression $$r=a_0 + \\frac{1}{a_1 + \\frac{1}{\\dots + \\frac{1}{a_k}}},$$ is called the continued fraction representation of the rational number $r$ and is denoted shortly as $r=[a_0;a_1,a_2,\\dots,a_k]$ . Example Let $r = \\frac{5}{3}$ . There are two ways to represent it as a continued fraction: $$ \\begin{align} r = [1;1,1,1] &= 1+\\frac{1}{1+\\frac{1}{1+\\frac{1}{1}}},\\\\ r = [1;1,2] &= 1+\\frac{1}{1+\\frac{1}{2}}. \\end{align} $$ It can be proven that any rational number can be represented as a continued fraction in exactly $2$ ways: $$r = [a_0;a_1,\\dots,a_k,1] = [a_0;a_1,\\dots,a_k+1].$$ Moreover, the length $k$ of such continued fraction is estimated as $k = O(\\log \\min(p, q))$ for $r=\\frac{p}{q}$ . The reasoning behind this will be clear once we delve into the details of the continued fraction construction. Definition Let $a_0,a_1,a_2, \\dots$ be an integer sequence such that $a_1, a_2, \\dots \\geq 1$ . Let $r_k = [a_0; a_1, \\dots, a_k]$ . Then the expression $$r = a_0 + \\frac{1}{a_1 + \\frac{1}{a_2+\\dots}} = \\lim\\limits_{k \\to \\infty} r_k.$$ is called the continued fraction representation of the irrational number $r$ and is denoted shortly as $r = [a_0;a_1,a_2,\\dots]$ . Note that for $r=[a_0;a_1,\\dots]$ and integer $k$ , it holds that $r+k = [a_0+k; a_1, \\dots]$ . Another important observation is that $\\frac{1}{r}=[0;a_0, a_1, \\dots]$ when $a_0 > 0$ and $\\frac{1}{r} = [a_1; a_2, \\dots]$ when $a_0 = 0$ . Definition In the definition above, rational numbers $r_0, r_1, r_2, \\dots$ are called the convergents of $r$ . Correspondingly, individual $r_k = [a_0; a_1, \\dots, a_k] = \\frac{p_k}{q_k}$ is called the $k$ -th convergent of $r$ . Example Consider $r = [1; 1, 1, 1, \\dots]$ . It can be proven by induction that $r_k = \\frac{F_{k+2}}{F_{k+1}}$ , where $F_k$ is the Fibonacci sequence defined as $F_0 = 0$ , $F_1 = 1$ and $F_{k} = F_{k-1} + F_{k-2}$ . From the Binet's formula, it is known that $$r_k = \\frac{\\phi^{k+2} - \\psi^{k+2}}{\\phi^{k+1} - \\psi^{k+1}},$$ where $\\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618$ is the golden ratio and $\\psi = \\frac{1-\\sqrt{5}}{2} = -\\frac{1}{\\phi} \\approx -0.618$ . Thus, $$r = 1+\\frac{1}{1+\\frac{1}{1+\\dots}}=\\lim\\limits_{k \\to \\infty} r_k = \\phi = \\frac{1+\\sqrt{5}}{2}.$$ Note that in this specific case, an alternative way to find $r$ would be to solve the equation $$r = 1+\\frac{1}{r} \\implies r^2 = r + 1. $$ Definition Let $r_k = [a_0; a_1, \\dots, a_{k-1}, a_k]$ . The numbers $[a_0; a_1, \\dots, a_{k-1}, t]$ for $1 \\leq t \\leq a_k$ are called semiconvergents . We will typically refer to (semi)convergents that are greater than $r$ as upper (semi)convergents and to those that are less than $r$ as lower (semi)convergents. Definition Complementary to convergents, we define the complete quotients as $s_k = [a_k; a_{k+1}, a_{k+2}, \\dots]$ . Correspondingly, we will call an individual $s_k$ the $k$ -th complete quotient of $r$ . From the definitions above, one can conclude that $s_k \\geq 1$ for $k \\geq 1$ . Treating $[a_0; a_1, \\dots, a_k]$ as a formal algebraic expression and allowing arbitrary real numbers instead of $a_i$ , we obtain $$r = [a_0; a_1, \\dots, a_{k-1}, s_k].$$ In particular, $r = [s_0] = s_0$ . On the other hand, we can express $s_k$ as $$s_k = [a_k; s_{k+1}] = a_k + \\frac{1}{s_{k+1}},$$ meaning that we can compute $a_k = \\lfloor s_k \\rfloor$ and $s_{k+1} = (s_k - a_k)^{-1}$ from $s_k$ . The sequence $a_0, a_1, \\dots$ is well-defined unless $s_k=a_k$ which only happens when $r$ is a rational number. Thus the continued fraction representation is uniquely defined for any irrational number $r$ . Implementation \u00b6 In the code snippets we will mostly assume finite continued fractions. From $s_k$ , the transition to $s_{k+1}$ looks like $$s_k =\\left\\lfloor s_k \\right\\rfloor + \\frac{1}{s_{k+1}}.$$ From this expression, the next complete quotient $s_{k+1}$ is obtained as $$s_{k+1} = \\left(s_k-\\left\\lfloor s_k\\right\\rfloor\\right)^{-1}.$$ For $s_k=\\frac{p}{q}$ it means that $$ s_{k+1} = \\left(\\frac{p}{q}-\\left\\lfloor \\frac{p}{q} \\right\\rfloor\\right)^{-1} = \\frac{q}{p-q\\cdot \\lfloor \\frac{p}{q} \\rfloor} = \\frac{q}{p \\bmod q}. $$ Thus, the computation of a continued fraction representation for $r=\\frac{p}{q}$ follows the steps of the Euclidean algorithm for $p$ and $q$ . From this also follows that $\\gcd(p_k, q_k) = 1$ for $\\frac{p_k}{q_k} = [a_0; a_1, \\dots, a_k]$ . Hence, convergents are always irreducible. C++ Python auto fraction ( int p , int q ) { vector < int > a ; while ( q ) { a . push_back ( p / q ); tie ( p , q ) = make_pair ( q , p % q ); } return a ; } def fraction ( p , q ): a = [] while q : a . append ( p // q ) p , q = q , p % q return a Key results \u00b6 To provide some motivation for further study of continued fraction, we give some key facts now. Recurrence For the convergents $r_k = \\frac{p_k}{q_k}$ , the following recurrence stands, allowing their fast computation: $$\\frac{p_k}{q_k}=\\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}},$$ where $\\frac{p_{-1}}{q_{-1}}=\\frac{1}{0}$ and $\\frac{p_{-2}}{q_{-2}}=\\frac{0}{1}$ . Deviations The deviation of $r_k = \\frac{p_k}{q_k}$ from $r$ can be generally estimated as $$\\left|\\frac{p_k}{q_k}-r\\right| \\leq \\frac{1}{q_k q_{k+1}} \\leq \\frac{1}{q_k^2}.$$ Multiplying both sides with $q_k$ , we obtain alternate estimation: $$|p_k - q_k r| \\leq \\frac{1}{q_{k+1}}.$$ From the recurrence above it follows that $q_k$ grows at least as fast as Fibonacci numbers. On the picture below you may see the visualization of how convergents $r_k$ approach $r=\\frac{1+\\sqrt 5}{2}$ : $r=\\frac{1+\\sqrt 5}{2}$ is depicted by blue dotted line. Odd convergents approach it from above and even convergents approach it from below. Lattice hulls Consider convex hulls of points above and below the line $y=rx$ . Odd convergents $(q_k;p_k)$ are the vertices of the upper hull, while the even convergents $(q_k;p_k)$ are the vertices of the bottom hull. All integers vertices on the hulls are obtained as $(q;p)$ such that $$\\frac{p}{q} = \\frac{tp_{k-1} + p_{k-2}}{tq_{k-1} + q_{k-2}}$$ for integer $0 \\leq t \\leq a_k$ . In other words, the set of lattice points on the hulls corresponds to the set of semiconvergents. On the picture below, you may see the convergents and semiconvergents (intermediate gray points) of $r=\\frac{9}{7}$ . Best approximations Let $\\frac{p}{q}$ be the fraction to minimize $\\left|r-\\frac{p}{q}\\right|$ subject to $q \\leq x$ for some $x$ . Then $\\frac{p}{q}$ is a semiconvergent of $r$ . The last fact allows to find the best rational approximations of $r$ by checking its semiconvergents. Below you will find the further explanation and a bit of intuition and interpretation for these facts. Convergents \u00b6 Let's take a closer look at the convergents that were defined earlier. For $r=[a_0, a_1, a_2, \\dots]$ , its convergents are $$\\begin{gather} r_0=[a_0],\\\\r_1=[a_0, a_1],\\\\ \\dots,\\\\ r_k=[a_0, a_1, \\dots, a_k]. \\end{gather}$$ Convergents are the core concept of continued fractions, so it is important to study their properties. For the number $r$ , its $k$ -th convergent $r_k = \\frac{p_k}{q_k}$ can be computed as $$r_k = \\frac{P_k(a_0,a_1,\\dots,a_k)}{P_{k-1}(a_1,\\dots,a_k)} = \\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}},$$ where $P_k(a_0,\\dots,a_k)$ is the continuant , a multivariate polynomial defined as $$P_k(x_0,x_1,\\dots,x_k) = \\det \\begin{bmatrix} x_k & 1 & 0 & \\dots & 0 \\\\ -1 & x_{k-1} & 1 & \\dots & 0 \\\\ 0 & -1 & x_2 & . & \\vdots \\\\ \\vdots & \\vdots & . & \\ddots & 1 \\\\ 0 & 0 & \\dots & -1 & x_0 \\end{bmatrix}_{\\textstyle .}$$ Thus, $r_k$ is a weighted mediant of $r_{k-1}$ and $r_{k-2}$ . For consistency, two additional convergents $r_{-1} = \\frac{1}{0}$ and $r_{-2} = \\frac{0}{1}$ are defined. Detailed explanation The numerator and the denominator of $r_k$ can be seen as multivariate polynomials of $a_0, a_1, \\dots, a_k$ : $$r_k = \\frac{P_k(a_0, a_1, \\dots, a_k)}{Q_k(a_0,a_1, \\dots, a_k)}.$$ From the definition of convergents, $$r_k = a_0 + \\frac{1}{[a_1;a_2,\\dots, a_k]}= a_0 + \\frac{Q_{k-1}(a_1, \\dots, a_k)}{P_{k-1}(a_1, \\dots, a_k)} = \\frac{a_0 P_{k-1}(a_1, \\dots, a_k) + Q_{k-1}(a_1, \\dots, a_k)}{P_{k-1}(a_1, \\dots, a_k)}.$$ From this follows $Q_k(a_0, \\dots, a_k) = P_{k-1}(a_1, \\dots, a_k)$ . This yields the relation $$P_k(a_0, \\dots, a_k) = a_0 P_{k-1}(a_1, \\dots, a_k) + P_{k-2}(a_2, \\dots, a_k).$$ Initially, $r_0 = \\frac{a_0}{1}$ and $r_1 = \\frac{a_0 a_1 + 1}{a_1}$ , thus $$\\begin{align}P_0(a_0)&=a_0,\\\\ P_1(a_0, a_1) &= a_0 a_1 + 1.\\end{align}$$ For consistency, it is convenient to define $P_{-1} = 1$ and $P_{-2}=0$ and formally say that $r_{-1} = \\frac{1}{0}$ and $r_{-2}=\\frac{0}{1}$ . From numerical analysis, it is known that the determinant of an arbitrary tridiagonal matrix $$T_k = \\det \\begin{bmatrix} a_0 & b_0 & 0 & \\dots & 0 \\\\ c_0 & a_1 & b_1 & \\dots & 0 \\\\ 0 & c_1 & a_2 & . & \\vdots \\\\ \\vdots & \\vdots & . & \\ddots & c_{k-1} \\\\ 0 & 0 & \\dots & b_{k-1} & a_k \\end{bmatrix}$$ can be computed recursively as $T_k = a_k T_{k-1} - b_{k-1} c_{k-1} T_{k-2}$ . Comparing it to $P_k$ , we get a direct expression $$P_k = \\det \\begin{bmatrix} x_k & 1 & 0 & \\dots & 0 \\\\ -1 & x_{k-1} & 1 & \\dots & 0 \\\\ 0 & -1 & x_2 & . & \\vdots \\\\ \\vdots & \\vdots & . & \\ddots & 1 \\\\ 0 & 0 & \\dots & -1 & x_0 \\end{bmatrix}_{\\textstyle .}$$ This polynomial is also known as the continuant due to its close relation with continued fraction. The continuant won't change if the sequence on the main diagonal is reversed. This yields an alternative formula to compute it: $$P_k(a_0, \\dots, a_k) = a_k P_{k-1}(a_0, \\dots, a_{k-1}) + P_{k-2}(a_0, \\dots, a_{k-2}).$$ Implementation \u00b6 We will compute the convergents as a pair of sequences $p_{-2}, p_{-1}, p_0, p_1, \\dots, p_k$ and $q_{-2}, q_{-1}, q_0, q_1, \\dots, q_k$ : C++ Python auto convergents ( vector < int > a ) { vector < int > p = { 0 , 1 }; vector < int > q = { 1 , 0 }; for ( auto it : a ) { p . push_back ( p [ p . size () - 1 ] * it + p [ p . size () - 2 ]); q . push_back ( q [ q . size () - 1 ] * it + q [ q . size () - 2 ]); } return make_pair ( p , q ); } def convergents ( a ): p = [ 0 , 1 ] q = [ 1 , 0 ] for it in a : p . append ( p [ - 1 ] * it + p [ - 2 ]) q . append ( q [ - 1 ] * it + q [ - 2 ]) return p , q Trees of continued fractions \u00b6 There are two major ways to unite all possible continued fractions into useful tree structures. Stern-Brocot tree \u00b6 The Stern-Brocot tree is a binary search tree that contains all distinct positive rational numbers. The tree generally looks as follows: The image by Aaron Rotenberg is licensed under CC BY-SA 3.0 Fractions $\\frac{0}{1}$ and $\\frac{1}{0}$ are \"virtually\" kept on the left and right sides of the tree correspondingly. Then the fraction in a node is a mediant $\\frac{a+c}{b+d}$ of two fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ above it. The recurrence $\\frac{p_k}{q_k}=\\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}}$ means that the continued fraction representation encodes the path to $\\frac{p_k}{q_k}$ in the tree. To find $[a_0; a_1, \\dots, a_{k}, 1]$ , one has to make $a_0$ moves to the right, $a_1$ moves to the left, $a_2$ moves to the right and so on up to $a_k$ . The parent of $[a_0; a_1, \\dots, a_k,1]$ then is the fraction obtained by taking one step back in the last used direction. In other words, it is $[a_0; a_1, \\dots, a_k-1,1]$ when $a_k > 1$ and $[a_0; a_1, \\dots, a_{k-1}, 1]$ when $a_k = 1$ . Thus the children of $[a_0; a_1, \\dots, a_k, 1]$ are $[a_0; a_1, \\dots, a_k+1, 1]$ and $[a_0; a_1, \\dots, a_k, 1, 1]$ . Let's index the Stern-Brocot tree. The root vertex is assigned an index $1$ . Then for a vertex $v$ , the index of its left child is assigned by changing the leading bit of $v$ from $1$ to $10$ and for the right child, it's assigned by changing the leading bit from $1$ to $11$ : In this indexing, the continued fraction representation of a rational number specifies the run-length encoding of its binary index. For $\\frac{5}{2} = [2;2] = [2;1,1]$ , its index is $1011_2$ and its run-length encoding, considering bits in the ascending order, is $[2;1,1]$ . Another example is $\\frac{2}{5} = [0;2,2]=[0;2,1,1]$ , which has index $1100_2$ and its run-length encoding is, indeed, $[0;2,2]$ . It is worth noting that the Stern-Brocot tree is, in fact, a treap . That is, it is a binary search tree by $\\frac{p}{q}$ , but it is a heap by both $p$ and $q$ . Comparing continued fractions You're given $A=[a_0; a_1, \\dots, a_n]$ and $B=[b_0; b_1, \\dots, b_m]$ . Which fraction is smaller? Solution Assume for now that $A$ and $B$ are irrational and their continued fraction representations denote an infinite descent in the Stern-Brocot tree. As we already mentioned, in this representation $a_0$ denotes the number of right turns in the descent, $a_1$ denotes the number of consequent left turns and so on. Therefore, when we compare $a_k$ and $b_k$ , if $a_k = b_k$ we should just move on to comparing $a_{k+1}$ and $b_{k+1}$ . Otherwise, if we're at right descents, we should check if $a_k < b_k$ and if we're at left descents, we should check if $a_k > b_k$ to tell whether $A < B$ . In other words, for irrational $A$ and $B$ it would be $A < B$ if and only if $(a_0, -a_1, a_2, -a_3, \\dots) < (b_0, -b_1, b_2, -b_3, \\dots)$ with lexicographical comparison. Now, formally using $\\infty$ as an element of continued fraction representation it is possible to emulate irrational numbers $A-\\varepsilon$ and $A+\\varepsilon$ , that is, elements that are smaller (greater) than $A$ , but greater (smaller) than any other real number. Specifically, for $A=[a_0; a_1, \\dots, a_n]$ , one of these two elements can be emulated as $[a_0; a_1, \\dots, a_n, \\infty]$ and the other can be emulated as $[a_0; a_1, \\dots, a_n - 1, 1, \\infty]$ . Which one corresponds to $A-\\varepsilon$ and which one to $A+\\varepsilon$ can be determined by the parity of $n$ or by comparing them as irrational numbers. Python # check if a < b assuming that a[-1] = b[-1] = infty and a != b def less ( a , b ): a = [( - 1 ) ** i * a [ i ] for i in range ( len ( a ))] b = [( - 1 ) ** i * b [ i ] for i in range ( len ( b ))] return a < b # [a0; a1, ..., ak] -> [a0, a1, ..., ak-1, 1] def expand ( a ): if a : # empty a = inf a [ - 1 ] -= 1 a . append ( 1 ) return a # return a-eps, a+eps def pm_eps ( a ): b = expand ( a . copy ()) a . append ( float ( 'inf' )) b . append ( float ( 'inf' )) return ( a , b ) if less ( a , b ) else ( b , a ) Best inner point You're given $\\frac{0}{1} \\leq \\frac{p_0}{q_0} < \\frac{p_1}{q_1} \\leq \\frac{1}{0}$ . Find the rational number $\\frac{p}{q}$ such that $(q; p)$ is lexicographically smallest and $\\frac{p_0}{q_0} < \\frac{p}{q} < \\frac{p_1}{q_1}$ . Solution In terms of the Stern-Brocot tree it means that we need to find the LCA of $\\frac{p_0}{q_0}$ and $\\frac{p_1}{q_1}$ . Due to the connection between Stern-Brocot tree and continued fraction, this LCA would roughly correspond to the largest common prefix of continued fraction representations for $\\frac{p_0}{q_0}$ and $\\frac{p_1}{q_1}$ . So, if $\\frac{p_0}{q_0} = [a_0; a_1, \\dots, a_{k-1}, a_k, \\dots]$ and $\\frac{p_1}{q_1} = [a_0; a_1, \\dots, a_{k-1}, b_k, \\dots]$ are irrational numbers, the LCA is $[a_0; a_1, \\dots, \\min(a_k, b_k)+1]$ . For rational $r_0$ and $r_1$ , one of them could be the LCA itself which would require us to casework it. To simplify the solution for rational $r_0$ and $r_1$ , it is possible to use continued fraction representation of $r_0 + \\varepsilon$ and $r_1 - \\varepsilon$ which was derived in the previous problem. Python # finds lexicographically smallest (q, p) # such that p0/q0 < p/q < p1/q1 def middle ( p0 , q0 , p1 , q1 ): a0 = pm_eps ( fraction ( p0 , q0 ))[ 1 ] a1 = pm_eps ( fraction ( p1 , q1 ))[ 0 ] a = [] for i in range ( min ( len ( a0 ), len ( a1 ))): a . append ( min ( a0 [ i ], a1 [ i ])) if a0 [ i ] != a1 [ i ]: break a [ - 1 ] += 1 p , q = convergents ( a ) return p [ - 1 ], q [ - 1 ] GCJ 2019, Round 2 - New Elements: Part 2 You're given $N$ positive integer pairs $(C_i, J_i)$ . You need to find a positive integer pair $(x, y)$ such that $C_i x + J_i y$ is a strictly increasing sequence. Among such pairs, find the lexicographically minimum one. Solution Rephrasing the statement, $A_i x + B_i y$ must be positive for all $i$ , where $A_i = C_i - C_{i-1}$ and $B_i = J_i - J_{i-1}$ . Among such equations we have four significant groups for $A_i x + B_i y > 0$ : $A_i, B_i > 0$ can be ignored since we're looking for $x, y > 0$ . $A_i, B_i \\leq 0$ would provide \"IMPOSSIBLE\" as an answer. $A_i > 0$ , $B_i \\leq 0$ . Such constraints are equivalent to $\\frac{y}{x} < \\frac{A_i}{-B_i}$ . $A_i \\leq 0$ , $B_i > 0$ . Such constraints are equivalent to $\\frac{y}{x} > \\frac{-A_i}{B_i}$ . Let $\\frac{p_0}{q_0}$ be the largest $\\frac{-A_i}{B_i}$ from the fourth group and $\\frac{p_1}{q_1}$ be the smallest $\\frac{A_i}{-B_i}$ from the third group. The problem is now, given $\\frac{p_0}{q_0} < \\frac{p_1}{q_1}$ , find a fraction $\\frac{p}{q}$ such that $(q;p)$ is lexicographically smallest and $\\frac{p_0}{q_0} < \\frac{p}{q} < \\frac{p_1}{q_1}$ . Python def solve (): n = int ( input ()) C = [ 0 ] * n J = [ 0 ] * n # p0/q0 < y/x < p1/q1 p0 , q0 = 0 , 1 p1 , q1 = 1 , 0 fail = False for i in range ( n ): C [ i ], J [ i ] = map ( int , input () . split ()) if i > 0 : A = C [ i ] - C [ i - 1 ] B = J [ i ] - J [ i - 1 ] if A <= 0 and B <= 0 : fail = True elif B > 0 and A < 0 : # y/x > (-A)/B if B > 0 if ( - A ) * q0 > p0 * B : p0 , q0 = - A , B elif B < 0 and A > 0 : # y/x < A/(-B) if B < 0 if A * q1 < p1 * ( - B ): p1 , q1 = A , - B if p0 * q1 >= p1 * q0 or fail : return 'IMPOSSIBLE' p , q = middle ( p0 , q0 , p1 , q1 ) return str ( q ) + ' ' + str ( p ) Calkin-Wilf tree \u00b6 A somewhat simpler way to organize continued fractions in a binary tree is the Calkin-Wilf tree . The tree generally looks like this: The image by Olli Niemitalo , Proz is licensed under CC0 1.0 In the root of the tree, the number $\\frac{1}{1}$ is located. Then, for the vertex with a number $\\frac{p}{q}$ , its children are $\\frac{p}{p+q}$ and $\\frac{p+q}{q}$ . Unlike the Stern-Brocot tree, the Calkin-Wilf tree is not a binary search tree, so it can't be used to perform rational binary search. In the Calkin-Wilf tree, the direct parent of a fraction $\\frac{p}{q}$ is $\\frac{p-q}{q}$ when $p>q$ and $\\frac{p}{q-p}$ otherwise. For the Stern-Brocot tree, we used the recurrence for convergents. To draw the connection between the continued fraction and the Calkin-Wilf tree, we should recall the recurrence for complete quotients. If $s_k = \\frac{p}{q}$ , then $s_{k+1} = \\frac{q}{p \\mod q} = \\frac{q}{p-\\lfloor p/q \\rfloor \\cdot q}$ . On the other hand, if we repeatedly go from $s_k = \\frac{p}{q}$ to its parent in the Calkin-Wilf tree when $p > q$ , we will end up in $\\frac{p \\mod q}{q} = \\frac{1}{s_{k+1}}$ . If we continue doing so, we will end up in $s_{k+2}$ , then $\\frac{1}{s_{k+3}}$ and so on. From this we can deduce that: When $a_0> 0$ , the direct parent of $[a_0; a_1, \\dots, a_k]$ in the Calkin-Wilf tree is $\\frac{p-q}{q}=[a_0 - 1; a_1, \\dots, a_k]$ . When $a_0 = 0$ and $a_1 > 1$ , its direct parent is $\\frac{p}{q-p} = [0; a_1 - 1, a_2, \\dots, a_k]$ . And when $a_0 = 0$ and $a_1 = 1$ , its direct parent is $\\frac{p}{q-p} = [a_2; a_3, \\dots, a_k]$ . Correspondingly, children of $\\frac{p}{q} = [a_0; a_1, \\dots, a_k]$ are $\\frac{p+q}{q}=1+\\frac{p}{q}$ , which is $[a_0+1; a_1, \\dots, a_k]$ , $\\frac{p}{p+q} = \\frac{1}{1+\\frac{q}{p}}$ , which is $[0, 1, a_0, a_1, \\dots, a_k]$ for $a_0 > 0$ and $[0, a_1+1, a_2, \\dots, a_k]$ for $a_0=0$ . Noteworthy, if we enumerate vertices of the Calkin-Wilf tree in the breadth-first search order (that is, the root has a number $1$ , and the children of the vertex $v$ have indices $2v$ and $2v+1$ correspondingly), the index of the rational number in the Calkin-Wilf tree would be the same as in the Stern-Brocot tree. Thus, numbers on the same levels of the Stern-Brocot tree and the Calkin-Wilf tree are the same, but their ordering differs through the bit-reversal permutation . Convergence \u00b6 For the number $r$ and its $k$ -th convergent $r_k=\\frac{p_k}{q_k}$ the following formula stands: $$r_k = a_0 + \\sum\\limits_{i=1}^k \\frac{(-1)^{i-1}}{q_i q_{i-1}}.$$ In particular, it means that $$r_k - r_{k-1} = \\frac{(-1)^{k-1}}{q_k q_{k-1}}$$ and $$p_k q_{k-1} - p_{k-1} q_k = (-1)^{k-1}.$$ From this we can conclude that $$\\left| r-\\frac{p_k}{q_k} \\right| \\leq \\frac{1}{q_{k+1}q_k} \\leq \\frac{1}{q_k^2}.$$ The latter inequality is due to the fact that $r_k$ and $r_{k+1}$ are generally located on different sides of $r$ , thus $$|r-r_k| = |r_k-r_{k+1}|-|r-r_{k+1}| \\leq |r_k - r_{k+1}|.$$ Detailed explanation To estimate $|r-r_k|$ , we start by estimating the difference between adjacent convergents. By definition, $$\\frac{p_k}{q_k} - \\frac{p_{k-1}}{q_{k-1}} = \\frac{p_k q_{k-1} - p_{k-1} q_k}{q_k q_{k-1}}.$$ Replacing $p_k$ and $q_k$ in the numerator with their recurrences, we get $$\\begin{align} p_k q_{k-1} - p_{k-1} q_k &= (a_k p_{k-1} + p_{k-2}) q_{k-1} - p_{k-1} (a_k q_{k-1} + q_{k-2}) \\\\&= p_{k-2} q_{k-1} - p_{k-1} q_{k-2},\\end{align}$$ thus the numerator of $r_k - r_{k-1}$ is always the negated numerator of $r_{k-1} - r_{k-2}$ . It, in turn, equals to $1$ for $$r_1 - r_0=\\left(a_0+\\frac{1}{a_1}\\right)-a_0=\\frac{1}{a_1},$$ thus $$r_k - r_{k-1} = \\frac{(-1)^{k-1}}{q_k q_{k-1}}.$$ This yields an alternative representation of $r_k$ as a partial sum of infinite series: $$r_k = (r_k - r_{k-1}) + \\dots + (r_1 - r_0) + r_0 = a_0 + \\sum\\limits_{i=1}^k \\frac{(-1)^{i-1}}{q_i q_{i-1}}.$$ From the recurrent relation it follows that $q_k$ monotonously increases at least as fast as Fibonacci numbers, thus $$r = \\lim\\limits_{k \\to \\infty} r_k = a_0 + \\sum\\limits_{i=1}^\\infty \\frac{(-1)^{i-1}}{q_i q_{i-1}}$$ is always well-defined, as the underlying series always converge. Noteworthy, the residual series $$r-r_k = \\sum\\limits_{i=k+1}^\\infty \\frac{(-1)^{i-1}}{q_i q_{i-1}}$$ has the same sign as $(-1)^k$ due to how fast $q_i q_{i-1}$ decreases. Hence even-indexed $r_k$ approach $r$ from below while odd-indexed $r_k$ approach it from above: Convergents of $r=\\phi = \\frac{1+\\sqrt{5}}{2}=[1;1,1,\\dots]$ and their distance from $r$ . From this picture we can see that $$|r-r_k| = |r_k - r_{k+1}| - |r-r_{k+1}| \\leq |r_k - r_{k+1}|,$$ thus the distance between $r$ and $r_k$ is never larger than the distance between $r_k$ and $r_{k+1}$ : $$\\left|r-\\frac{p_k}{q_k}\\right| \\leq \\frac{1}{q_k q_{k+1}} \\leq \\frac{1}{q_k^2}.$$ Extended Euclidean? You're given $A, B, C \\in \\mathbb Z$ . Find $x, y \\in \\mathbb Z$ such that $Ax + By = C$ . Solution Although this problem is typically solved with the extended Euclidean algorithm , there is a simple and straightforward solution with continued fractions. Let $\\frac{A}{B}=[a_0; a_1, \\dots, a_k]$ . It was proved above that $p_k q_{k-1} - p_{k-1} q_k = (-1)^{k-1}$ . Substituting $p_k$ and $q_k$ with $A$ and $B$ , we get $$Aq_{k-1} - Bp_{k-1} = (-1)^{k-1} g,$$ where $g = \\gcd(A, B)$ . If $C$ is divisible by $g$ , then the solution is $x = (-1)^{k-1}\\frac{C}{g} q_{k-1}$ and $y = (-1)^{k}\\frac{C}{g} p_{k-1}$ . Python # return (x, y) such that Ax+By=C # assumes that such (x, y) exists def dio ( A , B , C ): p , q = convergents ( fraction ( A , B )) C //= A // p [ - 1 ] # divide by gcd(A, B) t = ( - 1 ) if len ( p ) % 2 else 1 return t * C * q [ - 2 ], - t * C * p [ - 2 ] Linear fractional transformations \u00b6 Another important concept for continued fractions are the so-called linear fractional transformations . Definition A linear fractional transformation is a function $f : \\mathbb R \\to \\mathbb R$ such that $f(x) = \\frac{ax+b}{cx+d}$ for some $a,b,c,d \\in \\mathbb R$ . A composition $(L_0 \\circ L_1)(x) = L_0(L_1(x))$ of linear fractional transforms $L_0(x)=\\frac{a_0 x + b_0}{c_0 x + d_0}$ and $L_1(x)=\\frac{a_1 x + b_1}{c_1 x + d_1}$ is itself a linear fractional transform: $$\\frac{a_0\\frac{a_1 x + b_1}{c_1 x + d_1} + b_0}{c_0 \\frac{a_1 x + b_1}{c_1 x + d_1} + d_0} = \\frac{a_0(a_1 x + b_1) + b_0 (c_1 x + d_1)}{c_0 (a_1 x + b_1) + d_0 (c_1 x + d_1)} = \\frac{(a_0 a_1 + b_0 c_1) x + (a_0 b_1 + b_0 d_1)}{(c_0 a_1 + d_0 c_1) x + (c_0 b_1 + d_0 d_1)}.$$ Inverse of a linear fractional transform, is also a linear fractional transform: $$y = \\frac{ax+b}{cx+d} \\iff y(cx+d) = ax + b \\iff x = -\\frac{dy-b}{cy-a}.$$ DMOPC '19 Contest 7 P4 - Bob and Continued Fractions You're given an array of positive integers $a_1, \\dots, a_n$ . You need to answer $m$ queries. Each query is to compute $[a_l; a_{l+1}, \\dots, a_r]$ . Solution We can solve this problem with the segment tree if we're able to concatenate continued fractions. It's generally true that $[a_0; a_1, \\dots, a_k, b_0, b_1, \\dots, b_k] = [a_0; a_1, \\dots, a_k, [b_1; b_2, \\dots, b_k]]$ . Let's denote $L_{k}(x) = [a_k; x] = a_k + \\frac{1}{x} = \\frac{a_k\\cdot x+1}{1\\cdot x + 0}$ . Note that $L_k(\\infty) = a_k$ . In this notion, it holds that $$[a_0; a_1, \\dots, a_k, x] = [a_0; [a_1; [\\dots; [a_k; x]]]] = (L_0 \\circ L_1 \\circ \\dots \\circ L_k)(x) = \\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}.$$ Thus, the problem boils down to the computation of $$(L_l \\circ L_{l+1} \\circ \\dots \\circ L_r)(\\infty).$$ Composition of transforms is associative, so it's possible to compute in each node of a segment tree the composition of transforms in its subtree. Linear fractional transformation of a continued fraction Let $L(x) = \\frac{ax+b}{cx+d}$ . Compute the continued fraction representation $[b_0; b_1, \\dots, b_m]$ of $L(A)$ for $A=[a_0; a_1, \\dots, a_n]$ . This allows to compute $A + \\frac{p}{q} = \\frac{qA + p}{q}$ and $A \\cdot \\frac{p}{q} = \\frac{p A}{q}$ for any $\\frac{p}{q}$ . Solution As we noted above, $[a_0; a_1, \\dots, a_k] = (L_{a_0} \\circ L_{a_1} \\circ \\dots \\circ L_{a_k})(\\infty)$ , hence $L([a_0; a_1, \\dots, a_k]) = (L \\circ L_{a_0} \\circ L_{a_1} \\circ \\dots L_{a_k})(\\infty)$ . Hence, by consequentially adding $L_{a_0}$ , $L_{a_1}$ and so on we would be able to compute $$(L \\circ L_{a_0} \\circ \\dots \\circ L_{a_k})(x) = L\\left(\\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}\\right)=\\frac{a_k x + b_k}{c_k x + d_k}.$$ Since $L(x)$ is invertible, it is also monotonous in $x$ . Therefore, for any $x \\geq 0$ it holds that $L(\\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}})$ is between $L(\\frac{p_k}{q_k}) = \\frac{a_k}{c_k}$ and $L(\\frac{p_{k-1}}{q_{k-1}}) = \\frac{b_k}{d_k}$ . Moreover, for $x=[a_{k+1}; \\dots, a_n]$ it is equal to $L(A)$ . Hence, $b_0 = \\lfloor L(A) \\rfloor$ is between $\\lfloor L(\\frac{p_k}{q_k}) \\rfloor$ and $\\lfloor L(\\frac{p_{k-1}}{q_{k-1}}) \\rfloor$ . When they're equal, they're also equal to $b_0$ . Note that $L(A) = (L_{b_0} \\circ L_{b_1} \\circ \\dots \\circ L_{b_m})(\\infty)$ . Knowing $b_0$ , we can compose $L_{b_0}^{-1}$ with the current transform and continue adding $L_{a_{k+1}}$ , $L_{a_{k+2}}$ and so on, looking for new floors to agree, from which we would be able to deduce $b_1$ and so on until we recover all values of $[b_0; b_1, \\dots, b_m]$ . Continued fraction arithmetics Let $A=[a_0; a_1, \\dots, a_n]$ and $B=[b_0; b_1, \\dots, b_m]$ . Compute the continued fraction representations of $A+B$ and $A \\cdot B$ . Solution Idea here is similar to the previous problem, but instead of $L(x) = \\frac{ax+b}{cx+d}$ you should consider bilinear fractional transform $L(x, y) = \\frac{axy+bx+cy+d}{exy+fx+gy+h}$ . Rather than $L(x) \\mapsto L(L_{a_k}(x))$ you would change your current transform as $L(x, y) \\mapsto L(L_{a_k}(x), y)$ or $L(x, y) \\mapsto L(x, L_{b_k}(y))$ . Then, you check if $\\lfloor \\frac{a}{e} \\rfloor = \\lfloor \\frac{b}{f} \\rfloor = \\lfloor \\frac{c}{g} \\rfloor = \\lfloor \\frac{d}{h} \\rfloor$ and if they all agree, you use this value as $c_k$ in the resulting fraction and change the transform as $$L(x, y) \\mapsto \\frac{1}{L(x, y) - c_k}.$$ Definition A continued fraction $x = [a_0; a_1, \\dots]$ is said to be periodic if $x = [a_0; a_1, \\dots, a_k, x]$ for some $k$ . A continued fraction $x = [a_0; a_1, \\dots]$ is said to be eventually periodic if $x = [a_0; a_1, \\dots, a_k, y]$ , where $y$ is periodic. For $x = [1; 1, 1, \\dots]$ it holds that $x = 1 + \\frac{1}{x}$ , thus $x^2 = x + 1$ . There is a generic connection between periodic continued fractions and quadratic equations. Consider the following equation: $$ x = [a_0; a_1, \\dots, a_k, x].$$ On one hand, this equation means that the continued fraction representation of $x$ is periodic with the period $k+1$ . On the other hand, using the formula for convergents, this equation means that $$x = \\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}.$$ That is, $x$ is a linear fractional transformation of itself. It follows from the equation that $x$ is a root of the second degree equation: $$q_k x^2 + (q_{k-1}-p_k)x - p_{k-1} = 0.$$ Similar reasoning stands for continued fractions that are eventually periodic, that is $x = [a_0; a_1, \\dots, a_k, y]$ for $y=[b_0; b_1, \\dots, b_k, y]$ . Indeed, from first equation we derive that $x = L_0(y)$ and from second equation that $y = L_1(y)$ , where $L_0$ and $L_1$ are linear fractional transformations. Therefore, $$x = (L_0 \\circ L_1)(y) = (L_0 \\circ L_1 \\circ L_0^{-1})(x).$$ One can further prove (and it was first done by Lagrange) that for arbitrary quadratic equation $ax^2+bx+c=0$ with integer coefficients, its solution $x$ is an eventually periodic continued fraction. Quadratic irrationality Find the continued fraction of $\\alpha = \\frac{x+y\\sqrt{n}}{z}$ where $x, y, z, n \\in \\mathbb Z$ and $n > 0$ is not a perfect square. Solution For the $k$ -th complete quotient $s_k$ of the number it generally holds that $$\\alpha = [a_0; a_1, \\dots, a_{k-1}, s_k] = \\frac{s_k p_{k-1} + p_{k-2}}{s_k q_{k-1} + q_{k-2}}.$$ Therefore, $$s_k = -\\frac{\\alpha q_{k-1} - p_{k-1}}{\\alpha q_k - p_k} = -\\frac{q_{k-1} y \\sqrt n + (x q_{k-1} - z p_{k-1})}{q_k y \\sqrt n + (xq_k-zp_k)}.$$ Multiplying the numerator and denominator by $(xq_k - zp_k) - q_k y \\sqrt n$ , we'll get rid of $\\sqrt n$ in the denominator, thus the complete quotients are of form $$s_k = \\frac{x_k + y_k \\sqrt n}{z_k}.$$ Let's find $s_{k+1}$ , assuming that $s_k$ is known. First of all, $a_k = \\lfloor s_k \\rfloor = \\left\\lfloor \\frac{x_k + y_k \\lfloor \\sqrt n \\rfloor}{z_k} \\right\\rfloor$ . Then, $$s_{k+1} = \\frac{1}{s_k-a_k} = \\frac{z_k}{(x_k - z_k a_k) + y_k \\sqrt n} = \\frac{z_k (x_k - y_k a_k) - y_k z_k \\sqrt n}{(x_k - y_k a_k)^2 - y_k^2 n}.$$ Thus, if we denote $t_k = x_k - y_k a_k$ , it will hold that $$\\begin{align}x_{k+1} &=& z_k t_k, \\\\ y_{k+1} &=& -y_k z_k, \\\\ z_{k+1} &=& t_k^2 - y_k^2 n.\\end{align}$$ Nice thing about such representation is that if we reduce $x_{k+1}, y_{k+1}, z_{k+1}$ by their greatest common divisor, the result would be unique. Therefore, we may use it to check whether the current state has already been repeated and also to check where was the previous index that had this state. Below is the code to compute the continued fraction representation for $\\alpha = \\sqrt n$ : Python # compute the continued fraction of sqrt(n) def sqrt ( n ): n0 = math . floor ( math . sqrt ( n )) x , y , z = 1 , 0 , 1 a = [] def step ( x , y , z ): a . append (( x * n0 + y ) // z ) t = y - a [ - 1 ] * z x , y , z = - z * x , z * t , t ** 2 - n * x ** 2 g = math . gcd ( x , math . gcd ( y , z )) return x // g , y // g , z // g used = dict () for i in range ( n ): used [ x , y , z ] = i x , y , z = step ( x , y , z ) if ( x , y , z ) in used : return a Using the same step function but different initial $x$ , $y$ and $z$ it is possible to compute it for arbitrary $\\frac{x+y \\sqrt{n}}{z}$ . Tavrida NU Akai Contest - Continued Fraction You're given $x$ and $k$ , $x$ is not a perfect square. Let $\\sqrt x = [a_0; a_1, \\dots]$ , find $\\frac{p_k}{q_k}=[a_0; a_1, \\dots, a_k]$ for $0 \\leq k \\leq 10^9$ . Solution After computing the period of $\\sqrt x$ , it is possible to compute $a_k$ using binary exponentiation on the linear fractional transformation induced by the continued fraction representation. To find the resulting transformation, you compress the period of size $T$ into a single transformation and repeat it $\\lfloor \\frac{k-1}{T}\\rfloor$ times, after which you manually combine it with the remaining transformations. Python x , k = map ( int , input () . split ()) mod = 10 ** 9 + 7 # compose (A[0]*x + A[1]) / (A[2]*x + A[3]) and (B[0]*x + B[1]) / (B[2]*x + B[3]) def combine ( A , B ): return [ t % mod for t in [ A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 2 ], A [ 0 ] * B [ 1 ] + A [ 1 ] * B [ 3 ], A [ 2 ] * B [ 0 ] + A [ 3 ] * B [ 2 ], A [ 2 ] * B [ 1 ] + A [ 3 ] * B [ 3 ]]] A = [ 1 , 0 , 0 , 1 ] # (x + 0) / (0*x + 1) = x a = sqrt ( x ) T = len ( a ) - 1 # period of a # apply ak + 1/x = (ak*x+1)/(1x+0) to (Ax + B) / (Cx + D) for i in reversed ( range ( 1 , len ( a ))): A = combine ([ a [ i ], 1 , 1 , 0 ], A ) def bpow ( A , n ): return [ 1 , 0 , 0 , 1 ] if not n else combine ( A , bpow ( A , n - 1 )) if n % 2 else bpow ( combine ( A , A ), n // 2 ) C = ( 0 , 1 , 0 , 0 ) # = 1 / 0 while k % T : i = k % T C = combine ([ a [ i ], 1 , 1 , 0 ], C ) k -= 1 C = combine ( bpow ( A , k // T ), C ) C = combine ([ a [ 0 ], 1 , 1 , 0 ], C ) print ( str ( C [ 1 ]) + '/' + str ( C [ 3 ])) Geometric interpretation \u00b6 Let $\\vec r_k = (q_k;p_k)$ for the convergent $r_k = \\frac{p_k}{q_k}$ . Then, the following recurrence holds: $$\\vec r_k = a_k \\vec r_{k-1} + \\vec r_{k-2}.$$ Let $\\vec r = (1;r)$ . Then, each vector $(x;y)$ corresponds to the number that is equal to its slope coefficient $\\frac{y}{x}$ . With the notion of pseudoscalar product $(x_1;y_1) \\times (x_2;y_2) = x_1 y_2 - x_2 y_1$ , it can be shown (see the explanation below) that $$s_k = -\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r} = \\left|\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r}\\right|.$$ The last equation is due to the fact that $r_{k-1}$ and $r_{k-2}$ lie on the different sides of $r$ , thus pseudoscalar products of $\\vec r_{k-1}$ and $\\vec r_{k-2}$ with $\\vec r$ have distinct signs. With $a_k = \\lfloor s_k \\rfloor$ in mind, formula for $\\vec r_k$ now looks like $$\\vec r_k = \\vec r_{k-2} + \\left\\lfloor \\left| \\frac{\\vec r \\times \\vec r_{k-2}}{\\vec r \\times \\vec r_{k-1}}\\right|\\right\\rfloor \\vec r_{k-1}.$$ Note that $\\vec r_k \\times r = (q;p) \\times (1;r) = qr - p$ , thus $$a_k = \\left\\lfloor \\left| \\frac{q_{k-1}r-p_{k-1}}{q_{k-2}r-p_{k-2}} \\right| \\right\\rfloor.$$ Explanation As we have already noted, $a_k = \\lfloor s_k \\rfloor$ , where $s_k = [a_k; a_{k+1}, a_{k+2}, \\dots]$ . On the other hand, from the convergent recurrence we derive that $$r = [a_0; a_1, \\dots, a_{k-1}, s_k] = \\frac{s_k p_{k-1} + p_{k-2}}{s_k q_{k-1} + q_{k-2}}.$$ In vector form, it rewrites as $$\\vec r \\parallel s_k \\vec r_{k-1} + \\vec r_{k-2},$$ meaning that $\\vec r$ and $s_k \\vec r_{k-1} + \\vec r_{k-2}$ are collinear (that is, have the same slope coefficient). Taking the pseudoscalar product of both parts with $\\vec r$ , we get $$0 = s_k (\\vec r_{k-1} \\times \\vec r) + (\\vec r_{k-2} \\times \\vec r),$$ which yields the final formula $$s_k = -\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r}.$$ Nose stretching algorithm Each time you add $\\vec r_{k-1}$ to the vector $\\vec p$ , the value of $\\vec p \\times \\vec r$ is increased by $\\vec r_{k-1} \\times \\vec r$ . Thus, $a_k=\\lfloor s_k \\rfloor$ is the maximum integer number of $\\vec r_{k-1}$ vectors that can be added to $\\vec r_{k-2}$ without changing the sign of the cross product with $\\vec r$ . In other words, $a_k$ is the maximum integer number of times you can add $\\vec r_{k-1}$ to $\\vec r_{k-2}$ without crossing the line defined by $\\vec r$ : Convergents of $r=\\frac{7}{9}=[0;1,3,2]$ . Semiconvergents correspond to intermediate points between gray arrows. On the picture above, $\\vec r_2 = (4;3)$ is obtained by repeatedly adding $\\vec r_1 = (1;1)$ to $\\vec r_0 = (1;0)$ . When it is not possible to further add $\\vec r_1$ to $\\vec r_0$ without crossing the $y=rx$ line, we go to the other side and repeatedly add $\\vec r_2$ to $\\vec r_1$ to obtain $\\vec r_3 = (9;7)$ . This procedure generates exponentially longer vectors, that approach the line. For this property, the procedure of generating consequent convergent vectors was dubbed the nose stretching algorithm by Boris Delaunay. If we look on the triangle drawn on points $\\vec r_{k-2}$ , $\\vec r_{k}$ and $\\vec 0$ we will notice that its doubled area is $$|\\vec r_{k-2} \\times \\vec r_k| = |\\vec r_{k-2} \\times (\\vec r_{k-2} + a_k \\vec r_{k-1})| = a_k |\\vec r_{k-2} \\times \\vec r_{k-1}| = a_k.$$ Combined with the Pick's theorem , it means that there are no lattice points strictly inside the triangle and the only lattice points on its border are $\\vec 0$ and $\\vec r_{k-2} + t \\cdot \\vec r_{k-1}$ for all integer $t$ such that $0 \\leq t \\leq a_k$ . When joined for all possible $k$ it means that there are no integer points in the space between polygons formed by even-indexed and odd-indexed convergent vectors. This, in turn, means that $\\vec r_k$ with odd coefficients form a convex hull of lattice points with $x \\geq 0$ above the line $y=rx$ , while $\\vec r_k$ with even coefficients form a convex hull of lattice points with $x > 0$ below the line $y=rx$ . Definition These polygons are also known as Klein polygons , named after Felix Klein who first suggested this geometric interpretation to the continued fractions. Problem examples \u00b6 Now that the most important facts and concepts were introduced, it is time to delve into specific problem examples. Convex hull under the line Find the convex hull of lattice points $(x;y)$ such that $0 \\leq x \\leq N$ and $0 \\leq y \\leq rx$ for $r=[a_0;a_1,\\dots,a_k]=\\frac{p_k}{q_k}$ . Solution If we were considering the unbounded set $0 \\leq x$ , the upper convex hull would be given by the line $y=rx$ itself. However, with additional constraint $x \\leq N$ we'd need to eventually deviate from the line to maintain proper convex hull. Let $t = \\lfloor \\frac{N}{q_k}\\rfloor$ , then first $t$ lattice points on the hull after $(0;0)$ are $\\alpha \\cdot (q_k; p_k)$ for integer $1 \\leq \\alpha \\leq t$ . However $(t+1)(q_k; p_k)$ can't be next lattice point since $(t+1)q_k$ is greater than $N$ . To get to the next lattice points in the hull, we should get to the point $(x;y)$ which diverges from $y=rx$ by the smallest margin, while maintaining $x \\leq N$ . Convex hull of lattice points under $y=\\frac{4}{7}x$ for $0 \\leq x \\leq 19$ consists of points $(0;0), (7;4), (14;8), (16;9), (18;10), (19;10)$ . Let $(x; y)$ be the last current point in the convex hull. Then the next point $(x'; y')$ is such that $x' \\leq N$ and $(x'; y') - (x; y) = (\\Delta x; \\Delta y)$ is as close to the line $y=rx$ as possible. In other words, $(\\Delta x; \\Delta y)$ maximizes $r \\Delta x - \\Delta y$ subject to $\\Delta x \\leq N - x$ and $\\Delta y \\leq r \\Delta x$ . Points like that lie on the convex hull of lattice points below $y=rx$ . In other words, $(\\Delta x; \\Delta y)$ must be a lower semiconvergent of $r$ . That being said, $(\\Delta x; \\Delta y)$ is of form $(q_{i-1}; p_{i-1}) + t \\cdot (q_i; p_i)$ for some odd number $i$ and $0 \\leq t < a_i$ . To find such $i$ , we can traverse all possible $i$ starting from the largest one and use $t = \\lfloor \\frac{N-x-q_{i-1}}{q_i} \\rfloor$ for $i$ such that $N-x-q_{i-1} \\geq 0$ . With $(\\Delta x; \\Delta y) = (q_{i-1}; p_{i-1}) + t \\cdot (q_i; p_i)$ , the condition $\\Delta y \\leq r \\Delta x$ would be preserved by semiconvergent properties. And $t < a_i$ would hold because we already exhausted semiconvergents obtained from $i+2$ , hence $x + q_{i-1} + a_i q_i = x+q_{i+1}$ is greater than $N$ . Now that we may add $(\\Delta x; \\Delta y)$ , to $(x;y)$ for $k = \\lfloor \\frac{N-x}{\\Delta x} \\rfloor$ times before we exceed $N$ , after which we would try the next semiconvergent. C++ Python // returns [ah, ph, qh] such that points r[i]=(ph[i], qh[i]) constitute upper convex hull // of lattice points on 0 <= x <= N and 0 <= y <= r * x, where r = [a0; a1, a2, ...] // and there are ah[i]-1 integer points on the segment between r[i] and r[i+1] auto hull ( auto a , int N ) { auto [ p , q ] = convergents ( a ); int t = N / q . back (); vector ah = { t }; vector ph = { 0 , t * p . back ()}; vector qh = { 0 , t * q . back ()}; for ( int i = q . size () - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) { while ( qh . back () + q [ i - 1 ] <= N ) { t = ( N - qh . back () - q [ i - 1 ]) / q [ i ]; int dp = p [ i - 1 ] + t * p [ i ]; int dq = q [ i - 1 ] + t * q [ i ]; int k = ( N - qh . back ()) / dq ; ah . push_back ( k ); ph . push_back ( ph . back () + k * dp ); qh . push_back ( qh . back () + k * dq ); } } } return make_tuple ( ah , ph , qh ); } # returns [ah, ph, qh] such that points r[i]=(ph[i], qh[i]) constitute upper convex hull # of lattice points on 0 <= x <= N and 0 <= y <= r * x, where r = [a0; a1, a2, ...] # and there are ah[i]-1 integer points on the segment between r[i] and r[i+1] def hull ( a , N ): p , q = convergents ( a ) t = N // q [ - 1 ] ah = [ t ] ph = [ 0 , t * p [ - 1 ]] qh = [ 0 , t * q [ - 1 ]] for i in reversed ( range ( len ( q ))): if i % 2 == 1 : while qh [ - 1 ] + q [ i - 1 ] <= N : t = ( N - qh [ - 1 ] - q [ i - 1 ]) // q [ i ] dp = p [ i - 1 ] + t * p [ i ] dq = q [ i - 1 ] + t * q [ i ] k = ( N - qh [ - 1 ]) // dq ah . append ( k ) ph . append ( ph [ - 1 ] + k * dp ) qh . append ( qh [ - 1 ] + k * dq ) return ah , ph , qh Timus - Crime and Punishment You're given integer numbers $A$ , $B$ and $N$ . Find $x \\geq 0$ and $y \\geq 0$ such that $Ax + By \\leq N$ and $Ax + By$ is the maximum possible. Solution In this problem it holds that $1 \\leq A, B, N \\leq 2 \\cdot 10^9$ , so it can be solved in $O(\\sqrt N)$ . However, there is $O(\\log N)$ solution with continued fractions. For our convenience, we will invert the direction of $x$ by doing a substitution $x \\mapsto \\lfloor \\frac{N}{A}\\rfloor - x$ , so that now we need to find the point $(x; y)$ such that $0 \\leq x \\leq \\lfloor \\frac{N}{A} \\rfloor$ , $By - Ax \\leq N \\;\\bmod\\; A$ and $By - Ax$ is the maximum possible. Optimal $y$ for each $x$ has a value of $\\lfloor \\frac{Ax + (N \\bmod A)}{B} \\rfloor$ . To treat it more generically, we will write a function that finds the best point on $0 \\leq x \\leq N$ and $y = \\lfloor \\frac{Ax+B}{C} \\rfloor$ . Core solution idea in this problem essentially repeats the previous problem, but instead of using lower semiconvergents to diverge from line, you use upper semiconvergents to get closer to the line without crossing it and without violating $x \\leq N$ . Unfortunately, unlike the previous problem, you need to make sure that you don't cross the $y=\\frac{Ax+B}{C}$ line while getting closer to it, so you should keep it in mind when calculating semiconvergent's coefficient $t$ . Python # (x, y) such that y = (A*x+B) // C, # Cy - Ax is max and 0 <= x <= N. def closest ( A , B , C , N ): # y <= (A*x + B)/C <=> diff(x, y) <= B def diff ( x , y ): return C * y - A * x a = fraction ( A , C ) p , q = convergents ( a ) ph = [ B // C ] qh = [ 0 ] for i in range ( 2 , len ( q ) - 1 ): if i % 2 == 0 : while diff ( qh [ - 1 ] + q [ i + 1 ], ph [ - 1 ] + p [ i + 1 ]) <= B : t = 1 + ( diff ( qh [ - 1 ] + q [ i - 1 ], ph [ - 1 ] + p [ i - 1 ]) - B - 1 ) // abs ( diff ( q [ i ], p [ i ])) dp = p [ i - 1 ] + t * p [ i ] dq = q [ i - 1 ] + t * q [ i ] k = ( N - qh [ - 1 ]) // dq if k == 0 : return qh [ - 1 ], ph [ - 1 ] if diff ( dq , dp ) != 0 : k = min ( k , ( B - diff ( qh [ - 1 ], ph [ - 1 ])) // diff ( dq , dp )) qh . append ( qh [ - 1 ] + k * dq ) ph . append ( ph [ - 1 ] + k * dp ) return qh [ - 1 ], ph [ - 1 ] def solve ( A , B , N ): x , y = closest ( A , N % A , B , N // A ) return N // A - x , y June Challenge 2017 - Euler Sum Compute $\\sum\\limits_{x=1}^N \\lfloor ex \\rfloor$ , where $e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, \\dots, 1, 2n, 1, \\dots]$ is the Euler's number and $N \\leq 10^{4000}$ . Solution This sum is equal to the number of lattice point $(x;y)$ such that $1 \\leq x \\leq N$ and $1 \\leq y \\leq ex$ . After constructing the convex hull of the points below $y=ex$ , this number can be computed using Pick's theorem : C++ Python // sum floor(k * x) for k in [1, N] and x = [a0; a1, a2, ...] int sum_floor ( auto a , int N ) { N ++ ; auto [ ah , ph , qh ] = hull ( a , N ); // The number of lattice points within a vertical right trapezoid // on points (0; 0) - (0; y1) - (dx; y2) - (dx; 0) that has // a+1 integer points on the segment (0; y1) - (dx; y2). auto picks = []( int y1 , int y2 , int dx , int a ) { int b = y1 + y2 + a + dx ; int A = ( y1 + y2 ) * dx ; return ( A - b + 2 ) / 2 + b - ( y2 + 1 ); }; int ans = 0 ; for ( size_t i = 1 ; i < qh . size (); i ++ ) { ans += picks ( ph [ i - 1 ], ph [ i ], qh [ i ] - qh [ i - 1 ], ah [ i - 1 ]); } return ans - N ; } # sum floor(k * x) for k in [1, N] and x = [a0; a1, a2, ...] def sum_floor ( a , N ): N += 1 ah , ph , qh = hull ( a , N ) # The number of lattice points within a vertical right trapezoid # on points (0; 0) - (0; y1) - (dx; y2) - (dx; 0) that has # a+1 integer points on the segment (0; y1) - (dx; y2). def picks ( y1 , y2 , dx , a ): b = y1 + y2 + a + dx A = ( y1 + y2 ) * dx return ( A - b + 2 ) // 2 + b - ( y2 + 1 ) ans = 0 for i in range ( 1 , len ( qh )): ans += picks ( ph [ i - 1 ], ph [ i ], qh [ i ] - qh [ i - 1 ], ah [ i - 1 ]) return ans - N NAIPC 2019 - It's a Mod, Mod, Mod, Mod World Given $p$ , $q$ and $n$ , compute $\\sum\\limits_{i=1}^n [p \\cdot i \\bmod q]$ . Solution This problem reduces to the previous one if you note that $a \\bmod b = a - \\lfloor \\frac{a}{b} \\rfloor b$ . With this fact, the sum reduces to $$\\sum\\limits_{i=1}^n \\left(p \\cdot i - \\left\\lfloor \\frac{p \\cdot i}{q} \\right\\rfloor q\\right) = \\frac{pn(n+1)}{2}-q\\sum\\limits_{i=1}^n \\left\\lfloor \\frac{p \\cdot i}{q}\\right\\rfloor.$$ However, summing up $\\lfloor rx \\rfloor$ for $x$ from $1$ to $N$ is something that we're capable of from the previous problem. C++ Python void solve ( int p , int q , int N ) { cout << p * N * ( N + 1 ) / 2 - q * sum_floor ( fraction ( p , q ), N ) << \" \\n \" ; } def solve ( p , q , N ): return p * N * ( N + 1 ) // 2 - q * sum_floor ( fraction ( p , q ), N ) Library Checker - Sum of Floor of Linear Given $N$ , $M$ , $A$ and $B$ , compute $\\sum\\limits_{i=0}^{N-1} \\lfloor \\frac{A \\cdot i + B}{M} \\rfloor$ . Solution This is the most technically troublesome problem so far. It is possible to use the same approach and construct the full convex hull of points below the line $y = \\frac{Ax+B}{M}$ . We already know how to solve it for $B = 0$ . Moreover, we already know how to construct this convex hull up to the closest lattice point to this line on $[0, N-1]$ segment (this is done in the \"Crime and Punishment\" problem above. Now we should note that once we reached the closest point to the line, we can just assume that the line in fact passes through the closest point, as there are no other lattice points on $[0, N-1]$ in between the actual line and the line moved slightly below to pass through the closest point. That being said, to construct the full convex hull below the line $y=\\frac{Ax+B}{M}$ on $[0, N-1]$ , we can construct it up to the closest point to the line on $[0, N-1]$ and then continue as if the line passes through this point, reusing algorithm for constructing convex hull with $B=0$ : Python # hull of lattice (x, y) such that C*y <= A*x+B def hull ( A , B , C , N ): def diff ( x , y ): return C * y - A * x a = fraction ( A , C ) p , q = convergents ( a ) ah = [] ph = [ B // C ] qh = [ 0 ] def insert ( dq , dp ): k = ( N - qh [ - 1 ]) // dq if diff ( dq , dp ) > 0 : k = min ( k , ( B - diff ( qh [ - 1 ], ph [ - 1 ])) // diff ( dq , dp )) ah . append ( k ) qh . append ( qh [ - 1 ] + k * dq ) ph . append ( ph [ - 1 ] + k * dp ) for i in range ( 1 , len ( q ) - 1 ): if i % 2 == 0 : while diff ( qh [ - 1 ] + q [ i + 1 ], ph [ - 1 ] + p [ i + 1 ]) <= B : t = ( B - diff ( qh [ - 1 ] + q [ i + 1 ], ph [ - 1 ] + p [ i + 1 ])) // abs ( diff ( q [ i ], p [ i ])) dp = p [ i + 1 ] - t * p [ i ] dq = q [ i + 1 ] - t * q [ i ] if dq < 0 or qh [ - 1 ] + dq > N : break insert ( dq , dp ) insert ( q [ - 1 ], p [ - 1 ]) for i in reversed ( range ( len ( q ))): if i % 2 == 1 : while qh [ - 1 ] + q [ i - 1 ] <= N : t = ( N - qh [ - 1 ] - q [ i - 1 ]) // q [ i ] dp = p [ i - 1 ] + t * p [ i ] dq = q [ i - 1 ] + t * q [ i ] insert ( dq , dp ) return ah , ph , qh OKC 2 - From Modular to Rational There is a rational number $\\frac{p}{q}$ such that $1 \\leq p, q \\leq 10^9$ . You may ask the value of $p q^{-1}$ modulo $m \\sim 10^9$ for several prime numbers $m$ . Recover $\\frac{p}{q}$ . Equivalent formulation: Find $x$ that delivers the minimum of $Ax \\;\\bmod\\; M$ for $1 \\leq x \\leq N$ . Solution Due to Chinese remainder theorem, asking the result modulo several prime numbers is the same as asking it modulo their product. Due to this, without loss of generality we'll assume that we know the remainder modulo sufficiently large number $m$ . There could be several possible solutions $(p, q)$ to $p \\equiv qr \\pmod m$ for a given remainder $r$ . However, if $(p_1, q_1)$ and $(p_2, q_2)$ are both the solutions then it also holds that $p_1 q_2 \\equiv p_2 q_1 \\pmod m$ . Assuming that $\\frac{p_1}{q_1} \\neq \\frac{p_2}{q_2}$ it means that $|p_1 q_2 - p_2 q_1|$ is at least $m$ . In the statement we were told that $1 \\leq p, q \\leq 10^9$ , so if both $p_1, q_1$ and $p_2, q_2$ are at most $10^9$ , then the difference is at most $10^{18}$ . For $m > 10^{18}$ it means that the solution $\\frac{p}{q}$ with $1 \\leq p, q \\leq 10^9$ is unique, as a rational number. So, the problem boils down, given $r$ modulo $m$ , to finding any $q$ such that $1 \\leq q \\leq 10^9$ and $qr \\;\\bmod\\; m \\leq 10^9$ . This is effectively the same as finding $q$ that delivers the minimum possible $qr \\bmod m$ for $1 \\leq q \\leq 10^9$ . For $qr = km + b$ it means that we need to find a pair $(q, m)$ such that $1 \\leq q \\leq 10^9$ and $qr - km \\geq 0$ is the minimum possible. Since $m$ is constant, we can divide by it and further restate it as find $q$ such that $1 \\leq q \\leq 10^9$ and $\\frac{r}{m} q - k \\geq 0$ is the minimum possible. In terms of continued fractions it means that $\\frac{k}{q}$ is the best diophantine approximation to $\\frac{r}{m}$ and it is sufficient to only check lower semiconvergents of $\\frac{r}{m}$ . Python # find Q that minimizes Q*r mod m for 1 <= k <= n < m def mod_min ( r , n , m ): a = fraction ( r , m ) p , q = convergents ( a ) for i in range ( 2 , len ( q )): if i % 2 == 1 and ( i + 1 == len ( q ) or q [ i + 1 ] > n ): t = ( n - q [ i - 1 ]) // q [ i ] return q [ i - 1 ] + t * q [ i ] Practice problems \u00b6 UVa OJ - Continued Fractions ProjectEuler+ #64: Odd period square roots Codeforces Round #184 (Div. 2) - Continued Fractions Codeforces Round #201 (Div. 1) - Doodle Jump Codeforces Round #325 (Div. 1) - Alice, Bob, Oranges and Apples POJ Founder Monthly Contest 2008.03.16 - A Modular Arithmetic Challenge 2019 Multi-University Training Contest 5 - fraction SnackDown 2019 Elimination Round - Election Bait Code Jam 2019 round 2 - Continued Fraction","title":"Continued fractions"},{"location":"algebra/continued-fractions.html#continued-fractions","text":"Continued fraction is a representation of a real number as a specific convergent sequence of rational numbers. They are useful in competitive programming because they are easy to compute and can be efficiently used to find the best possible rational approximation of the underlying real number (among all numbers whose denominator doesn't exceed a given value). Besides that, continued fractions are closely related to Euclidean algorithm which makes them useful in a bunch of number-theoretical problems.","title":"Continued fractions"},{"location":"algebra/continued-fractions.html#continued-fraction-representation","text":"Definition Let $a_0, a_1, \\dots, a_k \\in \\mathbb Z$ and $a_1, a_2, \\dots, a_k \\geq 1$ . Then the expression $$r=a_0 + \\frac{1}{a_1 + \\frac{1}{\\dots + \\frac{1}{a_k}}},$$ is called the continued fraction representation of the rational number $r$ and is denoted shortly as $r=[a_0;a_1,a_2,\\dots,a_k]$ . Example Let $r = \\frac{5}{3}$ . There are two ways to represent it as a continued fraction: $$ \\begin{align} r = [1;1,1,1] &= 1+\\frac{1}{1+\\frac{1}{1+\\frac{1}{1}}},\\\\ r = [1;1,2] &= 1+\\frac{1}{1+\\frac{1}{2}}. \\end{align} $$ It can be proven that any rational number can be represented as a continued fraction in exactly $2$ ways: $$r = [a_0;a_1,\\dots,a_k,1] = [a_0;a_1,\\dots,a_k+1].$$ Moreover, the length $k$ of such continued fraction is estimated as $k = O(\\log \\min(p, q))$ for $r=\\frac{p}{q}$ . The reasoning behind this will be clear once we delve into the details of the continued fraction construction. Definition Let $a_0,a_1,a_2, \\dots$ be an integer sequence such that $a_1, a_2, \\dots \\geq 1$ . Let $r_k = [a_0; a_1, \\dots, a_k]$ . Then the expression $$r = a_0 + \\frac{1}{a_1 + \\frac{1}{a_2+\\dots}} = \\lim\\limits_{k \\to \\infty} r_k.$$ is called the continued fraction representation of the irrational number $r$ and is denoted shortly as $r = [a_0;a_1,a_2,\\dots]$ . Note that for $r=[a_0;a_1,\\dots]$ and integer $k$ , it holds that $r+k = [a_0+k; a_1, \\dots]$ . Another important observation is that $\\frac{1}{r}=[0;a_0, a_1, \\dots]$ when $a_0 > 0$ and $\\frac{1}{r} = [a_1; a_2, \\dots]$ when $a_0 = 0$ . Definition In the definition above, rational numbers $r_0, r_1, r_2, \\dots$ are called the convergents of $r$ . Correspondingly, individual $r_k = [a_0; a_1, \\dots, a_k] = \\frac{p_k}{q_k}$ is called the $k$ -th convergent of $r$ . Example Consider $r = [1; 1, 1, 1, \\dots]$ . It can be proven by induction that $r_k = \\frac{F_{k+2}}{F_{k+1}}$ , where $F_k$ is the Fibonacci sequence defined as $F_0 = 0$ , $F_1 = 1$ and $F_{k} = F_{k-1} + F_{k-2}$ . From the Binet's formula, it is known that $$r_k = \\frac{\\phi^{k+2} - \\psi^{k+2}}{\\phi^{k+1} - \\psi^{k+1}},$$ where $\\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618$ is the golden ratio and $\\psi = \\frac{1-\\sqrt{5}}{2} = -\\frac{1}{\\phi} \\approx -0.618$ . Thus, $$r = 1+\\frac{1}{1+\\frac{1}{1+\\dots}}=\\lim\\limits_{k \\to \\infty} r_k = \\phi = \\frac{1+\\sqrt{5}}{2}.$$ Note that in this specific case, an alternative way to find $r$ would be to solve the equation $$r = 1+\\frac{1}{r} \\implies r^2 = r + 1. $$ Definition Let $r_k = [a_0; a_1, \\dots, a_{k-1}, a_k]$ . The numbers $[a_0; a_1, \\dots, a_{k-1}, t]$ for $1 \\leq t \\leq a_k$ are called semiconvergents . We will typically refer to (semi)convergents that are greater than $r$ as upper (semi)convergents and to those that are less than $r$ as lower (semi)convergents. Definition Complementary to convergents, we define the complete quotients as $s_k = [a_k; a_{k+1}, a_{k+2}, \\dots]$ . Correspondingly, we will call an individual $s_k$ the $k$ -th complete quotient of $r$ . From the definitions above, one can conclude that $s_k \\geq 1$ for $k \\geq 1$ . Treating $[a_0; a_1, \\dots, a_k]$ as a formal algebraic expression and allowing arbitrary real numbers instead of $a_i$ , we obtain $$r = [a_0; a_1, \\dots, a_{k-1}, s_k].$$ In particular, $r = [s_0] = s_0$ . On the other hand, we can express $s_k$ as $$s_k = [a_k; s_{k+1}] = a_k + \\frac{1}{s_{k+1}},$$ meaning that we can compute $a_k = \\lfloor s_k \\rfloor$ and $s_{k+1} = (s_k - a_k)^{-1}$ from $s_k$ . The sequence $a_0, a_1, \\dots$ is well-defined unless $s_k=a_k$ which only happens when $r$ is a rational number. Thus the continued fraction representation is uniquely defined for any irrational number $r$ .","title":"Continued fraction representation"},{"location":"algebra/continued-fractions.html#implementation","text":"In the code snippets we will mostly assume finite continued fractions. From $s_k$ , the transition to $s_{k+1}$ looks like $$s_k =\\left\\lfloor s_k \\right\\rfloor + \\frac{1}{s_{k+1}}.$$ From this expression, the next complete quotient $s_{k+1}$ is obtained as $$s_{k+1} = \\left(s_k-\\left\\lfloor s_k\\right\\rfloor\\right)^{-1}.$$ For $s_k=\\frac{p}{q}$ it means that $$ s_{k+1} = \\left(\\frac{p}{q}-\\left\\lfloor \\frac{p}{q} \\right\\rfloor\\right)^{-1} = \\frac{q}{p-q\\cdot \\lfloor \\frac{p}{q} \\rfloor} = \\frac{q}{p \\bmod q}. $$ Thus, the computation of a continued fraction representation for $r=\\frac{p}{q}$ follows the steps of the Euclidean algorithm for $p$ and $q$ . From this also follows that $\\gcd(p_k, q_k) = 1$ for $\\frac{p_k}{q_k} = [a_0; a_1, \\dots, a_k]$ . Hence, convergents are always irreducible. C++ Python auto fraction ( int p , int q ) { vector < int > a ; while ( q ) { a . push_back ( p / q ); tie ( p , q ) = make_pair ( q , p % q ); } return a ; } def fraction ( p , q ): a = [] while q : a . append ( p // q ) p , q = q , p % q return a","title":"Implementation"},{"location":"algebra/continued-fractions.html#key-results","text":"To provide some motivation for further study of continued fraction, we give some key facts now. Recurrence For the convergents $r_k = \\frac{p_k}{q_k}$ , the following recurrence stands, allowing their fast computation: $$\\frac{p_k}{q_k}=\\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}},$$ where $\\frac{p_{-1}}{q_{-1}}=\\frac{1}{0}$ and $\\frac{p_{-2}}{q_{-2}}=\\frac{0}{1}$ . Deviations The deviation of $r_k = \\frac{p_k}{q_k}$ from $r$ can be generally estimated as $$\\left|\\frac{p_k}{q_k}-r\\right| \\leq \\frac{1}{q_k q_{k+1}} \\leq \\frac{1}{q_k^2}.$$ Multiplying both sides with $q_k$ , we obtain alternate estimation: $$|p_k - q_k r| \\leq \\frac{1}{q_{k+1}}.$$ From the recurrence above it follows that $q_k$ grows at least as fast as Fibonacci numbers. On the picture below you may see the visualization of how convergents $r_k$ approach $r=\\frac{1+\\sqrt 5}{2}$ : $r=\\frac{1+\\sqrt 5}{2}$ is depicted by blue dotted line. Odd convergents approach it from above and even convergents approach it from below. Lattice hulls Consider convex hulls of points above and below the line $y=rx$ . Odd convergents $(q_k;p_k)$ are the vertices of the upper hull, while the even convergents $(q_k;p_k)$ are the vertices of the bottom hull. All integers vertices on the hulls are obtained as $(q;p)$ such that $$\\frac{p}{q} = \\frac{tp_{k-1} + p_{k-2}}{tq_{k-1} + q_{k-2}}$$ for integer $0 \\leq t \\leq a_k$ . In other words, the set of lattice points on the hulls corresponds to the set of semiconvergents. On the picture below, you may see the convergents and semiconvergents (intermediate gray points) of $r=\\frac{9}{7}$ . Best approximations Let $\\frac{p}{q}$ be the fraction to minimize $\\left|r-\\frac{p}{q}\\right|$ subject to $q \\leq x$ for some $x$ . Then $\\frac{p}{q}$ is a semiconvergent of $r$ . The last fact allows to find the best rational approximations of $r$ by checking its semiconvergents. Below you will find the further explanation and a bit of intuition and interpretation for these facts.","title":"Key results"},{"location":"algebra/continued-fractions.html#convergents","text":"Let's take a closer look at the convergents that were defined earlier. For $r=[a_0, a_1, a_2, \\dots]$ , its convergents are $$\\begin{gather} r_0=[a_0],\\\\r_1=[a_0, a_1],\\\\ \\dots,\\\\ r_k=[a_0, a_1, \\dots, a_k]. \\end{gather}$$ Convergents are the core concept of continued fractions, so it is important to study their properties. For the number $r$ , its $k$ -th convergent $r_k = \\frac{p_k}{q_k}$ can be computed as $$r_k = \\frac{P_k(a_0,a_1,\\dots,a_k)}{P_{k-1}(a_1,\\dots,a_k)} = \\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}},$$ where $P_k(a_0,\\dots,a_k)$ is the continuant , a multivariate polynomial defined as $$P_k(x_0,x_1,\\dots,x_k) = \\det \\begin{bmatrix} x_k & 1 & 0 & \\dots & 0 \\\\ -1 & x_{k-1} & 1 & \\dots & 0 \\\\ 0 & -1 & x_2 & . & \\vdots \\\\ \\vdots & \\vdots & . & \\ddots & 1 \\\\ 0 & 0 & \\dots & -1 & x_0 \\end{bmatrix}_{\\textstyle .}$$ Thus, $r_k$ is a weighted mediant of $r_{k-1}$ and $r_{k-2}$ . For consistency, two additional convergents $r_{-1} = \\frac{1}{0}$ and $r_{-2} = \\frac{0}{1}$ are defined. Detailed explanation The numerator and the denominator of $r_k$ can be seen as multivariate polynomials of $a_0, a_1, \\dots, a_k$ : $$r_k = \\frac{P_k(a_0, a_1, \\dots, a_k)}{Q_k(a_0,a_1, \\dots, a_k)}.$$ From the definition of convergents, $$r_k = a_0 + \\frac{1}{[a_1;a_2,\\dots, a_k]}= a_0 + \\frac{Q_{k-1}(a_1, \\dots, a_k)}{P_{k-1}(a_1, \\dots, a_k)} = \\frac{a_0 P_{k-1}(a_1, \\dots, a_k) + Q_{k-1}(a_1, \\dots, a_k)}{P_{k-1}(a_1, \\dots, a_k)}.$$ From this follows $Q_k(a_0, \\dots, a_k) = P_{k-1}(a_1, \\dots, a_k)$ . This yields the relation $$P_k(a_0, \\dots, a_k) = a_0 P_{k-1}(a_1, \\dots, a_k) + P_{k-2}(a_2, \\dots, a_k).$$ Initially, $r_0 = \\frac{a_0}{1}$ and $r_1 = \\frac{a_0 a_1 + 1}{a_1}$ , thus $$\\begin{align}P_0(a_0)&=a_0,\\\\ P_1(a_0, a_1) &= a_0 a_1 + 1.\\end{align}$$ For consistency, it is convenient to define $P_{-1} = 1$ and $P_{-2}=0$ and formally say that $r_{-1} = \\frac{1}{0}$ and $r_{-2}=\\frac{0}{1}$ . From numerical analysis, it is known that the determinant of an arbitrary tridiagonal matrix $$T_k = \\det \\begin{bmatrix} a_0 & b_0 & 0 & \\dots & 0 \\\\ c_0 & a_1 & b_1 & \\dots & 0 \\\\ 0 & c_1 & a_2 & . & \\vdots \\\\ \\vdots & \\vdots & . & \\ddots & c_{k-1} \\\\ 0 & 0 & \\dots & b_{k-1} & a_k \\end{bmatrix}$$ can be computed recursively as $T_k = a_k T_{k-1} - b_{k-1} c_{k-1} T_{k-2}$ . Comparing it to $P_k$ , we get a direct expression $$P_k = \\det \\begin{bmatrix} x_k & 1 & 0 & \\dots & 0 \\\\ -1 & x_{k-1} & 1 & \\dots & 0 \\\\ 0 & -1 & x_2 & . & \\vdots \\\\ \\vdots & \\vdots & . & \\ddots & 1 \\\\ 0 & 0 & \\dots & -1 & x_0 \\end{bmatrix}_{\\textstyle .}$$ This polynomial is also known as the continuant due to its close relation with continued fraction. The continuant won't change if the sequence on the main diagonal is reversed. This yields an alternative formula to compute it: $$P_k(a_0, \\dots, a_k) = a_k P_{k-1}(a_0, \\dots, a_{k-1}) + P_{k-2}(a_0, \\dots, a_{k-2}).$$","title":"Convergents"},{"location":"algebra/continued-fractions.html#implementation_1","text":"We will compute the convergents as a pair of sequences $p_{-2}, p_{-1}, p_0, p_1, \\dots, p_k$ and $q_{-2}, q_{-1}, q_0, q_1, \\dots, q_k$ : C++ Python auto convergents ( vector < int > a ) { vector < int > p = { 0 , 1 }; vector < int > q = { 1 , 0 }; for ( auto it : a ) { p . push_back ( p [ p . size () - 1 ] * it + p [ p . size () - 2 ]); q . push_back ( q [ q . size () - 1 ] * it + q [ q . size () - 2 ]); } return make_pair ( p , q ); } def convergents ( a ): p = [ 0 , 1 ] q = [ 1 , 0 ] for it in a : p . append ( p [ - 1 ] * it + p [ - 2 ]) q . append ( q [ - 1 ] * it + q [ - 2 ]) return p , q","title":"Implementation"},{"location":"algebra/continued-fractions.html#trees-of-continued-fractions","text":"There are two major ways to unite all possible continued fractions into useful tree structures.","title":"Trees of continued fractions"},{"location":"algebra/continued-fractions.html#stern-brocot-tree","text":"The Stern-Brocot tree is a binary search tree that contains all distinct positive rational numbers. The tree generally looks as follows: The image by Aaron Rotenberg is licensed under CC BY-SA 3.0 Fractions $\\frac{0}{1}$ and $\\frac{1}{0}$ are \"virtually\" kept on the left and right sides of the tree correspondingly. Then the fraction in a node is a mediant $\\frac{a+c}{b+d}$ of two fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ above it. The recurrence $\\frac{p_k}{q_k}=\\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}}$ means that the continued fraction representation encodes the path to $\\frac{p_k}{q_k}$ in the tree. To find $[a_0; a_1, \\dots, a_{k}, 1]$ , one has to make $a_0$ moves to the right, $a_1$ moves to the left, $a_2$ moves to the right and so on up to $a_k$ . The parent of $[a_0; a_1, \\dots, a_k,1]$ then is the fraction obtained by taking one step back in the last used direction. In other words, it is $[a_0; a_1, \\dots, a_k-1,1]$ when $a_k > 1$ and $[a_0; a_1, \\dots, a_{k-1}, 1]$ when $a_k = 1$ . Thus the children of $[a_0; a_1, \\dots, a_k, 1]$ are $[a_0; a_1, \\dots, a_k+1, 1]$ and $[a_0; a_1, \\dots, a_k, 1, 1]$ . Let's index the Stern-Brocot tree. The root vertex is assigned an index $1$ . Then for a vertex $v$ , the index of its left child is assigned by changing the leading bit of $v$ from $1$ to $10$ and for the right child, it's assigned by changing the leading bit from $1$ to $11$ : In this indexing, the continued fraction representation of a rational number specifies the run-length encoding of its binary index. For $\\frac{5}{2} = [2;2] = [2;1,1]$ , its index is $1011_2$ and its run-length encoding, considering bits in the ascending order, is $[2;1,1]$ . Another example is $\\frac{2}{5} = [0;2,2]=[0;2,1,1]$ , which has index $1100_2$ and its run-length encoding is, indeed, $[0;2,2]$ . It is worth noting that the Stern-Brocot tree is, in fact, a treap . That is, it is a binary search tree by $\\frac{p}{q}$ , but it is a heap by both $p$ and $q$ . Comparing continued fractions You're given $A=[a_0; a_1, \\dots, a_n]$ and $B=[b_0; b_1, \\dots, b_m]$ . Which fraction is smaller? Solution Assume for now that $A$ and $B$ are irrational and their continued fraction representations denote an infinite descent in the Stern-Brocot tree. As we already mentioned, in this representation $a_0$ denotes the number of right turns in the descent, $a_1$ denotes the number of consequent left turns and so on. Therefore, when we compare $a_k$ and $b_k$ , if $a_k = b_k$ we should just move on to comparing $a_{k+1}$ and $b_{k+1}$ . Otherwise, if we're at right descents, we should check if $a_k < b_k$ and if we're at left descents, we should check if $a_k > b_k$ to tell whether $A < B$ . In other words, for irrational $A$ and $B$ it would be $A < B$ if and only if $(a_0, -a_1, a_2, -a_3, \\dots) < (b_0, -b_1, b_2, -b_3, \\dots)$ with lexicographical comparison. Now, formally using $\\infty$ as an element of continued fraction representation it is possible to emulate irrational numbers $A-\\varepsilon$ and $A+\\varepsilon$ , that is, elements that are smaller (greater) than $A$ , but greater (smaller) than any other real number. Specifically, for $A=[a_0; a_1, \\dots, a_n]$ , one of these two elements can be emulated as $[a_0; a_1, \\dots, a_n, \\infty]$ and the other can be emulated as $[a_0; a_1, \\dots, a_n - 1, 1, \\infty]$ . Which one corresponds to $A-\\varepsilon$ and which one to $A+\\varepsilon$ can be determined by the parity of $n$ or by comparing them as irrational numbers. Python # check if a < b assuming that a[-1] = b[-1] = infty and a != b def less ( a , b ): a = [( - 1 ) ** i * a [ i ] for i in range ( len ( a ))] b = [( - 1 ) ** i * b [ i ] for i in range ( len ( b ))] return a < b # [a0; a1, ..., ak] -> [a0, a1, ..., ak-1, 1] def expand ( a ): if a : # empty a = inf a [ - 1 ] -= 1 a . append ( 1 ) return a # return a-eps, a+eps def pm_eps ( a ): b = expand ( a . copy ()) a . append ( float ( 'inf' )) b . append ( float ( 'inf' )) return ( a , b ) if less ( a , b ) else ( b , a ) Best inner point You're given $\\frac{0}{1} \\leq \\frac{p_0}{q_0} < \\frac{p_1}{q_1} \\leq \\frac{1}{0}$ . Find the rational number $\\frac{p}{q}$ such that $(q; p)$ is lexicographically smallest and $\\frac{p_0}{q_0} < \\frac{p}{q} < \\frac{p_1}{q_1}$ . Solution In terms of the Stern-Brocot tree it means that we need to find the LCA of $\\frac{p_0}{q_0}$ and $\\frac{p_1}{q_1}$ . Due to the connection between Stern-Brocot tree and continued fraction, this LCA would roughly correspond to the largest common prefix of continued fraction representations for $\\frac{p_0}{q_0}$ and $\\frac{p_1}{q_1}$ . So, if $\\frac{p_0}{q_0} = [a_0; a_1, \\dots, a_{k-1}, a_k, \\dots]$ and $\\frac{p_1}{q_1} = [a_0; a_1, \\dots, a_{k-1}, b_k, \\dots]$ are irrational numbers, the LCA is $[a_0; a_1, \\dots, \\min(a_k, b_k)+1]$ . For rational $r_0$ and $r_1$ , one of them could be the LCA itself which would require us to casework it. To simplify the solution for rational $r_0$ and $r_1$ , it is possible to use continued fraction representation of $r_0 + \\varepsilon$ and $r_1 - \\varepsilon$ which was derived in the previous problem. Python # finds lexicographically smallest (q, p) # such that p0/q0 < p/q < p1/q1 def middle ( p0 , q0 , p1 , q1 ): a0 = pm_eps ( fraction ( p0 , q0 ))[ 1 ] a1 = pm_eps ( fraction ( p1 , q1 ))[ 0 ] a = [] for i in range ( min ( len ( a0 ), len ( a1 ))): a . append ( min ( a0 [ i ], a1 [ i ])) if a0 [ i ] != a1 [ i ]: break a [ - 1 ] += 1 p , q = convergents ( a ) return p [ - 1 ], q [ - 1 ] GCJ 2019, Round 2 - New Elements: Part 2 You're given $N$ positive integer pairs $(C_i, J_i)$ . You need to find a positive integer pair $(x, y)$ such that $C_i x + J_i y$ is a strictly increasing sequence. Among such pairs, find the lexicographically minimum one. Solution Rephrasing the statement, $A_i x + B_i y$ must be positive for all $i$ , where $A_i = C_i - C_{i-1}$ and $B_i = J_i - J_{i-1}$ . Among such equations we have four significant groups for $A_i x + B_i y > 0$ : $A_i, B_i > 0$ can be ignored since we're looking for $x, y > 0$ . $A_i, B_i \\leq 0$ would provide \"IMPOSSIBLE\" as an answer. $A_i > 0$ , $B_i \\leq 0$ . Such constraints are equivalent to $\\frac{y}{x} < \\frac{A_i}{-B_i}$ . $A_i \\leq 0$ , $B_i > 0$ . Such constraints are equivalent to $\\frac{y}{x} > \\frac{-A_i}{B_i}$ . Let $\\frac{p_0}{q_0}$ be the largest $\\frac{-A_i}{B_i}$ from the fourth group and $\\frac{p_1}{q_1}$ be the smallest $\\frac{A_i}{-B_i}$ from the third group. The problem is now, given $\\frac{p_0}{q_0} < \\frac{p_1}{q_1}$ , find a fraction $\\frac{p}{q}$ such that $(q;p)$ is lexicographically smallest and $\\frac{p_0}{q_0} < \\frac{p}{q} < \\frac{p_1}{q_1}$ . Python def solve (): n = int ( input ()) C = [ 0 ] * n J = [ 0 ] * n # p0/q0 < y/x < p1/q1 p0 , q0 = 0 , 1 p1 , q1 = 1 , 0 fail = False for i in range ( n ): C [ i ], J [ i ] = map ( int , input () . split ()) if i > 0 : A = C [ i ] - C [ i - 1 ] B = J [ i ] - J [ i - 1 ] if A <= 0 and B <= 0 : fail = True elif B > 0 and A < 0 : # y/x > (-A)/B if B > 0 if ( - A ) * q0 > p0 * B : p0 , q0 = - A , B elif B < 0 and A > 0 : # y/x < A/(-B) if B < 0 if A * q1 < p1 * ( - B ): p1 , q1 = A , - B if p0 * q1 >= p1 * q0 or fail : return 'IMPOSSIBLE' p , q = middle ( p0 , q0 , p1 , q1 ) return str ( q ) + ' ' + str ( p )","title":"Stern-Brocot tree"},{"location":"algebra/continued-fractions.html#calkin-wilf-tree","text":"A somewhat simpler way to organize continued fractions in a binary tree is the Calkin-Wilf tree . The tree generally looks like this: The image by Olli Niemitalo , Proz is licensed under CC0 1.0 In the root of the tree, the number $\\frac{1}{1}$ is located. Then, for the vertex with a number $\\frac{p}{q}$ , its children are $\\frac{p}{p+q}$ and $\\frac{p+q}{q}$ . Unlike the Stern-Brocot tree, the Calkin-Wilf tree is not a binary search tree, so it can't be used to perform rational binary search. In the Calkin-Wilf tree, the direct parent of a fraction $\\frac{p}{q}$ is $\\frac{p-q}{q}$ when $p>q$ and $\\frac{p}{q-p}$ otherwise. For the Stern-Brocot tree, we used the recurrence for convergents. To draw the connection between the continued fraction and the Calkin-Wilf tree, we should recall the recurrence for complete quotients. If $s_k = \\frac{p}{q}$ , then $s_{k+1} = \\frac{q}{p \\mod q} = \\frac{q}{p-\\lfloor p/q \\rfloor \\cdot q}$ . On the other hand, if we repeatedly go from $s_k = \\frac{p}{q}$ to its parent in the Calkin-Wilf tree when $p > q$ , we will end up in $\\frac{p \\mod q}{q} = \\frac{1}{s_{k+1}}$ . If we continue doing so, we will end up in $s_{k+2}$ , then $\\frac{1}{s_{k+3}}$ and so on. From this we can deduce that: When $a_0> 0$ , the direct parent of $[a_0; a_1, \\dots, a_k]$ in the Calkin-Wilf tree is $\\frac{p-q}{q}=[a_0 - 1; a_1, \\dots, a_k]$ . When $a_0 = 0$ and $a_1 > 1$ , its direct parent is $\\frac{p}{q-p} = [0; a_1 - 1, a_2, \\dots, a_k]$ . And when $a_0 = 0$ and $a_1 = 1$ , its direct parent is $\\frac{p}{q-p} = [a_2; a_3, \\dots, a_k]$ . Correspondingly, children of $\\frac{p}{q} = [a_0; a_1, \\dots, a_k]$ are $\\frac{p+q}{q}=1+\\frac{p}{q}$ , which is $[a_0+1; a_1, \\dots, a_k]$ , $\\frac{p}{p+q} = \\frac{1}{1+\\frac{q}{p}}$ , which is $[0, 1, a_0, a_1, \\dots, a_k]$ for $a_0 > 0$ and $[0, a_1+1, a_2, \\dots, a_k]$ for $a_0=0$ . Noteworthy, if we enumerate vertices of the Calkin-Wilf tree in the breadth-first search order (that is, the root has a number $1$ , and the children of the vertex $v$ have indices $2v$ and $2v+1$ correspondingly), the index of the rational number in the Calkin-Wilf tree would be the same as in the Stern-Brocot tree. Thus, numbers on the same levels of the Stern-Brocot tree and the Calkin-Wilf tree are the same, but their ordering differs through the bit-reversal permutation .","title":"Calkin-Wilf tree"},{"location":"algebra/continued-fractions.html#convergence","text":"For the number $r$ and its $k$ -th convergent $r_k=\\frac{p_k}{q_k}$ the following formula stands: $$r_k = a_0 + \\sum\\limits_{i=1}^k \\frac{(-1)^{i-1}}{q_i q_{i-1}}.$$ In particular, it means that $$r_k - r_{k-1} = \\frac{(-1)^{k-1}}{q_k q_{k-1}}$$ and $$p_k q_{k-1} - p_{k-1} q_k = (-1)^{k-1}.$$ From this we can conclude that $$\\left| r-\\frac{p_k}{q_k} \\right| \\leq \\frac{1}{q_{k+1}q_k} \\leq \\frac{1}{q_k^2}.$$ The latter inequality is due to the fact that $r_k$ and $r_{k+1}$ are generally located on different sides of $r$ , thus $$|r-r_k| = |r_k-r_{k+1}|-|r-r_{k+1}| \\leq |r_k - r_{k+1}|.$$ Detailed explanation To estimate $|r-r_k|$ , we start by estimating the difference between adjacent convergents. By definition, $$\\frac{p_k}{q_k} - \\frac{p_{k-1}}{q_{k-1}} = \\frac{p_k q_{k-1} - p_{k-1} q_k}{q_k q_{k-1}}.$$ Replacing $p_k$ and $q_k$ in the numerator with their recurrences, we get $$\\begin{align} p_k q_{k-1} - p_{k-1} q_k &= (a_k p_{k-1} + p_{k-2}) q_{k-1} - p_{k-1} (a_k q_{k-1} + q_{k-2}) \\\\&= p_{k-2} q_{k-1} - p_{k-1} q_{k-2},\\end{align}$$ thus the numerator of $r_k - r_{k-1}$ is always the negated numerator of $r_{k-1} - r_{k-2}$ . It, in turn, equals to $1$ for $$r_1 - r_0=\\left(a_0+\\frac{1}{a_1}\\right)-a_0=\\frac{1}{a_1},$$ thus $$r_k - r_{k-1} = \\frac{(-1)^{k-1}}{q_k q_{k-1}}.$$ This yields an alternative representation of $r_k$ as a partial sum of infinite series: $$r_k = (r_k - r_{k-1}) + \\dots + (r_1 - r_0) + r_0 = a_0 + \\sum\\limits_{i=1}^k \\frac{(-1)^{i-1}}{q_i q_{i-1}}.$$ From the recurrent relation it follows that $q_k$ monotonously increases at least as fast as Fibonacci numbers, thus $$r = \\lim\\limits_{k \\to \\infty} r_k = a_0 + \\sum\\limits_{i=1}^\\infty \\frac{(-1)^{i-1}}{q_i q_{i-1}}$$ is always well-defined, as the underlying series always converge. Noteworthy, the residual series $$r-r_k = \\sum\\limits_{i=k+1}^\\infty \\frac{(-1)^{i-1}}{q_i q_{i-1}}$$ has the same sign as $(-1)^k$ due to how fast $q_i q_{i-1}$ decreases. Hence even-indexed $r_k$ approach $r$ from below while odd-indexed $r_k$ approach it from above: Convergents of $r=\\phi = \\frac{1+\\sqrt{5}}{2}=[1;1,1,\\dots]$ and their distance from $r$ . From this picture we can see that $$|r-r_k| = |r_k - r_{k+1}| - |r-r_{k+1}| \\leq |r_k - r_{k+1}|,$$ thus the distance between $r$ and $r_k$ is never larger than the distance between $r_k$ and $r_{k+1}$ : $$\\left|r-\\frac{p_k}{q_k}\\right| \\leq \\frac{1}{q_k q_{k+1}} \\leq \\frac{1}{q_k^2}.$$ Extended Euclidean? You're given $A, B, C \\in \\mathbb Z$ . Find $x, y \\in \\mathbb Z$ such that $Ax + By = C$ . Solution Although this problem is typically solved with the extended Euclidean algorithm , there is a simple and straightforward solution with continued fractions. Let $\\frac{A}{B}=[a_0; a_1, \\dots, a_k]$ . It was proved above that $p_k q_{k-1} - p_{k-1} q_k = (-1)^{k-1}$ . Substituting $p_k$ and $q_k$ with $A$ and $B$ , we get $$Aq_{k-1} - Bp_{k-1} = (-1)^{k-1} g,$$ where $g = \\gcd(A, B)$ . If $C$ is divisible by $g$ , then the solution is $x = (-1)^{k-1}\\frac{C}{g} q_{k-1}$ and $y = (-1)^{k}\\frac{C}{g} p_{k-1}$ . Python # return (x, y) such that Ax+By=C # assumes that such (x, y) exists def dio ( A , B , C ): p , q = convergents ( fraction ( A , B )) C //= A // p [ - 1 ] # divide by gcd(A, B) t = ( - 1 ) if len ( p ) % 2 else 1 return t * C * q [ - 2 ], - t * C * p [ - 2 ]","title":"Convergence"},{"location":"algebra/continued-fractions.html#linear-fractional-transformations","text":"Another important concept for continued fractions are the so-called linear fractional transformations . Definition A linear fractional transformation is a function $f : \\mathbb R \\to \\mathbb R$ such that $f(x) = \\frac{ax+b}{cx+d}$ for some $a,b,c,d \\in \\mathbb R$ . A composition $(L_0 \\circ L_1)(x) = L_0(L_1(x))$ of linear fractional transforms $L_0(x)=\\frac{a_0 x + b_0}{c_0 x + d_0}$ and $L_1(x)=\\frac{a_1 x + b_1}{c_1 x + d_1}$ is itself a linear fractional transform: $$\\frac{a_0\\frac{a_1 x + b_1}{c_1 x + d_1} + b_0}{c_0 \\frac{a_1 x + b_1}{c_1 x + d_1} + d_0} = \\frac{a_0(a_1 x + b_1) + b_0 (c_1 x + d_1)}{c_0 (a_1 x + b_1) + d_0 (c_1 x + d_1)} = \\frac{(a_0 a_1 + b_0 c_1) x + (a_0 b_1 + b_0 d_1)}{(c_0 a_1 + d_0 c_1) x + (c_0 b_1 + d_0 d_1)}.$$ Inverse of a linear fractional transform, is also a linear fractional transform: $$y = \\frac{ax+b}{cx+d} \\iff y(cx+d) = ax + b \\iff x = -\\frac{dy-b}{cy-a}.$$ DMOPC '19 Contest 7 P4 - Bob and Continued Fractions You're given an array of positive integers $a_1, \\dots, a_n$ . You need to answer $m$ queries. Each query is to compute $[a_l; a_{l+1}, \\dots, a_r]$ . Solution We can solve this problem with the segment tree if we're able to concatenate continued fractions. It's generally true that $[a_0; a_1, \\dots, a_k, b_0, b_1, \\dots, b_k] = [a_0; a_1, \\dots, a_k, [b_1; b_2, \\dots, b_k]]$ . Let's denote $L_{k}(x) = [a_k; x] = a_k + \\frac{1}{x} = \\frac{a_k\\cdot x+1}{1\\cdot x + 0}$ . Note that $L_k(\\infty) = a_k$ . In this notion, it holds that $$[a_0; a_1, \\dots, a_k, x] = [a_0; [a_1; [\\dots; [a_k; x]]]] = (L_0 \\circ L_1 \\circ \\dots \\circ L_k)(x) = \\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}.$$ Thus, the problem boils down to the computation of $$(L_l \\circ L_{l+1} \\circ \\dots \\circ L_r)(\\infty).$$ Composition of transforms is associative, so it's possible to compute in each node of a segment tree the composition of transforms in its subtree. Linear fractional transformation of a continued fraction Let $L(x) = \\frac{ax+b}{cx+d}$ . Compute the continued fraction representation $[b_0; b_1, \\dots, b_m]$ of $L(A)$ for $A=[a_0; a_1, \\dots, a_n]$ . This allows to compute $A + \\frac{p}{q} = \\frac{qA + p}{q}$ and $A \\cdot \\frac{p}{q} = \\frac{p A}{q}$ for any $\\frac{p}{q}$ . Solution As we noted above, $[a_0; a_1, \\dots, a_k] = (L_{a_0} \\circ L_{a_1} \\circ \\dots \\circ L_{a_k})(\\infty)$ , hence $L([a_0; a_1, \\dots, a_k]) = (L \\circ L_{a_0} \\circ L_{a_1} \\circ \\dots L_{a_k})(\\infty)$ . Hence, by consequentially adding $L_{a_0}$ , $L_{a_1}$ and so on we would be able to compute $$(L \\circ L_{a_0} \\circ \\dots \\circ L_{a_k})(x) = L\\left(\\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}\\right)=\\frac{a_k x + b_k}{c_k x + d_k}.$$ Since $L(x)$ is invertible, it is also monotonous in $x$ . Therefore, for any $x \\geq 0$ it holds that $L(\\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}})$ is between $L(\\frac{p_k}{q_k}) = \\frac{a_k}{c_k}$ and $L(\\frac{p_{k-1}}{q_{k-1}}) = \\frac{b_k}{d_k}$ . Moreover, for $x=[a_{k+1}; \\dots, a_n]$ it is equal to $L(A)$ . Hence, $b_0 = \\lfloor L(A) \\rfloor$ is between $\\lfloor L(\\frac{p_k}{q_k}) \\rfloor$ and $\\lfloor L(\\frac{p_{k-1}}{q_{k-1}}) \\rfloor$ . When they're equal, they're also equal to $b_0$ . Note that $L(A) = (L_{b_0} \\circ L_{b_1} \\circ \\dots \\circ L_{b_m})(\\infty)$ . Knowing $b_0$ , we can compose $L_{b_0}^{-1}$ with the current transform and continue adding $L_{a_{k+1}}$ , $L_{a_{k+2}}$ and so on, looking for new floors to agree, from which we would be able to deduce $b_1$ and so on until we recover all values of $[b_0; b_1, \\dots, b_m]$ . Continued fraction arithmetics Let $A=[a_0; a_1, \\dots, a_n]$ and $B=[b_0; b_1, \\dots, b_m]$ . Compute the continued fraction representations of $A+B$ and $A \\cdot B$ . Solution Idea here is similar to the previous problem, but instead of $L(x) = \\frac{ax+b}{cx+d}$ you should consider bilinear fractional transform $L(x, y) = \\frac{axy+bx+cy+d}{exy+fx+gy+h}$ . Rather than $L(x) \\mapsto L(L_{a_k}(x))$ you would change your current transform as $L(x, y) \\mapsto L(L_{a_k}(x), y)$ or $L(x, y) \\mapsto L(x, L_{b_k}(y))$ . Then, you check if $\\lfloor \\frac{a}{e} \\rfloor = \\lfloor \\frac{b}{f} \\rfloor = \\lfloor \\frac{c}{g} \\rfloor = \\lfloor \\frac{d}{h} \\rfloor$ and if they all agree, you use this value as $c_k$ in the resulting fraction and change the transform as $$L(x, y) \\mapsto \\frac{1}{L(x, y) - c_k}.$$ Definition A continued fraction $x = [a_0; a_1, \\dots]$ is said to be periodic if $x = [a_0; a_1, \\dots, a_k, x]$ for some $k$ . A continued fraction $x = [a_0; a_1, \\dots]$ is said to be eventually periodic if $x = [a_0; a_1, \\dots, a_k, y]$ , where $y$ is periodic. For $x = [1; 1, 1, \\dots]$ it holds that $x = 1 + \\frac{1}{x}$ , thus $x^2 = x + 1$ . There is a generic connection between periodic continued fractions and quadratic equations. Consider the following equation: $$ x = [a_0; a_1, \\dots, a_k, x].$$ On one hand, this equation means that the continued fraction representation of $x$ is periodic with the period $k+1$ . On the other hand, using the formula for convergents, this equation means that $$x = \\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}.$$ That is, $x$ is a linear fractional transformation of itself. It follows from the equation that $x$ is a root of the second degree equation: $$q_k x^2 + (q_{k-1}-p_k)x - p_{k-1} = 0.$$ Similar reasoning stands for continued fractions that are eventually periodic, that is $x = [a_0; a_1, \\dots, a_k, y]$ for $y=[b_0; b_1, \\dots, b_k, y]$ . Indeed, from first equation we derive that $x = L_0(y)$ and from second equation that $y = L_1(y)$ , where $L_0$ and $L_1$ are linear fractional transformations. Therefore, $$x = (L_0 \\circ L_1)(y) = (L_0 \\circ L_1 \\circ L_0^{-1})(x).$$ One can further prove (and it was first done by Lagrange) that for arbitrary quadratic equation $ax^2+bx+c=0$ with integer coefficients, its solution $x$ is an eventually periodic continued fraction. Quadratic irrationality Find the continued fraction of $\\alpha = \\frac{x+y\\sqrt{n}}{z}$ where $x, y, z, n \\in \\mathbb Z$ and $n > 0$ is not a perfect square. Solution For the $k$ -th complete quotient $s_k$ of the number it generally holds that $$\\alpha = [a_0; a_1, \\dots, a_{k-1}, s_k] = \\frac{s_k p_{k-1} + p_{k-2}}{s_k q_{k-1} + q_{k-2}}.$$ Therefore, $$s_k = -\\frac{\\alpha q_{k-1} - p_{k-1}}{\\alpha q_k - p_k} = -\\frac{q_{k-1} y \\sqrt n + (x q_{k-1} - z p_{k-1})}{q_k y \\sqrt n + (xq_k-zp_k)}.$$ Multiplying the numerator and denominator by $(xq_k - zp_k) - q_k y \\sqrt n$ , we'll get rid of $\\sqrt n$ in the denominator, thus the complete quotients are of form $$s_k = \\frac{x_k + y_k \\sqrt n}{z_k}.$$ Let's find $s_{k+1}$ , assuming that $s_k$ is known. First of all, $a_k = \\lfloor s_k \\rfloor = \\left\\lfloor \\frac{x_k + y_k \\lfloor \\sqrt n \\rfloor}{z_k} \\right\\rfloor$ . Then, $$s_{k+1} = \\frac{1}{s_k-a_k} = \\frac{z_k}{(x_k - z_k a_k) + y_k \\sqrt n} = \\frac{z_k (x_k - y_k a_k) - y_k z_k \\sqrt n}{(x_k - y_k a_k)^2 - y_k^2 n}.$$ Thus, if we denote $t_k = x_k - y_k a_k$ , it will hold that $$\\begin{align}x_{k+1} &=& z_k t_k, \\\\ y_{k+1} &=& -y_k z_k, \\\\ z_{k+1} &=& t_k^2 - y_k^2 n.\\end{align}$$ Nice thing about such representation is that if we reduce $x_{k+1}, y_{k+1}, z_{k+1}$ by their greatest common divisor, the result would be unique. Therefore, we may use it to check whether the current state has already been repeated and also to check where was the previous index that had this state. Below is the code to compute the continued fraction representation for $\\alpha = \\sqrt n$ : Python # compute the continued fraction of sqrt(n) def sqrt ( n ): n0 = math . floor ( math . sqrt ( n )) x , y , z = 1 , 0 , 1 a = [] def step ( x , y , z ): a . append (( x * n0 + y ) // z ) t = y - a [ - 1 ] * z x , y , z = - z * x , z * t , t ** 2 - n * x ** 2 g = math . gcd ( x , math . gcd ( y , z )) return x // g , y // g , z // g used = dict () for i in range ( n ): used [ x , y , z ] = i x , y , z = step ( x , y , z ) if ( x , y , z ) in used : return a Using the same step function but different initial $x$ , $y$ and $z$ it is possible to compute it for arbitrary $\\frac{x+y \\sqrt{n}}{z}$ . Tavrida NU Akai Contest - Continued Fraction You're given $x$ and $k$ , $x$ is not a perfect square. Let $\\sqrt x = [a_0; a_1, \\dots]$ , find $\\frac{p_k}{q_k}=[a_0; a_1, \\dots, a_k]$ for $0 \\leq k \\leq 10^9$ . Solution After computing the period of $\\sqrt x$ , it is possible to compute $a_k$ using binary exponentiation on the linear fractional transformation induced by the continued fraction representation. To find the resulting transformation, you compress the period of size $T$ into a single transformation and repeat it $\\lfloor \\frac{k-1}{T}\\rfloor$ times, after which you manually combine it with the remaining transformations. Python x , k = map ( int , input () . split ()) mod = 10 ** 9 + 7 # compose (A[0]*x + A[1]) / (A[2]*x + A[3]) and (B[0]*x + B[1]) / (B[2]*x + B[3]) def combine ( A , B ): return [ t % mod for t in [ A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 2 ], A [ 0 ] * B [ 1 ] + A [ 1 ] * B [ 3 ], A [ 2 ] * B [ 0 ] + A [ 3 ] * B [ 2 ], A [ 2 ] * B [ 1 ] + A [ 3 ] * B [ 3 ]]] A = [ 1 , 0 , 0 , 1 ] # (x + 0) / (0*x + 1) = x a = sqrt ( x ) T = len ( a ) - 1 # period of a # apply ak + 1/x = (ak*x+1)/(1x+0) to (Ax + B) / (Cx + D) for i in reversed ( range ( 1 , len ( a ))): A = combine ([ a [ i ], 1 , 1 , 0 ], A ) def bpow ( A , n ): return [ 1 , 0 , 0 , 1 ] if not n else combine ( A , bpow ( A , n - 1 )) if n % 2 else bpow ( combine ( A , A ), n // 2 ) C = ( 0 , 1 , 0 , 0 ) # = 1 / 0 while k % T : i = k % T C = combine ([ a [ i ], 1 , 1 , 0 ], C ) k -= 1 C = combine ( bpow ( A , k // T ), C ) C = combine ([ a [ 0 ], 1 , 1 , 0 ], C ) print ( str ( C [ 1 ]) + '/' + str ( C [ 3 ]))","title":"Linear fractional transformations"},{"location":"algebra/continued-fractions.html#geometric-interpretation","text":"Let $\\vec r_k = (q_k;p_k)$ for the convergent $r_k = \\frac{p_k}{q_k}$ . Then, the following recurrence holds: $$\\vec r_k = a_k \\vec r_{k-1} + \\vec r_{k-2}.$$ Let $\\vec r = (1;r)$ . Then, each vector $(x;y)$ corresponds to the number that is equal to its slope coefficient $\\frac{y}{x}$ . With the notion of pseudoscalar product $(x_1;y_1) \\times (x_2;y_2) = x_1 y_2 - x_2 y_1$ , it can be shown (see the explanation below) that $$s_k = -\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r} = \\left|\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r}\\right|.$$ The last equation is due to the fact that $r_{k-1}$ and $r_{k-2}$ lie on the different sides of $r$ , thus pseudoscalar products of $\\vec r_{k-1}$ and $\\vec r_{k-2}$ with $\\vec r$ have distinct signs. With $a_k = \\lfloor s_k \\rfloor$ in mind, formula for $\\vec r_k$ now looks like $$\\vec r_k = \\vec r_{k-2} + \\left\\lfloor \\left| \\frac{\\vec r \\times \\vec r_{k-2}}{\\vec r \\times \\vec r_{k-1}}\\right|\\right\\rfloor \\vec r_{k-1}.$$ Note that $\\vec r_k \\times r = (q;p) \\times (1;r) = qr - p$ , thus $$a_k = \\left\\lfloor \\left| \\frac{q_{k-1}r-p_{k-1}}{q_{k-2}r-p_{k-2}} \\right| \\right\\rfloor.$$ Explanation As we have already noted, $a_k = \\lfloor s_k \\rfloor$ , where $s_k = [a_k; a_{k+1}, a_{k+2}, \\dots]$ . On the other hand, from the convergent recurrence we derive that $$r = [a_0; a_1, \\dots, a_{k-1}, s_k] = \\frac{s_k p_{k-1} + p_{k-2}}{s_k q_{k-1} + q_{k-2}}.$$ In vector form, it rewrites as $$\\vec r \\parallel s_k \\vec r_{k-1} + \\vec r_{k-2},$$ meaning that $\\vec r$ and $s_k \\vec r_{k-1} + \\vec r_{k-2}$ are collinear (that is, have the same slope coefficient). Taking the pseudoscalar product of both parts with $\\vec r$ , we get $$0 = s_k (\\vec r_{k-1} \\times \\vec r) + (\\vec r_{k-2} \\times \\vec r),$$ which yields the final formula $$s_k = -\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r}.$$ Nose stretching algorithm Each time you add $\\vec r_{k-1}$ to the vector $\\vec p$ , the value of $\\vec p \\times \\vec r$ is increased by $\\vec r_{k-1} \\times \\vec r$ . Thus, $a_k=\\lfloor s_k \\rfloor$ is the maximum integer number of $\\vec r_{k-1}$ vectors that can be added to $\\vec r_{k-2}$ without changing the sign of the cross product with $\\vec r$ . In other words, $a_k$ is the maximum integer number of times you can add $\\vec r_{k-1}$ to $\\vec r_{k-2}$ without crossing the line defined by $\\vec r$ : Convergents of $r=\\frac{7}{9}=[0;1,3,2]$ . Semiconvergents correspond to intermediate points between gray arrows. On the picture above, $\\vec r_2 = (4;3)$ is obtained by repeatedly adding $\\vec r_1 = (1;1)$ to $\\vec r_0 = (1;0)$ . When it is not possible to further add $\\vec r_1$ to $\\vec r_0$ without crossing the $y=rx$ line, we go to the other side and repeatedly add $\\vec r_2$ to $\\vec r_1$ to obtain $\\vec r_3 = (9;7)$ . This procedure generates exponentially longer vectors, that approach the line. For this property, the procedure of generating consequent convergent vectors was dubbed the nose stretching algorithm by Boris Delaunay. If we look on the triangle drawn on points $\\vec r_{k-2}$ , $\\vec r_{k}$ and $\\vec 0$ we will notice that its doubled area is $$|\\vec r_{k-2} \\times \\vec r_k| = |\\vec r_{k-2} \\times (\\vec r_{k-2} + a_k \\vec r_{k-1})| = a_k |\\vec r_{k-2} \\times \\vec r_{k-1}| = a_k.$$ Combined with the Pick's theorem , it means that there are no lattice points strictly inside the triangle and the only lattice points on its border are $\\vec 0$ and $\\vec r_{k-2} + t \\cdot \\vec r_{k-1}$ for all integer $t$ such that $0 \\leq t \\leq a_k$ . When joined for all possible $k$ it means that there are no integer points in the space between polygons formed by even-indexed and odd-indexed convergent vectors. This, in turn, means that $\\vec r_k$ with odd coefficients form a convex hull of lattice points with $x \\geq 0$ above the line $y=rx$ , while $\\vec r_k$ with even coefficients form a convex hull of lattice points with $x > 0$ below the line $y=rx$ . Definition These polygons are also known as Klein polygons , named after Felix Klein who first suggested this geometric interpretation to the continued fractions.","title":"Geometric interpretation"},{"location":"algebra/continued-fractions.html#problem-examples","text":"Now that the most important facts and concepts were introduced, it is time to delve into specific problem examples. Convex hull under the line Find the convex hull of lattice points $(x;y)$ such that $0 \\leq x \\leq N$ and $0 \\leq y \\leq rx$ for $r=[a_0;a_1,\\dots,a_k]=\\frac{p_k}{q_k}$ . Solution If we were considering the unbounded set $0 \\leq x$ , the upper convex hull would be given by the line $y=rx$ itself. However, with additional constraint $x \\leq N$ we'd need to eventually deviate from the line to maintain proper convex hull. Let $t = \\lfloor \\frac{N}{q_k}\\rfloor$ , then first $t$ lattice points on the hull after $(0;0)$ are $\\alpha \\cdot (q_k; p_k)$ for integer $1 \\leq \\alpha \\leq t$ . However $(t+1)(q_k; p_k)$ can't be next lattice point since $(t+1)q_k$ is greater than $N$ . To get to the next lattice points in the hull, we should get to the point $(x;y)$ which diverges from $y=rx$ by the smallest margin, while maintaining $x \\leq N$ . Convex hull of lattice points under $y=\\frac{4}{7}x$ for $0 \\leq x \\leq 19$ consists of points $(0;0), (7;4), (14;8), (16;9), (18;10), (19;10)$ . Let $(x; y)$ be the last current point in the convex hull. Then the next point $(x'; y')$ is such that $x' \\leq N$ and $(x'; y') - (x; y) = (\\Delta x; \\Delta y)$ is as close to the line $y=rx$ as possible. In other words, $(\\Delta x; \\Delta y)$ maximizes $r \\Delta x - \\Delta y$ subject to $\\Delta x \\leq N - x$ and $\\Delta y \\leq r \\Delta x$ . Points like that lie on the convex hull of lattice points below $y=rx$ . In other words, $(\\Delta x; \\Delta y)$ must be a lower semiconvergent of $r$ . That being said, $(\\Delta x; \\Delta y)$ is of form $(q_{i-1}; p_{i-1}) + t \\cdot (q_i; p_i)$ for some odd number $i$ and $0 \\leq t < a_i$ . To find such $i$ , we can traverse all possible $i$ starting from the largest one and use $t = \\lfloor \\frac{N-x-q_{i-1}}{q_i} \\rfloor$ for $i$ such that $N-x-q_{i-1} \\geq 0$ . With $(\\Delta x; \\Delta y) = (q_{i-1}; p_{i-1}) + t \\cdot (q_i; p_i)$ , the condition $\\Delta y \\leq r \\Delta x$ would be preserved by semiconvergent properties. And $t < a_i$ would hold because we already exhausted semiconvergents obtained from $i+2$ , hence $x + q_{i-1} + a_i q_i = x+q_{i+1}$ is greater than $N$ . Now that we may add $(\\Delta x; \\Delta y)$ , to $(x;y)$ for $k = \\lfloor \\frac{N-x}{\\Delta x} \\rfloor$ times before we exceed $N$ , after which we would try the next semiconvergent. C++ Python // returns [ah, ph, qh] such that points r[i]=(ph[i], qh[i]) constitute upper convex hull // of lattice points on 0 <= x <= N and 0 <= y <= r * x, where r = [a0; a1, a2, ...] // and there are ah[i]-1 integer points on the segment between r[i] and r[i+1] auto hull ( auto a , int N ) { auto [ p , q ] = convergents ( a ); int t = N / q . back (); vector ah = { t }; vector ph = { 0 , t * p . back ()}; vector qh = { 0 , t * q . back ()}; for ( int i = q . size () - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) { while ( qh . back () + q [ i - 1 ] <= N ) { t = ( N - qh . back () - q [ i - 1 ]) / q [ i ]; int dp = p [ i - 1 ] + t * p [ i ]; int dq = q [ i - 1 ] + t * q [ i ]; int k = ( N - qh . back ()) / dq ; ah . push_back ( k ); ph . push_back ( ph . back () + k * dp ); qh . push_back ( qh . back () + k * dq ); } } } return make_tuple ( ah , ph , qh ); } # returns [ah, ph, qh] such that points r[i]=(ph[i], qh[i]) constitute upper convex hull # of lattice points on 0 <= x <= N and 0 <= y <= r * x, where r = [a0; a1, a2, ...] # and there are ah[i]-1 integer points on the segment between r[i] and r[i+1] def hull ( a , N ): p , q = convergents ( a ) t = N // q [ - 1 ] ah = [ t ] ph = [ 0 , t * p [ - 1 ]] qh = [ 0 , t * q [ - 1 ]] for i in reversed ( range ( len ( q ))): if i % 2 == 1 : while qh [ - 1 ] + q [ i - 1 ] <= N : t = ( N - qh [ - 1 ] - q [ i - 1 ]) // q [ i ] dp = p [ i - 1 ] + t * p [ i ] dq = q [ i - 1 ] + t * q [ i ] k = ( N - qh [ - 1 ]) // dq ah . append ( k ) ph . append ( ph [ - 1 ] + k * dp ) qh . append ( qh [ - 1 ] + k * dq ) return ah , ph , qh Timus - Crime and Punishment You're given integer numbers $A$ , $B$ and $N$ . Find $x \\geq 0$ and $y \\geq 0$ such that $Ax + By \\leq N$ and $Ax + By$ is the maximum possible. Solution In this problem it holds that $1 \\leq A, B, N \\leq 2 \\cdot 10^9$ , so it can be solved in $O(\\sqrt N)$ . However, there is $O(\\log N)$ solution with continued fractions. For our convenience, we will invert the direction of $x$ by doing a substitution $x \\mapsto \\lfloor \\frac{N}{A}\\rfloor - x$ , so that now we need to find the point $(x; y)$ such that $0 \\leq x \\leq \\lfloor \\frac{N}{A} \\rfloor$ , $By - Ax \\leq N \\;\\bmod\\; A$ and $By - Ax$ is the maximum possible. Optimal $y$ for each $x$ has a value of $\\lfloor \\frac{Ax + (N \\bmod A)}{B} \\rfloor$ . To treat it more generically, we will write a function that finds the best point on $0 \\leq x \\leq N$ and $y = \\lfloor \\frac{Ax+B}{C} \\rfloor$ . Core solution idea in this problem essentially repeats the previous problem, but instead of using lower semiconvergents to diverge from line, you use upper semiconvergents to get closer to the line without crossing it and without violating $x \\leq N$ . Unfortunately, unlike the previous problem, you need to make sure that you don't cross the $y=\\frac{Ax+B}{C}$ line while getting closer to it, so you should keep it in mind when calculating semiconvergent's coefficient $t$ . Python # (x, y) such that y = (A*x+B) // C, # Cy - Ax is max and 0 <= x <= N. def closest ( A , B , C , N ): # y <= (A*x + B)/C <=> diff(x, y) <= B def diff ( x , y ): return C * y - A * x a = fraction ( A , C ) p , q = convergents ( a ) ph = [ B // C ] qh = [ 0 ] for i in range ( 2 , len ( q ) - 1 ): if i % 2 == 0 : while diff ( qh [ - 1 ] + q [ i + 1 ], ph [ - 1 ] + p [ i + 1 ]) <= B : t = 1 + ( diff ( qh [ - 1 ] + q [ i - 1 ], ph [ - 1 ] + p [ i - 1 ]) - B - 1 ) // abs ( diff ( q [ i ], p [ i ])) dp = p [ i - 1 ] + t * p [ i ] dq = q [ i - 1 ] + t * q [ i ] k = ( N - qh [ - 1 ]) // dq if k == 0 : return qh [ - 1 ], ph [ - 1 ] if diff ( dq , dp ) != 0 : k = min ( k , ( B - diff ( qh [ - 1 ], ph [ - 1 ])) // diff ( dq , dp )) qh . append ( qh [ - 1 ] + k * dq ) ph . append ( ph [ - 1 ] + k * dp ) return qh [ - 1 ], ph [ - 1 ] def solve ( A , B , N ): x , y = closest ( A , N % A , B , N // A ) return N // A - x , y June Challenge 2017 - Euler Sum Compute $\\sum\\limits_{x=1}^N \\lfloor ex \\rfloor$ , where $e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, \\dots, 1, 2n, 1, \\dots]$ is the Euler's number and $N \\leq 10^{4000}$ . Solution This sum is equal to the number of lattice point $(x;y)$ such that $1 \\leq x \\leq N$ and $1 \\leq y \\leq ex$ . After constructing the convex hull of the points below $y=ex$ , this number can be computed using Pick's theorem : C++ Python // sum floor(k * x) for k in [1, N] and x = [a0; a1, a2, ...] int sum_floor ( auto a , int N ) { N ++ ; auto [ ah , ph , qh ] = hull ( a , N ); // The number of lattice points within a vertical right trapezoid // on points (0; 0) - (0; y1) - (dx; y2) - (dx; 0) that has // a+1 integer points on the segment (0; y1) - (dx; y2). auto picks = []( int y1 , int y2 , int dx , int a ) { int b = y1 + y2 + a + dx ; int A = ( y1 + y2 ) * dx ; return ( A - b + 2 ) / 2 + b - ( y2 + 1 ); }; int ans = 0 ; for ( size_t i = 1 ; i < qh . size (); i ++ ) { ans += picks ( ph [ i - 1 ], ph [ i ], qh [ i ] - qh [ i - 1 ], ah [ i - 1 ]); } return ans - N ; } # sum floor(k * x) for k in [1, N] and x = [a0; a1, a2, ...] def sum_floor ( a , N ): N += 1 ah , ph , qh = hull ( a , N ) # The number of lattice points within a vertical right trapezoid # on points (0; 0) - (0; y1) - (dx; y2) - (dx; 0) that has # a+1 integer points on the segment (0; y1) - (dx; y2). def picks ( y1 , y2 , dx , a ): b = y1 + y2 + a + dx A = ( y1 + y2 ) * dx return ( A - b + 2 ) // 2 + b - ( y2 + 1 ) ans = 0 for i in range ( 1 , len ( qh )): ans += picks ( ph [ i - 1 ], ph [ i ], qh [ i ] - qh [ i - 1 ], ah [ i - 1 ]) return ans - N NAIPC 2019 - It's a Mod, Mod, Mod, Mod World Given $p$ , $q$ and $n$ , compute $\\sum\\limits_{i=1}^n [p \\cdot i \\bmod q]$ . Solution This problem reduces to the previous one if you note that $a \\bmod b = a - \\lfloor \\frac{a}{b} \\rfloor b$ . With this fact, the sum reduces to $$\\sum\\limits_{i=1}^n \\left(p \\cdot i - \\left\\lfloor \\frac{p \\cdot i}{q} \\right\\rfloor q\\right) = \\frac{pn(n+1)}{2}-q\\sum\\limits_{i=1}^n \\left\\lfloor \\frac{p \\cdot i}{q}\\right\\rfloor.$$ However, summing up $\\lfloor rx \\rfloor$ for $x$ from $1$ to $N$ is something that we're capable of from the previous problem. C++ Python void solve ( int p , int q , int N ) { cout << p * N * ( N + 1 ) / 2 - q * sum_floor ( fraction ( p , q ), N ) << \" \\n \" ; } def solve ( p , q , N ): return p * N * ( N + 1 ) // 2 - q * sum_floor ( fraction ( p , q ), N ) Library Checker - Sum of Floor of Linear Given $N$ , $M$ , $A$ and $B$ , compute $\\sum\\limits_{i=0}^{N-1} \\lfloor \\frac{A \\cdot i + B}{M} \\rfloor$ . Solution This is the most technically troublesome problem so far. It is possible to use the same approach and construct the full convex hull of points below the line $y = \\frac{Ax+B}{M}$ . We already know how to solve it for $B = 0$ . Moreover, we already know how to construct this convex hull up to the closest lattice point to this line on $[0, N-1]$ segment (this is done in the \"Crime and Punishment\" problem above. Now we should note that once we reached the closest point to the line, we can just assume that the line in fact passes through the closest point, as there are no other lattice points on $[0, N-1]$ in between the actual line and the line moved slightly below to pass through the closest point. That being said, to construct the full convex hull below the line $y=\\frac{Ax+B}{M}$ on $[0, N-1]$ , we can construct it up to the closest point to the line on $[0, N-1]$ and then continue as if the line passes through this point, reusing algorithm for constructing convex hull with $B=0$ : Python # hull of lattice (x, y) such that C*y <= A*x+B def hull ( A , B , C , N ): def diff ( x , y ): return C * y - A * x a = fraction ( A , C ) p , q = convergents ( a ) ah = [] ph = [ B // C ] qh = [ 0 ] def insert ( dq , dp ): k = ( N - qh [ - 1 ]) // dq if diff ( dq , dp ) > 0 : k = min ( k , ( B - diff ( qh [ - 1 ], ph [ - 1 ])) // diff ( dq , dp )) ah . append ( k ) qh . append ( qh [ - 1 ] + k * dq ) ph . append ( ph [ - 1 ] + k * dp ) for i in range ( 1 , len ( q ) - 1 ): if i % 2 == 0 : while diff ( qh [ - 1 ] + q [ i + 1 ], ph [ - 1 ] + p [ i + 1 ]) <= B : t = ( B - diff ( qh [ - 1 ] + q [ i + 1 ], ph [ - 1 ] + p [ i + 1 ])) // abs ( diff ( q [ i ], p [ i ])) dp = p [ i + 1 ] - t * p [ i ] dq = q [ i + 1 ] - t * q [ i ] if dq < 0 or qh [ - 1 ] + dq > N : break insert ( dq , dp ) insert ( q [ - 1 ], p [ - 1 ]) for i in reversed ( range ( len ( q ))): if i % 2 == 1 : while qh [ - 1 ] + q [ i - 1 ] <= N : t = ( N - qh [ - 1 ] - q [ i - 1 ]) // q [ i ] dp = p [ i - 1 ] + t * p [ i ] dq = q [ i - 1 ] + t * q [ i ] insert ( dq , dp ) return ah , ph , qh OKC 2 - From Modular to Rational There is a rational number $\\frac{p}{q}$ such that $1 \\leq p, q \\leq 10^9$ . You may ask the value of $p q^{-1}$ modulo $m \\sim 10^9$ for several prime numbers $m$ . Recover $\\frac{p}{q}$ . Equivalent formulation: Find $x$ that delivers the minimum of $Ax \\;\\bmod\\; M$ for $1 \\leq x \\leq N$ . Solution Due to Chinese remainder theorem, asking the result modulo several prime numbers is the same as asking it modulo their product. Due to this, without loss of generality we'll assume that we know the remainder modulo sufficiently large number $m$ . There could be several possible solutions $(p, q)$ to $p \\equiv qr \\pmod m$ for a given remainder $r$ . However, if $(p_1, q_1)$ and $(p_2, q_2)$ are both the solutions then it also holds that $p_1 q_2 \\equiv p_2 q_1 \\pmod m$ . Assuming that $\\frac{p_1}{q_1} \\neq \\frac{p_2}{q_2}$ it means that $|p_1 q_2 - p_2 q_1|$ is at least $m$ . In the statement we were told that $1 \\leq p, q \\leq 10^9$ , so if both $p_1, q_1$ and $p_2, q_2$ are at most $10^9$ , then the difference is at most $10^{18}$ . For $m > 10^{18}$ it means that the solution $\\frac{p}{q}$ with $1 \\leq p, q \\leq 10^9$ is unique, as a rational number. So, the problem boils down, given $r$ modulo $m$ , to finding any $q$ such that $1 \\leq q \\leq 10^9$ and $qr \\;\\bmod\\; m \\leq 10^9$ . This is effectively the same as finding $q$ that delivers the minimum possible $qr \\bmod m$ for $1 \\leq q \\leq 10^9$ . For $qr = km + b$ it means that we need to find a pair $(q, m)$ such that $1 \\leq q \\leq 10^9$ and $qr - km \\geq 0$ is the minimum possible. Since $m$ is constant, we can divide by it and further restate it as find $q$ such that $1 \\leq q \\leq 10^9$ and $\\frac{r}{m} q - k \\geq 0$ is the minimum possible. In terms of continued fractions it means that $\\frac{k}{q}$ is the best diophantine approximation to $\\frac{r}{m}$ and it is sufficient to only check lower semiconvergents of $\\frac{r}{m}$ . Python # find Q that minimizes Q*r mod m for 1 <= k <= n < m def mod_min ( r , n , m ): a = fraction ( r , m ) p , q = convergents ( a ) for i in range ( 2 , len ( q )): if i % 2 == 1 and ( i + 1 == len ( q ) or q [ i + 1 ] > n ): t = ( n - q [ i - 1 ]) // q [ i ] return q [ i - 1 ] + t * q [ i ]","title":"Problem examples"},{"location":"algebra/continued-fractions.html#practice-problems","text":"UVa OJ - Continued Fractions ProjectEuler+ #64: Odd period square roots Codeforces Round #184 (Div. 2) - Continued Fractions Codeforces Round #201 (Div. 1) - Doodle Jump Codeforces Round #325 (Div. 1) - Alice, Bob, Oranges and Apples POJ Founder Monthly Contest 2008.03.16 - A Modular Arithmetic Challenge 2019 Multi-University Training Contest 5 - fraction SnackDown 2019 Elimination Round - Election Bait Code Jam 2019 round 2 - Continued Fraction","title":"Practice problems"},{"location":"algebra/discrete-log.html","text":"Discrete Logarithm \u00b6 The discrete logarithm is an integer $x$ satisfying the equation $$a^x \\equiv b \\pmod m$$ for given integers $a$ , $b$ and $m$ . The discrete logarithm does not always exist, for instance there is no solution to $2^x \\equiv 3 \\pmod 7$ . There is no simple condition to determine if the discrete logarithm exists. In this article, we describe the Baby-step giant-step algorithm, an algorithm to compute the discrete logarithm proposed by Shanks in 1971, which has the time complexity $O(\\sqrt{m})$ . This is a meet-in-the-middle algorithm because it uses the technique of separating tasks in half. Algorithm \u00b6 Consider the equation: $$a^x \\equiv b \\pmod m,$$ where $a$ and $m$ are relatively prime. Let $x = np - q$ , where $n$ is some pre-selected constant (we will describe how to select $n$ later). $p$ is known as giant step , since increasing it by one increases $x$ by $n$ . Similarly, $q$ is known as baby step . Obviously, any number $x$ in the interval $[0; m)$ can be represented in this form, where $p \\in [1; \\lceil \\frac{m}{n} \\rceil ]$ and $q \\in [0; n]$ . Then, the equation becomes: $$a^{np - q} \\equiv b \\pmod m.$$ Using the fact that $a$ and $m$ are relatively prime, we obtain: $$a^{np} \\equiv ba^q \\pmod m$$ This new equation can be rewritten in a simplified form: $$f_1(p) = f_2(q).$$ This problem can be solved using the meet-in-the-middle method as follows: Calculate $f_1$ for all possible arguments $p$ . Sort the array of value-argument pairs. For all possible arguments $q$ , calculate $f_2$ and look for the corresponding $p$ in the sorted array using binary search. Complexity \u00b6 We can calculate $f_1(p)$ in $O(\\log m)$ using the binary exponentiation algorithm . Similarly for $f_2(q)$ . In the first step of the algorithm, we need to calculate $f_1$ for every possible argument $p$ and then sort the values. Thus, this step has complexity: $$O\\left(\\left\\lceil \\frac{m}{n} \\right\\rceil \\left(\\log m + \\log \\left\\lceil \\frac{m}{n} \\right\\rceil \\right)\\right) = O\\left( \\left\\lceil \\frac {m}{n} \\right\\rceil \\log m\\right)$$ In the second step of the algorithm, we need to calculate $f_2(q)$ for every possible argument $q$ and then do a binary search on the array of values of $f_1$ , thus this step has complexity: $$O\\left(n \\left(\\log m + \\log \\frac{m}{n} \\right) \\right) = O\\left(n \\log m\\right).$$ Now, when we add these two complexities, we get $\\log m$ multiplied by the sum of $n$ and $m/n$ , which is minimal when $n = m/n$ , which means, to achieve optimal performance, $n$ should be chosen such that: $$n = \\sqrt{m}.$$ Then, the complexity of the algorithm becomes: $$O(\\sqrt {m} \\log m).$$ Implementation \u00b6 The simplest implementation \u00b6 In the following code, the function powmod calculates $a^b \\pmod m$ and the function solve produces a proper solution to the problem. It returns $-1$ if there is no solution and returns one of the possible solutions otherwise. int powmod ( int a , int b , int m ) { int res = 1 ; while ( b > 0 ) { if ( b & 1 ) { res = ( res * 1l l * a ) % m ; } a = ( a * 1l l * a ) % m ; b >>= 1 ; } return res ; } int solve ( int a , int b , int m ) { a %= m , b %= m ; int n = sqrt ( m ) + 1 ; map < int , int > vals ; for ( int p = 1 ; p <= n ; ++ p ) vals [ powmod ( a , p * n , m )] = p ; for ( int q = 0 ; q <= n ; ++ q ) { int cur = ( powmod ( a , q , m ) * 1l l * b ) % m ; if ( vals . count ( cur )) { int ans = vals [ cur ] * n - q ; return ans ; } } return -1 ; } In this code, we used map from the C++ standard library to store the values of $f_1$ . Internally, map uses a red-black tree to store values. Thus this code is a little bit slower than if we had used an array and binary searched, but is much easier to write. Notice that our code assumes $0^0 = 1$ , i.e. the code will compute $0$ as solution for the equation $0^x \\equiv 1 \\pmod m$ and also as solution for $0^x \\equiv 0 \\pmod 1$ . This is an often used convention in algebra, but it's also not universally accepted in all areas. Sometimes $0^0$ is simply undefined. If you don't like our convention, then you need to handle the case $a=0$ separately: if ( a == 0 ) return b == 0 ? 1 : -1 ; Another thing to note is that, if there are multiple arguments $p$ that map to the same value of $f_1$ , we only store one such argument. This works in this case because we only want to return one possible solution. If we need to return all possible solutions, we need to change map<int, int> to, say, map<int, vector<int>> . We also need to change the second step accordingly. Improved implementation \u00b6 A possible improvement is to get rid of binary exponentiation. This can be done by keeping a variable that is multiplied by $a$ each time we increase $q$ and a variable that is multiplied by $a^n$ each time we increase $p$ . With this change, the complexity of the algorithm is still the same, but now the $\\log$ factor is only for the map . Instead of a map , we can also use a hash table ( unordered_map in C++) which has the average time complexity $O(1)$ for inserting and searching. Problems often ask for the minimum $x$ which satisfies the solution. It is possible to get all answers and take the minimum, or reduce the first found answer using Euler's theorem , but we can be smart about the order in which we calculate values and ensure the first answer we find is the minimum. // Returns minimum x for which a ^ x % m = b % m, a and m are coprime. int solve ( int a , int b , int m ) { a %= m , b %= m ; int n = sqrt ( m ) + 1 ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * 1l l * a ) % m ; unordered_map < int , int > vals ; for ( int q = 0 , cur = b ; q <= n ; ++ q ) { vals [ cur ] = q ; cur = ( cur * 1l l * a ) % m ; } for ( int p = 1 , cur = 1 ; p <= n ; ++ p ) { cur = ( cur * 1l l * an ) % m ; if ( vals . count ( cur )) { int ans = n * p - vals [ cur ]; return ans ; } } return -1 ; } The complexity is $O(\\sqrt{m})$ using unordered_map . When $a$ and $m$ are not coprime \u00b6 Let $g = \\gcd(a, m)$ , and $g > 1$ . Clearly $a^x \\bmod m$ for every $x \\ge 1$ will be divisible by $g$ . If $g \\nmid b$ , there is no solution for $x$ . If $g \\mid b$ , let $a = g \\alpha, b = g \\beta, m = g \\nu$ . $$ \\begin{aligned} a^x & \\equiv b \\mod m \\\\\\ (g \\alpha) a^{x - 1} & \\equiv g \\beta \\mod g \\nu \\\\\\ \\alpha a^{x-1} & \\equiv \\beta \\mod \\nu \\end{aligned} $$ The baby-step giant-step algorithm can be easily extended to solve $ka^{x} \\equiv b \\pmod m$ for $x$ . // Returns minimum x for which a ^ x % m = b % m. int solve ( int a , int b , int m ) { a %= m , b %= m ; int k = 1 , add = 0 , g ; while (( g = gcd ( a , m )) > 1 ) { if ( b == k ) return add ; if ( b % g ) return -1 ; b /= g , m /= g , ++ add ; k = ( k * 1l l * a / g ) % m ; } int n = sqrt ( m ) + 1 ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * 1l l * a ) % m ; unordered_map < int , int > vals ; for ( int q = 0 , cur = b ; q <= n ; ++ q ) { vals [ cur ] = q ; cur = ( cur * 1l l * a ) % m ; } for ( int p = 1 , cur = k ; p <= n ; ++ p ) { cur = ( cur * 1l l * an ) % m ; if ( vals . count ( cur )) { int ans = n * p - vals [ cur ] + add ; return ans ; } } return -1 ; } The time complexity remains $O(\\sqrt{m})$ as before since the initial reduction to coprime $a$ and $m$ is done in $O(\\log^2 m)$ . Practice Problems \u00b6 Spoj - Power Modulo Inverted Topcoder - SplittingFoxes3 CodeChef - Inverse of a Function Hard Equation (assume that $0^0$ is undefined) CodeChef - Chef and Modular Sequence References \u00b6 Wikipedia - Baby-step giant-step Answer by Zander on Mathematics StackExchange","title":"Discrete Log"},{"location":"algebra/discrete-log.html#discrete-logarithm","text":"The discrete logarithm is an integer $x$ satisfying the equation $$a^x \\equiv b \\pmod m$$ for given integers $a$ , $b$ and $m$ . The discrete logarithm does not always exist, for instance there is no solution to $2^x \\equiv 3 \\pmod 7$ . There is no simple condition to determine if the discrete logarithm exists. In this article, we describe the Baby-step giant-step algorithm, an algorithm to compute the discrete logarithm proposed by Shanks in 1971, which has the time complexity $O(\\sqrt{m})$ . This is a meet-in-the-middle algorithm because it uses the technique of separating tasks in half.","title":"Discrete Logarithm"},{"location":"algebra/discrete-log.html#algorithm","text":"Consider the equation: $$a^x \\equiv b \\pmod m,$$ where $a$ and $m$ are relatively prime. Let $x = np - q$ , where $n$ is some pre-selected constant (we will describe how to select $n$ later). $p$ is known as giant step , since increasing it by one increases $x$ by $n$ . Similarly, $q$ is known as baby step . Obviously, any number $x$ in the interval $[0; m)$ can be represented in this form, where $p \\in [1; \\lceil \\frac{m}{n} \\rceil ]$ and $q \\in [0; n]$ . Then, the equation becomes: $$a^{np - q} \\equiv b \\pmod m.$$ Using the fact that $a$ and $m$ are relatively prime, we obtain: $$a^{np} \\equiv ba^q \\pmod m$$ This new equation can be rewritten in a simplified form: $$f_1(p) = f_2(q).$$ This problem can be solved using the meet-in-the-middle method as follows: Calculate $f_1$ for all possible arguments $p$ . Sort the array of value-argument pairs. For all possible arguments $q$ , calculate $f_2$ and look for the corresponding $p$ in the sorted array using binary search.","title":"Algorithm"},{"location":"algebra/discrete-log.html#complexity","text":"We can calculate $f_1(p)$ in $O(\\log m)$ using the binary exponentiation algorithm . Similarly for $f_2(q)$ . In the first step of the algorithm, we need to calculate $f_1$ for every possible argument $p$ and then sort the values. Thus, this step has complexity: $$O\\left(\\left\\lceil \\frac{m}{n} \\right\\rceil \\left(\\log m + \\log \\left\\lceil \\frac{m}{n} \\right\\rceil \\right)\\right) = O\\left( \\left\\lceil \\frac {m}{n} \\right\\rceil \\log m\\right)$$ In the second step of the algorithm, we need to calculate $f_2(q)$ for every possible argument $q$ and then do a binary search on the array of values of $f_1$ , thus this step has complexity: $$O\\left(n \\left(\\log m + \\log \\frac{m}{n} \\right) \\right) = O\\left(n \\log m\\right).$$ Now, when we add these two complexities, we get $\\log m$ multiplied by the sum of $n$ and $m/n$ , which is minimal when $n = m/n$ , which means, to achieve optimal performance, $n$ should be chosen such that: $$n = \\sqrt{m}.$$ Then, the complexity of the algorithm becomes: $$O(\\sqrt {m} \\log m).$$","title":"Complexity"},{"location":"algebra/discrete-log.html#implementation","text":"","title":"Implementation"},{"location":"algebra/discrete-log.html#the-simplest-implementation","text":"In the following code, the function powmod calculates $a^b \\pmod m$ and the function solve produces a proper solution to the problem. It returns $-1$ if there is no solution and returns one of the possible solutions otherwise. int powmod ( int a , int b , int m ) { int res = 1 ; while ( b > 0 ) { if ( b & 1 ) { res = ( res * 1l l * a ) % m ; } a = ( a * 1l l * a ) % m ; b >>= 1 ; } return res ; } int solve ( int a , int b , int m ) { a %= m , b %= m ; int n = sqrt ( m ) + 1 ; map < int , int > vals ; for ( int p = 1 ; p <= n ; ++ p ) vals [ powmod ( a , p * n , m )] = p ; for ( int q = 0 ; q <= n ; ++ q ) { int cur = ( powmod ( a , q , m ) * 1l l * b ) % m ; if ( vals . count ( cur )) { int ans = vals [ cur ] * n - q ; return ans ; } } return -1 ; } In this code, we used map from the C++ standard library to store the values of $f_1$ . Internally, map uses a red-black tree to store values. Thus this code is a little bit slower than if we had used an array and binary searched, but is much easier to write. Notice that our code assumes $0^0 = 1$ , i.e. the code will compute $0$ as solution for the equation $0^x \\equiv 1 \\pmod m$ and also as solution for $0^x \\equiv 0 \\pmod 1$ . This is an often used convention in algebra, but it's also not universally accepted in all areas. Sometimes $0^0$ is simply undefined. If you don't like our convention, then you need to handle the case $a=0$ separately: if ( a == 0 ) return b == 0 ? 1 : -1 ; Another thing to note is that, if there are multiple arguments $p$ that map to the same value of $f_1$ , we only store one such argument. This works in this case because we only want to return one possible solution. If we need to return all possible solutions, we need to change map<int, int> to, say, map<int, vector<int>> . We also need to change the second step accordingly.","title":"The simplest implementation"},{"location":"algebra/discrete-log.html#improved-implementation","text":"A possible improvement is to get rid of binary exponentiation. This can be done by keeping a variable that is multiplied by $a$ each time we increase $q$ and a variable that is multiplied by $a^n$ each time we increase $p$ . With this change, the complexity of the algorithm is still the same, but now the $\\log$ factor is only for the map . Instead of a map , we can also use a hash table ( unordered_map in C++) which has the average time complexity $O(1)$ for inserting and searching. Problems often ask for the minimum $x$ which satisfies the solution. It is possible to get all answers and take the minimum, or reduce the first found answer using Euler's theorem , but we can be smart about the order in which we calculate values and ensure the first answer we find is the minimum. // Returns minimum x for which a ^ x % m = b % m, a and m are coprime. int solve ( int a , int b , int m ) { a %= m , b %= m ; int n = sqrt ( m ) + 1 ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * 1l l * a ) % m ; unordered_map < int , int > vals ; for ( int q = 0 , cur = b ; q <= n ; ++ q ) { vals [ cur ] = q ; cur = ( cur * 1l l * a ) % m ; } for ( int p = 1 , cur = 1 ; p <= n ; ++ p ) { cur = ( cur * 1l l * an ) % m ; if ( vals . count ( cur )) { int ans = n * p - vals [ cur ]; return ans ; } } return -1 ; } The complexity is $O(\\sqrt{m})$ using unordered_map .","title":"Improved implementation"},{"location":"algebra/discrete-log.html#when-a-and-m-are-not-coprime","text":"Let $g = \\gcd(a, m)$ , and $g > 1$ . Clearly $a^x \\bmod m$ for every $x \\ge 1$ will be divisible by $g$ . If $g \\nmid b$ , there is no solution for $x$ . If $g \\mid b$ , let $a = g \\alpha, b = g \\beta, m = g \\nu$ . $$ \\begin{aligned} a^x & \\equiv b \\mod m \\\\\\ (g \\alpha) a^{x - 1} & \\equiv g \\beta \\mod g \\nu \\\\\\ \\alpha a^{x-1} & \\equiv \\beta \\mod \\nu \\end{aligned} $$ The baby-step giant-step algorithm can be easily extended to solve $ka^{x} \\equiv b \\pmod m$ for $x$ . // Returns minimum x for which a ^ x % m = b % m. int solve ( int a , int b , int m ) { a %= m , b %= m ; int k = 1 , add = 0 , g ; while (( g = gcd ( a , m )) > 1 ) { if ( b == k ) return add ; if ( b % g ) return -1 ; b /= g , m /= g , ++ add ; k = ( k * 1l l * a / g ) % m ; } int n = sqrt ( m ) + 1 ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * 1l l * a ) % m ; unordered_map < int , int > vals ; for ( int q = 0 , cur = b ; q <= n ; ++ q ) { vals [ cur ] = q ; cur = ( cur * 1l l * a ) % m ; } for ( int p = 1 , cur = k ; p <= n ; ++ p ) { cur = ( cur * 1l l * an ) % m ; if ( vals . count ( cur )) { int ans = n * p - vals [ cur ] + add ; return ans ; } } return -1 ; } The time complexity remains $O(\\sqrt{m})$ as before since the initial reduction to coprime $a$ and $m$ is done in $O(\\log^2 m)$ .","title":"When a and m are not coprime"},{"location":"algebra/discrete-log.html#practice-problems","text":"Spoj - Power Modulo Inverted Topcoder - SplittingFoxes3 CodeChef - Inverse of a Function Hard Equation (assume that $0^0$ is undefined) CodeChef - Chef and Modular Sequence","title":"Practice Problems"},{"location":"algebra/discrete-log.html#references","text":"Wikipedia - Baby-step giant-step Answer by Zander on Mathematics StackExchange","title":"References"},{"location":"algebra/discrete-root.html","text":"Discrete Root \u00b6 The problem of finding a discrete root is defined as follows. Given a prime $n$ and two integers $a$ and $k$ , find all $x$ for which: $x^k \\equiv a \\pmod n$ The algorithm \u00b6 We will solve this problem by reducing it to the discrete logarithm problem . Let's apply the concept of a primitive root modulo $n$ . Let $g$ be a primitive root modulo $n$ . Note that since $n$ is prime, it must exist, and it can be found in $O(Ans \\cdot \\log \\phi (n) \\cdot \\log n) = O(Ans \\cdot \\log^2 n)$ plus time of factoring $\\phi (n)$ . We can easily discard the case where $a = 0$ . In this case, obviously there is only one answer: $x = 0$ . Since we know that $n$ is a prime and any number between 1 and $n-1$ can be represented as a power of the primitive root, we can represent the discrete root problem as follows: $(g^y)^k \\equiv a \\pmod n$ where $x \\equiv g^y \\pmod n$ This, in turn, can be rewritten as $(g^k)^y \\equiv a \\pmod n$ Now we have one unknown $y$ , which is a discrete logarithm problem. The solution can be found using Shanks' baby-step giant-step algorithm in $O(\\sqrt {n} \\log n)$ (or we can verify that there are no solutions). Having found one solution $y_0$ , one of solutions of discrete root problem will be $x_0 = g^{y_0} \\pmod n$ . Finding all solutions from one known solution \u00b6 To solve the given problem in full, we need to find all solutions knowing one of them: $x_0 = g^{y_0} \\pmod n$ . Let's recall the fact that a primitive root always has order of $\\phi (n)$ , i.e. the smallest power of $g$ which gives 1 is $\\phi (n)$ . Therefore, if we add the term $\\phi (n)$ to the exponential, we still get the same value: $x^k \\equiv g^{ y_0 \\cdot k + l \\cdot \\phi (n)} \\equiv a \\pmod n \\forall l \\in Z$ Hence, all the solutions are of the form: $x = g^{y_0 + \\frac {l \\cdot \\phi (n)}{k}} \\pmod n \\forall l \\in Z$ . where $l$ is chosen such that the fraction must be an integer. For this to be true, the numerator has to be divisible by the least common multiple of $\\phi (n)$ and $k$ . Remember that least common multiple of two numbers $lcm(a, b) = \\frac{a \\cdot b}{gcd(a, b)}$ ; we'll get $x = g^{y_0 + i \\frac {\\phi (n)}{gcd(k, \\phi (n))}} \\pmod n \\forall i \\in Z$ . This is the final formula for all solutions of the discrete root problem. Implementation \u00b6 Here is a full implementation, including procedures for finding the primitive root, discrete log and finding and printing all solutions. int gcd ( int a , int b ) { return a ? gcd ( b % a , a ) : b ; } int powmod ( int a , int b , int p ) { int res = 1 ; while ( b > 0 ) { if ( b & 1 ) { res = res * a % p ; } a = a * a % p ; b >>= 1 ; } return res ; } // Finds the primitive root modulo p int generator ( int p ) { vector < int > fact ; int phi = p -1 , n = phi ; for ( int i = 2 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { fact . push_back ( i ); while ( n % i == 0 ) n /= i ; } } if ( n > 1 ) fact . push_back ( n ); for ( int res = 2 ; res <= p ; ++ res ) { bool ok = true ; for ( int factor : fact ) { if ( powmod ( res , phi / factor , p ) == 1 ) { ok = false ; break ; } } if ( ok ) return res ; } return -1 ; } // This program finds all numbers x such that x^k = a (mod n) int main () { int n , k , a ; scanf ( \"%d %d %d\" , & n , & k , & a ); if ( a == 0 ) { puts ( \"1 \\n 0\" ); return 0 ; } int g = generator ( n ); // Baby-step giant-step discrete logarithm algorithm int sq = ( int ) sqrt ( n + .0 ) + 1 ; vector < pair < int , int >> dec ( sq ); for ( int i = 1 ; i <= sq ; ++ i ) dec [ i -1 ] = { powmod ( g , i * sq * k % ( n - 1 ), n ), i }; sort ( dec . begin (), dec . end ()); int any_ans = -1 ; for ( int i = 0 ; i < sq ; ++ i ) { int my = powmod ( g , i * k % ( n - 1 ), n ) * a % n ; auto it = lower_bound ( dec . begin (), dec . end (), make_pair ( my , 0 )); if ( it != dec . end () && it -> first == my ) { any_ans = it -> second * sq - i ; break ; } } if ( any_ans == -1 ) { puts ( \"0\" ); return 0 ; } // Print all possible answers int delta = ( n -1 ) / gcd ( k , n -1 ); vector < int > ans ; for ( int cur = any_ans % delta ; cur < n -1 ; cur += delta ) ans . push_back ( powmod ( g , cur , n )); sort ( ans . begin (), ans . end ()); printf ( \"%d \\n \" , ans . size ()); for ( int answer : ans ) printf ( \"%d \" , answer ); } Practice problems \u00b6 Codeforces - Lunar New Year and a Recursive Sequence","title":"Discrete Root"},{"location":"algebra/discrete-root.html#discrete-root","text":"The problem of finding a discrete root is defined as follows. Given a prime $n$ and two integers $a$ and $k$ , find all $x$ for which: $x^k \\equiv a \\pmod n$","title":"Discrete Root"},{"location":"algebra/discrete-root.html#the-algorithm","text":"We will solve this problem by reducing it to the discrete logarithm problem . Let's apply the concept of a primitive root modulo $n$ . Let $g$ be a primitive root modulo $n$ . Note that since $n$ is prime, it must exist, and it can be found in $O(Ans \\cdot \\log \\phi (n) \\cdot \\log n) = O(Ans \\cdot \\log^2 n)$ plus time of factoring $\\phi (n)$ . We can easily discard the case where $a = 0$ . In this case, obviously there is only one answer: $x = 0$ . Since we know that $n$ is a prime and any number between 1 and $n-1$ can be represented as a power of the primitive root, we can represent the discrete root problem as follows: $(g^y)^k \\equiv a \\pmod n$ where $x \\equiv g^y \\pmod n$ This, in turn, can be rewritten as $(g^k)^y \\equiv a \\pmod n$ Now we have one unknown $y$ , which is a discrete logarithm problem. The solution can be found using Shanks' baby-step giant-step algorithm in $O(\\sqrt {n} \\log n)$ (or we can verify that there are no solutions). Having found one solution $y_0$ , one of solutions of discrete root problem will be $x_0 = g^{y_0} \\pmod n$ .","title":"The algorithm"},{"location":"algebra/discrete-root.html#finding-all-solutions-from-one-known-solution","text":"To solve the given problem in full, we need to find all solutions knowing one of them: $x_0 = g^{y_0} \\pmod n$ . Let's recall the fact that a primitive root always has order of $\\phi (n)$ , i.e. the smallest power of $g$ which gives 1 is $\\phi (n)$ . Therefore, if we add the term $\\phi (n)$ to the exponential, we still get the same value: $x^k \\equiv g^{ y_0 \\cdot k + l \\cdot \\phi (n)} \\equiv a \\pmod n \\forall l \\in Z$ Hence, all the solutions are of the form: $x = g^{y_0 + \\frac {l \\cdot \\phi (n)}{k}} \\pmod n \\forall l \\in Z$ . where $l$ is chosen such that the fraction must be an integer. For this to be true, the numerator has to be divisible by the least common multiple of $\\phi (n)$ and $k$ . Remember that least common multiple of two numbers $lcm(a, b) = \\frac{a \\cdot b}{gcd(a, b)}$ ; we'll get $x = g^{y_0 + i \\frac {\\phi (n)}{gcd(k, \\phi (n))}} \\pmod n \\forall i \\in Z$ . This is the final formula for all solutions of the discrete root problem.","title":"Finding all solutions from one known solution"},{"location":"algebra/discrete-root.html#implementation","text":"Here is a full implementation, including procedures for finding the primitive root, discrete log and finding and printing all solutions. int gcd ( int a , int b ) { return a ? gcd ( b % a , a ) : b ; } int powmod ( int a , int b , int p ) { int res = 1 ; while ( b > 0 ) { if ( b & 1 ) { res = res * a % p ; } a = a * a % p ; b >>= 1 ; } return res ; } // Finds the primitive root modulo p int generator ( int p ) { vector < int > fact ; int phi = p -1 , n = phi ; for ( int i = 2 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { fact . push_back ( i ); while ( n % i == 0 ) n /= i ; } } if ( n > 1 ) fact . push_back ( n ); for ( int res = 2 ; res <= p ; ++ res ) { bool ok = true ; for ( int factor : fact ) { if ( powmod ( res , phi / factor , p ) == 1 ) { ok = false ; break ; } } if ( ok ) return res ; } return -1 ; } // This program finds all numbers x such that x^k = a (mod n) int main () { int n , k , a ; scanf ( \"%d %d %d\" , & n , & k , & a ); if ( a == 0 ) { puts ( \"1 \\n 0\" ); return 0 ; } int g = generator ( n ); // Baby-step giant-step discrete logarithm algorithm int sq = ( int ) sqrt ( n + .0 ) + 1 ; vector < pair < int , int >> dec ( sq ); for ( int i = 1 ; i <= sq ; ++ i ) dec [ i -1 ] = { powmod ( g , i * sq * k % ( n - 1 ), n ), i }; sort ( dec . begin (), dec . end ()); int any_ans = -1 ; for ( int i = 0 ; i < sq ; ++ i ) { int my = powmod ( g , i * k % ( n - 1 ), n ) * a % n ; auto it = lower_bound ( dec . begin (), dec . end (), make_pair ( my , 0 )); if ( it != dec . end () && it -> first == my ) { any_ans = it -> second * sq - i ; break ; } } if ( any_ans == -1 ) { puts ( \"0\" ); return 0 ; } // Print all possible answers int delta = ( n -1 ) / gcd ( k , n -1 ); vector < int > ans ; for ( int cur = any_ans % delta ; cur < n -1 ; cur += delta ) ans . push_back ( powmod ( g , cur , n )); sort ( ans . begin (), ans . end ()); printf ( \"%d \\n \" , ans . size ()); for ( int answer : ans ) printf ( \"%d \" , answer ); }","title":"Implementation"},{"location":"algebra/discrete-root.html#practice-problems","text":"Codeforces - Lunar New Year and a Recursive Sequence","title":"Practice problems"},{"location":"algebra/divisors.html","text":"Number of divisors / sum of divisors \u00b6 In this article we discuss how to compute the number of divisors $d(n)$ and the sum of divisors $\\sigma(n)$ of a given number $n$ . Number of divisors \u00b6 It should be obvious that the prime factorization of a divisor $d$ has to be a subset of the prime factorization of $n$ , e.g. $6 = 2 \\cdot 3$ is a divisor of $60 = 2^2 \\cdot 3 \\cdot 5$ . So we only need to find all different subsets of the prime factorization of $n$ . Usually the number of subsets is $2^x$ for a set with $x$ elements. However this is no longer true, if there are repeated elements in the set. In our case some prime factors may appear multiple times in the prime factorization of $n$ . If a prime factor $p$ appears $e$ times in the prime factorization of $n$ , then we can use the factor $p$ up to $e$ times in the subset. Which means we have $e+1$ choices. Therefore if the prime factorization of $n$ is $p_1^{e_1} \\cdot p_2^{e_2} \\cdots p_k^{e_k}$ , where $p_i$ are distinct prime numbers, then the number of divisors is: $$d(n) = (e_1 + 1) \\cdot (e_2 + 1) \\cdots (e_k + 1)$$ A way of thinking about it is the following: If there is only one distinct prime divisor $n = p_1^{e_1}$ , then there are obviously $e_1 + 1$ divisors ( $1, p_1, p_1^2, \\dots, p_1^{e_1}$ ). If there are two distinct prime divisors $n = p_1^{e_1} \\cdot p_2^{e_2}$ , then you can arrange all divisors in form of a tabular. $$\\begin{array}{c|ccccc} & 1 & p_2 & p_2^2 & \\dots & p_2^{e_2} \\\\\\\\\\hline 1 & 1 & p_2 & p_2^2 & \\dots & p_2^{e_2} \\\\\\\\ p_1 & p_1 & p_1 \\cdot p_2 & p_1 \\cdot p_2^2 & \\dots & p_1 \\cdot p_2^{e_2} \\\\\\\\ p_1^2 & p_1^2 & p_1^2 \\cdot p_2 & p_1^2 \\cdot p_2^2 & \\dots & p_1^2 \\cdot p_2^{e_2} \\\\\\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\\\\ p_1^{e_1} & p_1^{e_1} & p_1^{e_1} \\cdot p_2 & p_1^{e_1} \\cdot p_2^2 & \\dots & p_1^{e_1} \\cdot p_2^{e_2} \\\\\\\\ \\end{array}$$ So the number of divisors is trivially $(e_1 + 1) \\cdot (e_2 + 1)$ . A similar argument can be made if there are more then two distinct prime factors. long long numberOfDivisors ( long long num ) { long long total = 1 ; for ( int i = 2 ; ( long long ) i * i <= num ; i ++ ) { if ( num % i == 0 ) { int e = 0 ; do { e ++ ; num /= i ; } while ( num % i == 0 ); total *= e + 1 ; } } if ( num > 1 ) { total *= 2 ; } return total ; } Sum of divisors \u00b6 We can use the same argument of the previous section. If there is only one distinct prime divisor $n = p_1^{e_1}$ , then the sum is: $$1 + p_1 + p_1^2 + \\dots + p_1^{e_1} = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1}$$ If there are two distinct prime divisors $n = p_1^{e_1} \\cdot p_2^{e_2}$ , then we can make the same table as before. The only difference is that now we now want to compute the sum instead of counting the elements. It is easy to see, that the sum of each combination can be expressed as: $$\\left(1 + p_1 + p_1^2 + \\dots + p_1^{e_1}\\right) \\cdot \\left(1 + p_2 + p_2^2 + \\dots + p_2^{e_2}\\right)$$ $$ = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1} \\cdot \\frac{p_2^{e_2 + 1} - 1}{p_2 - 1}$$ In general, for $n = p_1^{e_1} \\cdot p_2^{e_2} \\cdots p_k^{e_k}$ we receive the formula: $$\\sigma(n) = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1} \\cdot \\frac{p_2^{e_2 + 1} - 1}{p_2 - 1} \\cdots \\frac{p_k^{e_k + 1} - 1}{p_k - 1}$$ long long SumOfDivisors ( long long num ) { long long total = 1 ; for ( int i = 2 ; ( long long ) i * i <= num ; i ++ ) { if ( num % i == 0 ) { int e = 0 ; do { e ++ ; num /= i ; } while ( num % i == 0 ); long long sum = 0 , pow = 1 ; do { sum += pow ; pow *= i ; } while ( e -- > 0 ); total *= sum ; } } if ( num > 1 ) { total *= ( 1 + num ); } return total ; } Multiplicative functions \u00b6 A multiplicative function is a function $f(x)$ which satisfies $$f(a \\cdot b) = f(a) \\cdot f(b)$$ if $a$ and $b$ are coprime. Both $d(n)$ and $\\sigma(n)$ are multiplicative functions. Multiplicative functions have a huge variety of interesting properties, which can be very useful in number theory problems. For instance the Dirichlet convolution of two multiplicative functions is also multiplicative. Practice Problems \u00b6 SPOJ - COMDIV SPOJ - DIVSUM SPOJ - DIVSUM2","title":"Number of divisors / sum of divisors"},{"location":"algebra/divisors.html#number-of-divisors-sum-of-divisors","text":"In this article we discuss how to compute the number of divisors $d(n)$ and the sum of divisors $\\sigma(n)$ of a given number $n$ .","title":"Number of divisors / sum of divisors"},{"location":"algebra/divisors.html#number-of-divisors","text":"It should be obvious that the prime factorization of a divisor $d$ has to be a subset of the prime factorization of $n$ , e.g. $6 = 2 \\cdot 3$ is a divisor of $60 = 2^2 \\cdot 3 \\cdot 5$ . So we only need to find all different subsets of the prime factorization of $n$ . Usually the number of subsets is $2^x$ for a set with $x$ elements. However this is no longer true, if there are repeated elements in the set. In our case some prime factors may appear multiple times in the prime factorization of $n$ . If a prime factor $p$ appears $e$ times in the prime factorization of $n$ , then we can use the factor $p$ up to $e$ times in the subset. Which means we have $e+1$ choices. Therefore if the prime factorization of $n$ is $p_1^{e_1} \\cdot p_2^{e_2} \\cdots p_k^{e_k}$ , where $p_i$ are distinct prime numbers, then the number of divisors is: $$d(n) = (e_1 + 1) \\cdot (e_2 + 1) \\cdots (e_k + 1)$$ A way of thinking about it is the following: If there is only one distinct prime divisor $n = p_1^{e_1}$ , then there are obviously $e_1 + 1$ divisors ( $1, p_1, p_1^2, \\dots, p_1^{e_1}$ ). If there are two distinct prime divisors $n = p_1^{e_1} \\cdot p_2^{e_2}$ , then you can arrange all divisors in form of a tabular. $$\\begin{array}{c|ccccc} & 1 & p_2 & p_2^2 & \\dots & p_2^{e_2} \\\\\\\\\\hline 1 & 1 & p_2 & p_2^2 & \\dots & p_2^{e_2} \\\\\\\\ p_1 & p_1 & p_1 \\cdot p_2 & p_1 \\cdot p_2^2 & \\dots & p_1 \\cdot p_2^{e_2} \\\\\\\\ p_1^2 & p_1^2 & p_1^2 \\cdot p_2 & p_1^2 \\cdot p_2^2 & \\dots & p_1^2 \\cdot p_2^{e_2} \\\\\\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\\\\ p_1^{e_1} & p_1^{e_1} & p_1^{e_1} \\cdot p_2 & p_1^{e_1} \\cdot p_2^2 & \\dots & p_1^{e_1} \\cdot p_2^{e_2} \\\\\\\\ \\end{array}$$ So the number of divisors is trivially $(e_1 + 1) \\cdot (e_2 + 1)$ . A similar argument can be made if there are more then two distinct prime factors. long long numberOfDivisors ( long long num ) { long long total = 1 ; for ( int i = 2 ; ( long long ) i * i <= num ; i ++ ) { if ( num % i == 0 ) { int e = 0 ; do { e ++ ; num /= i ; } while ( num % i == 0 ); total *= e + 1 ; } } if ( num > 1 ) { total *= 2 ; } return total ; }","title":"Number of divisors"},{"location":"algebra/divisors.html#sum-of-divisors","text":"We can use the same argument of the previous section. If there is only one distinct prime divisor $n = p_1^{e_1}$ , then the sum is: $$1 + p_1 + p_1^2 + \\dots + p_1^{e_1} = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1}$$ If there are two distinct prime divisors $n = p_1^{e_1} \\cdot p_2^{e_2}$ , then we can make the same table as before. The only difference is that now we now want to compute the sum instead of counting the elements. It is easy to see, that the sum of each combination can be expressed as: $$\\left(1 + p_1 + p_1^2 + \\dots + p_1^{e_1}\\right) \\cdot \\left(1 + p_2 + p_2^2 + \\dots + p_2^{e_2}\\right)$$ $$ = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1} \\cdot \\frac{p_2^{e_2 + 1} - 1}{p_2 - 1}$$ In general, for $n = p_1^{e_1} \\cdot p_2^{e_2} \\cdots p_k^{e_k}$ we receive the formula: $$\\sigma(n) = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1} \\cdot \\frac{p_2^{e_2 + 1} - 1}{p_2 - 1} \\cdots \\frac{p_k^{e_k + 1} - 1}{p_k - 1}$$ long long SumOfDivisors ( long long num ) { long long total = 1 ; for ( int i = 2 ; ( long long ) i * i <= num ; i ++ ) { if ( num % i == 0 ) { int e = 0 ; do { e ++ ; num /= i ; } while ( num % i == 0 ); long long sum = 0 , pow = 1 ; do { sum += pow ; pow *= i ; } while ( e -- > 0 ); total *= sum ; } } if ( num > 1 ) { total *= ( 1 + num ); } return total ; }","title":"Sum of divisors"},{"location":"algebra/divisors.html#multiplicative-functions","text":"A multiplicative function is a function $f(x)$ which satisfies $$f(a \\cdot b) = f(a) \\cdot f(b)$$ if $a$ and $b$ are coprime. Both $d(n)$ and $\\sigma(n)$ are multiplicative functions. Multiplicative functions have a huge variety of interesting properties, which can be very useful in number theory problems. For instance the Dirichlet convolution of two multiplicative functions is also multiplicative.","title":"Multiplicative functions"},{"location":"algebra/divisors.html#practice-problems","text":"SPOJ - COMDIV SPOJ - DIVSUM SPOJ - DIVSUM2","title":"Practice Problems"},{"location":"algebra/euclid-algorithm.html","text":"Euclidean algorithm for computing the greatest common divisor \u00b6 Given two non-negative integers $a$ and $b$ , we have to find their GCD (greatest common divisor), i.e. the largest number which is a divisor of both $a$ and $b$ . It's commonly denoted by $\\gcd(a, b)$ . Mathematically it is defined as: $$\\gcd(a, b) = \\max \\{k > 0 : (k \\mid a) \\text{ and } (k \\mid b) \\}$$ (here the symbol \" $\\mid$ \" denotes divisibility, i.e. \" $k \\mid a$ \" means \" $k$ divides $a$ \") When one of the numbers is zero, while the other is non-zero, their greatest common divisor, by definition, is the second number. When both numbers are zero, their greatest common divisor is undefined (it can be any arbitrarily large number), but it is convenient to define it as zero as well to preserve the associativity of $\\gcd$ . Which gives us a simple rule: if one of the numbers is zero, the greatest common divisor is the other number. The Euclidean algorithm, discussed below, allows to find the greatest common divisor of two numbers $a$ and $b$ in $O(\\log \\min(a, b))$ . Since the function is associative , to find the GCD of more than two numbers , we can do $\\gcd(a, b, c) = \\gcd(a, \\gcd(b, c))$ and so forth. The algorithm was first described in Euclid's \"Elements\" (circa 300 BC), but it is possible that the algorithm has even earlier origins. Algorithm \u00b6 Originally, the Euclidean algorithm was formulated as follows: subtract the smaller number from the larger one until one of the numbers is zero. Indeed, if $g$ divides $a$ and $b$ , it also divides $a-b$ . On the other hand, if $g$ divides $a-b$ and $b$ , then it also divides $a = b + (a-b)$ , which means that the sets of the common divisors of $\\{a, b\\}$ and $\\{b,a-b\\}$ coincide. Note that $a$ remains the larger number until $b$ is subtracted from it at least $\\left\\lfloor\\frac{a}{b}\\right\\rfloor$ times. Therefore, to speed things up, $a-b$ is substituted with $a-\\left\\lfloor\\frac{a}{b}\\right\\rfloor b = a \\bmod b$ . Then the algorithm is formulated in an extremely simple way: $$\\gcd(a, b) = \\begin{cases}a,&\\text{if }b = 0 \\\\ \\gcd(b, a \\bmod b),&\\text{otherwise.}\\end{cases}$$ Implementation \u00b6 int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } Using the ternary operator in C++, we can write it as a one-liner. int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ; } And finally, here is a non-recursive implementation: int gcd ( int a , int b ) { while ( b ) { a %= b ; swap ( a , b ); } return a ; } Note that since C++17, gcd is implemented as a standard function in C++. Time Complexity \u00b6 The running time of the algorithm is estimated by Lam\u00e9's theorem, which establishes a surprising connection between the Euclidean algorithm and the Fibonacci sequence: If $a > b \\geq 1$ and $b < F_n$ for some $n$ , the Euclidean algorithm performs at most $n-2$ recursive calls. Moreover, it is possible to show that the upper bound of this theorem is optimal. When $a = F_n$ and $b = F_{n-1}$ , $gcd(a, b)$ will perform exactly $n-2$ recursive calls. In other words, consecutive Fibonacci numbers are the worst case input for Euclid's algorithm. Given that Fibonacci numbers grow exponentially, we get that the Euclidean algorithm works in $O(\\log \\min(a, b))$ . Another way to estimate the complexity is to notice that $a \\bmod b$ for the case $a \\geq b$ is at least $2$ times smaller than $a$ , so the larger number is reduced at least in half on each iteration of the algorithm. Applying this reasoning to the case when we compute the GCD of the set of numbers $a_1,\\dots,a_n \\leq C$ , this also allows us to estimate the total runtime as $O(n + \\log C)$ , rather than $O(n \\log C)$ , since every non-trivial iteration of the algorithm reduces the current GCD candidate by at least a factor of $2$ . Least common multiple \u00b6 Calculating the least common multiple (commonly denoted LCM ) can be reduced to calculating the GCD with the following simple formula: $$\\text{lcm}(a, b) = \\frac{a \\cdot b}{\\gcd(a, b)}$$ Thus, LCM can be calculated using the Euclidean algorithm with the same time complexity: A possible implementation, that cleverly avoids integer overflows by first dividing $a$ with the GCD, is given here: int lcm ( int a , int b ) { return a / gcd ( a , b ) * b ; } Binary GCD \u00b6 The Binary GCD algorithm is an optimization to the normal Euclidean algorithm. The slow part of the normal algorithm are the modulo operations. Modulo operations, although we see them as $O(1)$ , are a lot slower than simpler operations like addition, subtraction or bitwise operations. So it would be better to avoid those. It turns out, that you can design a fast GCD algorithm that avoids modulo operations. It's based on a few properties: If both numbers are even, then we can factor out a two of both and compute the GCD of the remaining numbers: $\\gcd(2a, 2b) = 2 \\gcd(a, b)$ . If one of the numbers is even and the other one is odd, then we can remove the factor 2 from the even one: $\\gcd(2a, b) = \\gcd(a, b)$ if $b$ is odd. If both numbers are odd, then subtracting one number of the other one will not change the GCD: $\\gcd(a, b) = \\gcd(b, a-b)$ Using only these properties, and some fast bitwise functions from GCC, we can implement a fast version: int gcd ( int a , int b ) { if ( ! a || ! b ) return a | b ; unsigned shift = __builtin_ctz ( a | b ); a >>= __builtin_ctz ( a ); do { b >>= __builtin_ctz ( b ); if ( a > b ) swap ( a , b ); b -= a ; } while ( b ); return a << shift ; } Notice, that such an optimization is usually not necessary, and most programming languages already have a GCD function in their standard libraries. E.g. C++17 has such a function std::gcd in the numeric header. Practice Problems \u00b6 CSAcademy - Greatest Common Divisor Codeforces 1916B - Two Divisors","title":"Euclidean algorithm for computing the greatest common divisor"},{"location":"algebra/euclid-algorithm.html#euclidean-algorithm-for-computing-the-greatest-common-divisor","text":"Given two non-negative integers $a$ and $b$ , we have to find their GCD (greatest common divisor), i.e. the largest number which is a divisor of both $a$ and $b$ . It's commonly denoted by $\\gcd(a, b)$ . Mathematically it is defined as: $$\\gcd(a, b) = \\max \\{k > 0 : (k \\mid a) \\text{ and } (k \\mid b) \\}$$ (here the symbol \" $\\mid$ \" denotes divisibility, i.e. \" $k \\mid a$ \" means \" $k$ divides $a$ \") When one of the numbers is zero, while the other is non-zero, their greatest common divisor, by definition, is the second number. When both numbers are zero, their greatest common divisor is undefined (it can be any arbitrarily large number), but it is convenient to define it as zero as well to preserve the associativity of $\\gcd$ . Which gives us a simple rule: if one of the numbers is zero, the greatest common divisor is the other number. The Euclidean algorithm, discussed below, allows to find the greatest common divisor of two numbers $a$ and $b$ in $O(\\log \\min(a, b))$ . Since the function is associative , to find the GCD of more than two numbers , we can do $\\gcd(a, b, c) = \\gcd(a, \\gcd(b, c))$ and so forth. The algorithm was first described in Euclid's \"Elements\" (circa 300 BC), but it is possible that the algorithm has even earlier origins.","title":"Euclidean algorithm for computing the greatest common divisor"},{"location":"algebra/euclid-algorithm.html#algorithm","text":"Originally, the Euclidean algorithm was formulated as follows: subtract the smaller number from the larger one until one of the numbers is zero. Indeed, if $g$ divides $a$ and $b$ , it also divides $a-b$ . On the other hand, if $g$ divides $a-b$ and $b$ , then it also divides $a = b + (a-b)$ , which means that the sets of the common divisors of $\\{a, b\\}$ and $\\{b,a-b\\}$ coincide. Note that $a$ remains the larger number until $b$ is subtracted from it at least $\\left\\lfloor\\frac{a}{b}\\right\\rfloor$ times. Therefore, to speed things up, $a-b$ is substituted with $a-\\left\\lfloor\\frac{a}{b}\\right\\rfloor b = a \\bmod b$ . Then the algorithm is formulated in an extremely simple way: $$\\gcd(a, b) = \\begin{cases}a,&\\text{if }b = 0 \\\\ \\gcd(b, a \\bmod b),&\\text{otherwise.}\\end{cases}$$","title":"Algorithm"},{"location":"algebra/euclid-algorithm.html#implementation","text":"int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } Using the ternary operator in C++, we can write it as a one-liner. int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ; } And finally, here is a non-recursive implementation: int gcd ( int a , int b ) { while ( b ) { a %= b ; swap ( a , b ); } return a ; } Note that since C++17, gcd is implemented as a standard function in C++.","title":"Implementation"},{"location":"algebra/euclid-algorithm.html#time-complexity","text":"The running time of the algorithm is estimated by Lam\u00e9's theorem, which establishes a surprising connection between the Euclidean algorithm and the Fibonacci sequence: If $a > b \\geq 1$ and $b < F_n$ for some $n$ , the Euclidean algorithm performs at most $n-2$ recursive calls. Moreover, it is possible to show that the upper bound of this theorem is optimal. When $a = F_n$ and $b = F_{n-1}$ , $gcd(a, b)$ will perform exactly $n-2$ recursive calls. In other words, consecutive Fibonacci numbers are the worst case input for Euclid's algorithm. Given that Fibonacci numbers grow exponentially, we get that the Euclidean algorithm works in $O(\\log \\min(a, b))$ . Another way to estimate the complexity is to notice that $a \\bmod b$ for the case $a \\geq b$ is at least $2$ times smaller than $a$ , so the larger number is reduced at least in half on each iteration of the algorithm. Applying this reasoning to the case when we compute the GCD of the set of numbers $a_1,\\dots,a_n \\leq C$ , this also allows us to estimate the total runtime as $O(n + \\log C)$ , rather than $O(n \\log C)$ , since every non-trivial iteration of the algorithm reduces the current GCD candidate by at least a factor of $2$ .","title":"Time Complexity"},{"location":"algebra/euclid-algorithm.html#least-common-multiple","text":"Calculating the least common multiple (commonly denoted LCM ) can be reduced to calculating the GCD with the following simple formula: $$\\text{lcm}(a, b) = \\frac{a \\cdot b}{\\gcd(a, b)}$$ Thus, LCM can be calculated using the Euclidean algorithm with the same time complexity: A possible implementation, that cleverly avoids integer overflows by first dividing $a$ with the GCD, is given here: int lcm ( int a , int b ) { return a / gcd ( a , b ) * b ; }","title":"Least common multiple"},{"location":"algebra/euclid-algorithm.html#binary-gcd","text":"The Binary GCD algorithm is an optimization to the normal Euclidean algorithm. The slow part of the normal algorithm are the modulo operations. Modulo operations, although we see them as $O(1)$ , are a lot slower than simpler operations like addition, subtraction or bitwise operations. So it would be better to avoid those. It turns out, that you can design a fast GCD algorithm that avoids modulo operations. It's based on a few properties: If both numbers are even, then we can factor out a two of both and compute the GCD of the remaining numbers: $\\gcd(2a, 2b) = 2 \\gcd(a, b)$ . If one of the numbers is even and the other one is odd, then we can remove the factor 2 from the even one: $\\gcd(2a, b) = \\gcd(a, b)$ if $b$ is odd. If both numbers are odd, then subtracting one number of the other one will not change the GCD: $\\gcd(a, b) = \\gcd(b, a-b)$ Using only these properties, and some fast bitwise functions from GCC, we can implement a fast version: int gcd ( int a , int b ) { if ( ! a || ! b ) return a | b ; unsigned shift = __builtin_ctz ( a | b ); a >>= __builtin_ctz ( a ); do { b >>= __builtin_ctz ( b ); if ( a > b ) swap ( a , b ); b -= a ; } while ( b ); return a << shift ; } Notice, that such an optimization is usually not necessary, and most programming languages already have a GCD function in their standard libraries. E.g. C++17 has such a function std::gcd in the numeric header.","title":"Binary GCD"},{"location":"algebra/euclid-algorithm.html#practice-problems","text":"CSAcademy - Greatest Common Divisor Codeforces 1916B - Two Divisors","title":"Practice Problems"},{"location":"algebra/extended-euclid-algorithm.html","text":"Extended Euclidean Algorithm \u00b6 While the Euclidean algorithm calculates only the greatest common divisor (GCD) of two integers $a$ and $b$ , the extended version also finds a way to represent GCD in terms of $a$ and $b$ , i.e. coefficients $x$ and $y$ for which: $$a \\cdot x + b \\cdot y = \\gcd(a, b)$$ It's important to note that by B\u00e9zout's identity we can always find such a representation. For instance, $\\gcd(55, 80) = 5$ , therefore we can represent $5$ as a linear combination with the terms $55$ and $80$ : $55 \\cdot 3 + 80 \\cdot (-2) = 5$ A more general form of that problem is discussed in the article about Linear Diophantine Equations . It will build upon this algorithm. Algorithm \u00b6 We will denote the GCD of $a$ and $b$ with $g$ in this section. The changes to the original algorithm are very simple. If we recall the algorithm, we can see that the algorithm ends with $b = 0$ and $a = g$ . For these parameters we can easily find coefficients, namely $g \\cdot 1 + 0 \\cdot 0 = g$ . Starting from these coefficients $(x, y) = (1, 0)$ , we can go backwards up the recursive calls. All we need to do is to figure out how the coefficients $x$ and $y$ change during the transition from $(a, b)$ to $(b, a \\bmod b)$ . Let us assume we found the coefficients $(x_1, y_1)$ for $(b, a \\bmod b)$ : $$b \\cdot x_1 + (a \\bmod b) \\cdot y_1 = g$$ and we want to find the pair $(x, y)$ for $(a, b)$ : $$ a \\cdot x + b \\cdot y = g$$ We can represent $a \\bmod b$ as: $$ a \\bmod b = a - \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\cdot b$$ Substituting this expression in the coefficient equation of $(x_1, y_1)$ gives: $$ g = b \\cdot x_1 + (a \\bmod b) \\cdot y_1 = b \\cdot x_1 + \\left(a - \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\cdot b \\right) \\cdot y_1$$ and after rearranging the terms: $$g = a \\cdot y_1 + b \\cdot \\left( x_1 - y_1 \\cdot \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\right)$$ We found the values of $x$ and $y$ : $$\\begin{cases} x = y_1 \\\\ y = x_1 - y_1 \\cdot \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\end{cases} $$ Implementation \u00b6 int gcd ( int a , int b , int & x , int & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } int x1 , y1 ; int d = gcd ( b , a % b , x1 , y1 ); x = y1 ; y = x1 - y1 * ( a / b ); return d ; } The recursive function above returns the GCD and the values of coefficients to x and y (which are passed by reference to the function). This implementation of extended Euclidean algorithm produces correct results for negative integers as well. Iterative version \u00b6 It's also possible to write the Extended Euclidean algorithm in an iterative way. Because it avoids recursion, the code will run a little bit faster than the recursive one. int gcd ( int a , int b , int & x , int & y ) { x = 1 , y = 0 ; int x1 = 0 , y1 = 1 , a1 = a , b1 = b ; while ( b1 ) { int q = a1 / b1 ; tie ( x , x1 ) = make_tuple ( x1 , x - q * x1 ); tie ( y , y1 ) = make_tuple ( y1 , y - q * y1 ); tie ( a1 , b1 ) = make_tuple ( b1 , a1 - q * b1 ); } return a1 ; } If you look closely at the variables a1 and b1 , you can notice that they take exactly the same values as in the iterative version of the normal Euclidean algorithm . So the algorithm will at least compute the correct GCD. To see why the algorithm computes the correct coefficients, consider that the following invariants hold at any given time (before the while loop begins and at the end of each iteration): $$x \\cdot a + y \\cdot b = a_1$$ $$x_1 \\cdot a + y_1 \\cdot b = b_1$$ Let the values at the end of an iteration be denoted by a prime ( $'$ ), and assume $q = \\frac{a_1}{b_1}$ . From the Euclidean algorithm , we have: $$a_1' = b_1$$ $$b_1' = a_1 - q \\cdot b_1$$ For the first invariant to hold, the following should be true: $$x' \\cdot a + y' \\cdot b = a_1' = b_1$$ $$x' \\cdot a + y' \\cdot b = x_1 \\cdot a + y_1 \\cdot b$$ Similarly for the second invariant, the following should hold: $$x_1' \\cdot a + y_1' \\cdot b = a_1 - q \\cdot b_1$$ $$x_1' \\cdot a + y_1' \\cdot b = (x - q \\cdot x_1) \\cdot a + (y - q \\cdot y_1) \\cdot b$$ By comparing the coefficients of $a$ and $b$ , the update equations for each variable can be derived, ensuring that the invariants are maintained throughout the algorithm. At the end we know that $a_1$ contains the GCD, so $x \\cdot a + y \\cdot b = g$ . Which means that we have found the required coefficients. You can even optimize the code more, and remove the variable $a_1$ and $b_1$ from the code, and just reuse $a$ and $b$ . However if you do so, you lose the ability to argue about the invariants. Practice Problems \u00b6 UVA - 10104 - Euclid Problem GYM - (J) Once Upon A Time UVA - 12775 - Gift Dilemma","title":"Extended Euclidean Algorithm"},{"location":"algebra/extended-euclid-algorithm.html#extended-euclidean-algorithm","text":"While the Euclidean algorithm calculates only the greatest common divisor (GCD) of two integers $a$ and $b$ , the extended version also finds a way to represent GCD in terms of $a$ and $b$ , i.e. coefficients $x$ and $y$ for which: $$a \\cdot x + b \\cdot y = \\gcd(a, b)$$ It's important to note that by B\u00e9zout's identity we can always find such a representation. For instance, $\\gcd(55, 80) = 5$ , therefore we can represent $5$ as a linear combination with the terms $55$ and $80$ : $55 \\cdot 3 + 80 \\cdot (-2) = 5$ A more general form of that problem is discussed in the article about Linear Diophantine Equations . It will build upon this algorithm.","title":"Extended Euclidean Algorithm"},{"location":"algebra/extended-euclid-algorithm.html#algorithm","text":"We will denote the GCD of $a$ and $b$ with $g$ in this section. The changes to the original algorithm are very simple. If we recall the algorithm, we can see that the algorithm ends with $b = 0$ and $a = g$ . For these parameters we can easily find coefficients, namely $g \\cdot 1 + 0 \\cdot 0 = g$ . Starting from these coefficients $(x, y) = (1, 0)$ , we can go backwards up the recursive calls. All we need to do is to figure out how the coefficients $x$ and $y$ change during the transition from $(a, b)$ to $(b, a \\bmod b)$ . Let us assume we found the coefficients $(x_1, y_1)$ for $(b, a \\bmod b)$ : $$b \\cdot x_1 + (a \\bmod b) \\cdot y_1 = g$$ and we want to find the pair $(x, y)$ for $(a, b)$ : $$ a \\cdot x + b \\cdot y = g$$ We can represent $a \\bmod b$ as: $$ a \\bmod b = a - \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\cdot b$$ Substituting this expression in the coefficient equation of $(x_1, y_1)$ gives: $$ g = b \\cdot x_1 + (a \\bmod b) \\cdot y_1 = b \\cdot x_1 + \\left(a - \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\cdot b \\right) \\cdot y_1$$ and after rearranging the terms: $$g = a \\cdot y_1 + b \\cdot \\left( x_1 - y_1 \\cdot \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\right)$$ We found the values of $x$ and $y$ : $$\\begin{cases} x = y_1 \\\\ y = x_1 - y_1 \\cdot \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\end{cases} $$","title":"Algorithm"},{"location":"algebra/extended-euclid-algorithm.html#implementation","text":"int gcd ( int a , int b , int & x , int & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } int x1 , y1 ; int d = gcd ( b , a % b , x1 , y1 ); x = y1 ; y = x1 - y1 * ( a / b ); return d ; } The recursive function above returns the GCD and the values of coefficients to x and y (which are passed by reference to the function). This implementation of extended Euclidean algorithm produces correct results for negative integers as well.","title":"Implementation"},{"location":"algebra/extended-euclid-algorithm.html#iterative-version","text":"It's also possible to write the Extended Euclidean algorithm in an iterative way. Because it avoids recursion, the code will run a little bit faster than the recursive one. int gcd ( int a , int b , int & x , int & y ) { x = 1 , y = 0 ; int x1 = 0 , y1 = 1 , a1 = a , b1 = b ; while ( b1 ) { int q = a1 / b1 ; tie ( x , x1 ) = make_tuple ( x1 , x - q * x1 ); tie ( y , y1 ) = make_tuple ( y1 , y - q * y1 ); tie ( a1 , b1 ) = make_tuple ( b1 , a1 - q * b1 ); } return a1 ; } If you look closely at the variables a1 and b1 , you can notice that they take exactly the same values as in the iterative version of the normal Euclidean algorithm . So the algorithm will at least compute the correct GCD. To see why the algorithm computes the correct coefficients, consider that the following invariants hold at any given time (before the while loop begins and at the end of each iteration): $$x \\cdot a + y \\cdot b = a_1$$ $$x_1 \\cdot a + y_1 \\cdot b = b_1$$ Let the values at the end of an iteration be denoted by a prime ( $'$ ), and assume $q = \\frac{a_1}{b_1}$ . From the Euclidean algorithm , we have: $$a_1' = b_1$$ $$b_1' = a_1 - q \\cdot b_1$$ For the first invariant to hold, the following should be true: $$x' \\cdot a + y' \\cdot b = a_1' = b_1$$ $$x' \\cdot a + y' \\cdot b = x_1 \\cdot a + y_1 \\cdot b$$ Similarly for the second invariant, the following should hold: $$x_1' \\cdot a + y_1' \\cdot b = a_1 - q \\cdot b_1$$ $$x_1' \\cdot a + y_1' \\cdot b = (x - q \\cdot x_1) \\cdot a + (y - q \\cdot y_1) \\cdot b$$ By comparing the coefficients of $a$ and $b$ , the update equations for each variable can be derived, ensuring that the invariants are maintained throughout the algorithm. At the end we know that $a_1$ contains the GCD, so $x \\cdot a + y \\cdot b = g$ . Which means that we have found the required coefficients. You can even optimize the code more, and remove the variable $a_1$ and $b_1$ from the code, and just reuse $a$ and $b$ . However if you do so, you lose the ability to argue about the invariants.","title":"Iterative version"},{"location":"algebra/extended-euclid-algorithm.html#practice-problems","text":"UVA - 10104 - Euclid Problem GYM - (J) Once Upon A Time UVA - 12775 - Gift Dilemma","title":"Practice Problems"},{"location":"algebra/factorial-divisors.html","text":"Finding Power of Factorial Divisor \u00b6 You are given two numbers $n$ and $k$ . Find the largest power of $k$ $x$ such that $n!$ is divisible by $k^x$ . Prime $k$ \u00b6 Let's first consider the case of prime $k$ . The explicit expression for factorial $$n! = 1 \\cdot 2 \\cdot 3 \\ldots (n-1) \\cdot n$$ Note that every $k$ -th element of the product is divisible by $k$ , i.e. adds $+1$ to the answer; the number of such elements is $\\Bigl\\lfloor\\dfrac{n}{k}\\Bigr\\rfloor$ . Next, every $k^2$ -th element is divisible by $k^2$ , i.e. adds another $+1$ to the answer (the first power of $k$ has already been counted in the previous paragraph). The number of such elements is $\\Bigl\\lfloor\\dfrac{n}{k^2}\\Bigr\\rfloor$ . And so on, for every $i$ each $k^i$ -th element adds another $+1$ to the answer, and there are $\\Bigl\\lfloor\\dfrac{n}{k^i}\\Bigr\\rfloor$ such elements. The final answer is $$\\Bigl\\lfloor\\dfrac{n}{k}\\Bigr\\rfloor + \\Bigl\\lfloor\\dfrac{n}{k^2}\\Bigr\\rfloor + \\ldots + \\Bigl\\lfloor\\dfrac{n}{k^i}\\Bigr\\rfloor + \\ldots$$ This result is also known as Legendre's formula . The sum is of course finite, since only approximately the first $\\log_k n$ elements are not zeros. Thus, the runtime of this algorithm is $O(\\log_k n)$ . Implementation \u00b6 int fact_pow ( int n , int k ) { int res = 0 ; while ( n ) { n /= k ; res += n ; } return res ; } Composite $k$ \u00b6 The same idea can't be applied directly. Instead we can factor $k$ , representing it as $k = k_1^{p_1} \\cdot \\ldots \\cdot k_m^{p_m}$ . For each $k_i$ , we find the number of times it is present in $n!$ using the algorithm described above - let's call this value $a_i$ . The answer for composite $k$ will be $$\\min_ {i=1 \\ldots m} \\dfrac{a_i}{p_i}$$","title":"Finding Power of Factorial Divisor"},{"location":"algebra/factorial-divisors.html#finding-power-of-factorial-divisor","text":"You are given two numbers $n$ and $k$ . Find the largest power of $k$ $x$ such that $n!$ is divisible by $k^x$ .","title":"Finding Power of Factorial Divisor"},{"location":"algebra/factorial-divisors.html#prime-k","text":"Let's first consider the case of prime $k$ . The explicit expression for factorial $$n! = 1 \\cdot 2 \\cdot 3 \\ldots (n-1) \\cdot n$$ Note that every $k$ -th element of the product is divisible by $k$ , i.e. adds $+1$ to the answer; the number of such elements is $\\Bigl\\lfloor\\dfrac{n}{k}\\Bigr\\rfloor$ . Next, every $k^2$ -th element is divisible by $k^2$ , i.e. adds another $+1$ to the answer (the first power of $k$ has already been counted in the previous paragraph). The number of such elements is $\\Bigl\\lfloor\\dfrac{n}{k^2}\\Bigr\\rfloor$ . And so on, for every $i$ each $k^i$ -th element adds another $+1$ to the answer, and there are $\\Bigl\\lfloor\\dfrac{n}{k^i}\\Bigr\\rfloor$ such elements. The final answer is $$\\Bigl\\lfloor\\dfrac{n}{k}\\Bigr\\rfloor + \\Bigl\\lfloor\\dfrac{n}{k^2}\\Bigr\\rfloor + \\ldots + \\Bigl\\lfloor\\dfrac{n}{k^i}\\Bigr\\rfloor + \\ldots$$ This result is also known as Legendre's formula . The sum is of course finite, since only approximately the first $\\log_k n$ elements are not zeros. Thus, the runtime of this algorithm is $O(\\log_k n)$ .","title":"Prime k"},{"location":"algebra/factorial-divisors.html#implementation","text":"int fact_pow ( int n , int k ) { int res = 0 ; while ( n ) { n /= k ; res += n ; } return res ; }","title":"Implementation"},{"location":"algebra/factorial-divisors.html#composite-k","text":"The same idea can't be applied directly. Instead we can factor $k$ , representing it as $k = k_1^{p_1} \\cdot \\ldots \\cdot k_m^{p_m}$ . For each $k_i$ , we find the number of times it is present in $n!$ using the algorithm described above - let's call this value $a_i$ . The answer for composite $k$ will be $$\\min_ {i=1 \\ldots m} \\dfrac{a_i}{p_i}$$","title":"Composite k"},{"location":"algebra/factorial-modulo.html","text":"Factorial modulo $p$ \u00b6 In some cases it is necessary to consider complex formulas modulo some prime $p$ , containing factorials in both numerator and denominator, like such that you encounter in the formula for Binomial coefficients. We consider the case when $p$ is relatively small. This problem makes only sense when the factorials appear in both numerator and denominator of fractions. Otherwise $p!$ and subsequent terms will reduce to zero. But in fractions the factors of $p$ can cancel, and the resulting expression will be non-zero modulo $p$ . Thus, formally the task is: You want to calculate $n! \\bmod p$ , without taking all the multiple factors of $p$ into account that appear in the factorial. Imagine you write down the prime factorization of $n!$ , remove all factors $p$ , and compute the product modulo $p$ . We will denote this modified factorial with $n!_{\\%p}$ . For instance $7!_{\\%p} \\equiv 1 \\cdot 2 \\cdot \\underbrace{1}_{3} \\cdot 4 \\cdot 5 \\underbrace{2}_{6} \\cdot 7 \\equiv 2 \\bmod 3$ . Learning how to effectively calculate this modified factorial allows us to quickly calculate the value of the various combinatorial formulas (for example, Binomial coefficients ). Algorithm \u00b6 Let's write this modified factorial explicitly. $$\\begin{eqnarray} n!_{\\%p} &=& 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot \\underbrace{1}_{p} \\cdot (p+1) \\cdot (p+2) \\cdot \\ldots \\cdot (2p-1) \\cdot \\underbrace{2}_{2p} \\\\\\ & &\\quad \\cdot (2p+1) \\cdot \\ldots \\cdot (p^2-1) \\cdot \\underbrace{1}_{p^2} \\cdot (p^2 +1) \\cdot \\ldots \\cdot n \\pmod{p} \\\\\\\\ &=& 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot \\underbrace{1}_{p} \\cdot 1 \\cdot 2 \\cdot \\ldots \\cdot (p-1) \\cdot \\underbrace{2}_{2p} \\cdot 1 \\cdot 2 \\\\\\ & &\\quad \\cdot \\ldots \\cdot (p-1) \\cdot \\underbrace{1}_{p^2} \\cdot 1 \\cdot 2 \\cdot \\ldots \\cdot (n \\bmod p) \\pmod{p} \\end{eqnarray}$$ It can be clearly seen that factorial is divided into several blocks of same length except for the last one. $$\\begin{eqnarray} n!_{\\%p}&=& \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 1}_{1\\text{st}} \\cdot \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 2}_{2\\text{nd}} \\cdot \\ldots \\\\\\\\ & & \\cdot \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 1}_{p\\text{th}} \\cdot \\ldots \\cdot \\quad \\underbrace{1 \\cdot 2 \\cdot \\cdot \\ldots \\cdot (n \\bmod p)}_{\\text{tail}} \\pmod{p}. \\end{eqnarray}$$ The main part of the blocks it is easy to count \u2014 it's just $(p-1)!\\ \\mathrm{mod}\\ p$ . We can compute that programmatically or just apply Wilson theorem which states that $(p-1)! \\bmod p = -1$ for any prime $p$ . We have exactly $\\lfloor \\frac{n}{p} \\rfloor$ such blocks, therefore we need to raise $-1$ to the power of $\\lfloor \\frac{n}{p} \\rfloor$ . This can be done in logarithmic time using Binary Exponentiation ; however you can also notice that the result will switch between $-1$ and $1$ , so we only need to look at the parity of the exponent and multiply by $-1$ if the parity is odd. And instead of a multiplication, we can also just subtract the current result from $p$ . The value of the last partial block can be calculated separately in $O(p)$ . This leaves only the last element of each block. If we hide the already handled elements, we can see the following pattern: $$n!_{\\%p} = \\underbrace{ \\ldots \\cdot 1 } \\cdot \\underbrace{ \\ldots \\cdot 2} \\cdot \\ldots \\cdot \\underbrace{ \\ldots \\cdot (p-1)} \\cdot \\underbrace{ \\ldots \\cdot 1 } \\cdot \\underbrace{ \\ldots \\cdot 1} \\cdot \\underbrace{ \\ldots \\cdot 2} \\cdots$$ This again is a modified factorial, only with a much smaller dimension. It's $\\lfloor n / p \\rfloor !_{\\%p}$ . Thus, during the calculation of the modified factorial $n\\!_{\\%p}$ we did $O(p)$ operations and are left with the calculation of $\\lfloor n / p \\rfloor !_{\\%p}$ . We have a recursive formula. The recursion depth is $O(\\log_p n)$ , and therefore the complete asymptotic behavior of the algorithm is $O(p \\log_p n)$ . Notice, if you precompute the factorials $0!,~ 1!,~ 2!,~ \\dots,~ (p-1)!$ modulo $p$ , then the complexity will just be $O(\\log_p n)$ . Implementation \u00b6 We don't need recursion because this is a case of tail recursion and thus can be easily implemented using iteration. In the following implementation we precompute the factorials $0!,~ 1!,~ \\dots,~ (p-1)!$ , and thus have the runtime $O(p + \\log_p n)$ . If you need to call the function multiple times, then you can do the precomputation outside of the function and do the computation of $n!_{\\%p}$ in $O(\\log_p n)$ time. int factmod ( int n , int p ) { vector < int > f ( p ); f [ 0 ] = 1 ; for ( int i = 1 ; i < p ; i ++ ) f [ i ] = f [ i -1 ] * i % p ; int res = 1 ; while ( n > 1 ) { if (( n / p ) % 2 ) res = p - res ; res = res * f [ n % p ] % p ; n /= p ; } return res ; } Alternative, if you only have limit memory and can't afford storing all factorials, you can also just remember the factorials that you need, sort them, and then compute them in one sweep by computing the factorials $0!,~ 1!,~ 2!,~ \\dots,~ (p-1)!$ in a loop without storing them explicitly. Multiplicity of $p$ \u00b6 If we want to compute a Binomial coefficient modulo $p$ , then we additionally need the multiplicity of the $p$ in $n$ , i.e. the number of times $p$ occurs in the prime factorization of $n$ , or number of times we erased $p$ during the computation of the modified factorial. Legendre's formula gives us a way to compute this in $O(\\log_p n)$ time. The formula gives the multiplicity $\\nu_p$ as: $$\\nu_p(n!) = \\sum_{i=1}^{\\infty} \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor$$ Thus we get the implementation: int multiplicity_factorial ( int n , int p ) { int count = 0 ; do { n /= p ; count += n ; } while ( n ); return count ; } This formula can be proven very easily using the same ideas that we did in the previous sections. Remove all elements that don't contain the factor $p$ . This leaves $\\lfloor n/p \\rfloor$ element remaining. If we remove the factor $p$ from each of them, we get the product $1 \\cdot 2 \\cdots \\lfloor n/p \\rfloor = \\lfloor n/p \\rfloor !$ , and again we have a recursion.","title":"Factorial modulo p"},{"location":"algebra/factorial-modulo.html#factorial-modulo-p","text":"In some cases it is necessary to consider complex formulas modulo some prime $p$ , containing factorials in both numerator and denominator, like such that you encounter in the formula for Binomial coefficients. We consider the case when $p$ is relatively small. This problem makes only sense when the factorials appear in both numerator and denominator of fractions. Otherwise $p!$ and subsequent terms will reduce to zero. But in fractions the factors of $p$ can cancel, and the resulting expression will be non-zero modulo $p$ . Thus, formally the task is: You want to calculate $n! \\bmod p$ , without taking all the multiple factors of $p$ into account that appear in the factorial. Imagine you write down the prime factorization of $n!$ , remove all factors $p$ , and compute the product modulo $p$ . We will denote this modified factorial with $n!_{\\%p}$ . For instance $7!_{\\%p} \\equiv 1 \\cdot 2 \\cdot \\underbrace{1}_{3} \\cdot 4 \\cdot 5 \\underbrace{2}_{6} \\cdot 7 \\equiv 2 \\bmod 3$ . Learning how to effectively calculate this modified factorial allows us to quickly calculate the value of the various combinatorial formulas (for example, Binomial coefficients ).","title":"Factorial modulo $p$"},{"location":"algebra/factorial-modulo.html#algorithm","text":"Let's write this modified factorial explicitly. $$\\begin{eqnarray} n!_{\\%p} &=& 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot \\underbrace{1}_{p} \\cdot (p+1) \\cdot (p+2) \\cdot \\ldots \\cdot (2p-1) \\cdot \\underbrace{2}_{2p} \\\\\\ & &\\quad \\cdot (2p+1) \\cdot \\ldots \\cdot (p^2-1) \\cdot \\underbrace{1}_{p^2} \\cdot (p^2 +1) \\cdot \\ldots \\cdot n \\pmod{p} \\\\\\\\ &=& 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot \\underbrace{1}_{p} \\cdot 1 \\cdot 2 \\cdot \\ldots \\cdot (p-1) \\cdot \\underbrace{2}_{2p} \\cdot 1 \\cdot 2 \\\\\\ & &\\quad \\cdot \\ldots \\cdot (p-1) \\cdot \\underbrace{1}_{p^2} \\cdot 1 \\cdot 2 \\cdot \\ldots \\cdot (n \\bmod p) \\pmod{p} \\end{eqnarray}$$ It can be clearly seen that factorial is divided into several blocks of same length except for the last one. $$\\begin{eqnarray} n!_{\\%p}&=& \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 1}_{1\\text{st}} \\cdot \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 2}_{2\\text{nd}} \\cdot \\ldots \\\\\\\\ & & \\cdot \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 1}_{p\\text{th}} \\cdot \\ldots \\cdot \\quad \\underbrace{1 \\cdot 2 \\cdot \\cdot \\ldots \\cdot (n \\bmod p)}_{\\text{tail}} \\pmod{p}. \\end{eqnarray}$$ The main part of the blocks it is easy to count \u2014 it's just $(p-1)!\\ \\mathrm{mod}\\ p$ . We can compute that programmatically or just apply Wilson theorem which states that $(p-1)! \\bmod p = -1$ for any prime $p$ . We have exactly $\\lfloor \\frac{n}{p} \\rfloor$ such blocks, therefore we need to raise $-1$ to the power of $\\lfloor \\frac{n}{p} \\rfloor$ . This can be done in logarithmic time using Binary Exponentiation ; however you can also notice that the result will switch between $-1$ and $1$ , so we only need to look at the parity of the exponent and multiply by $-1$ if the parity is odd. And instead of a multiplication, we can also just subtract the current result from $p$ . The value of the last partial block can be calculated separately in $O(p)$ . This leaves only the last element of each block. If we hide the already handled elements, we can see the following pattern: $$n!_{\\%p} = \\underbrace{ \\ldots \\cdot 1 } \\cdot \\underbrace{ \\ldots \\cdot 2} \\cdot \\ldots \\cdot \\underbrace{ \\ldots \\cdot (p-1)} \\cdot \\underbrace{ \\ldots \\cdot 1 } \\cdot \\underbrace{ \\ldots \\cdot 1} \\cdot \\underbrace{ \\ldots \\cdot 2} \\cdots$$ This again is a modified factorial, only with a much smaller dimension. It's $\\lfloor n / p \\rfloor !_{\\%p}$ . Thus, during the calculation of the modified factorial $n\\!_{\\%p}$ we did $O(p)$ operations and are left with the calculation of $\\lfloor n / p \\rfloor !_{\\%p}$ . We have a recursive formula. The recursion depth is $O(\\log_p n)$ , and therefore the complete asymptotic behavior of the algorithm is $O(p \\log_p n)$ . Notice, if you precompute the factorials $0!,~ 1!,~ 2!,~ \\dots,~ (p-1)!$ modulo $p$ , then the complexity will just be $O(\\log_p n)$ .","title":"Algorithm"},{"location":"algebra/factorial-modulo.html#implementation","text":"We don't need recursion because this is a case of tail recursion and thus can be easily implemented using iteration. In the following implementation we precompute the factorials $0!,~ 1!,~ \\dots,~ (p-1)!$ , and thus have the runtime $O(p + \\log_p n)$ . If you need to call the function multiple times, then you can do the precomputation outside of the function and do the computation of $n!_{\\%p}$ in $O(\\log_p n)$ time. int factmod ( int n , int p ) { vector < int > f ( p ); f [ 0 ] = 1 ; for ( int i = 1 ; i < p ; i ++ ) f [ i ] = f [ i -1 ] * i % p ; int res = 1 ; while ( n > 1 ) { if (( n / p ) % 2 ) res = p - res ; res = res * f [ n % p ] % p ; n /= p ; } return res ; } Alternative, if you only have limit memory and can't afford storing all factorials, you can also just remember the factorials that you need, sort them, and then compute them in one sweep by computing the factorials $0!,~ 1!,~ 2!,~ \\dots,~ (p-1)!$ in a loop without storing them explicitly.","title":"Implementation"},{"location":"algebra/factorial-modulo.html#multiplicity-of-p","text":"If we want to compute a Binomial coefficient modulo $p$ , then we additionally need the multiplicity of the $p$ in $n$ , i.e. the number of times $p$ occurs in the prime factorization of $n$ , or number of times we erased $p$ during the computation of the modified factorial. Legendre's formula gives us a way to compute this in $O(\\log_p n)$ time. The formula gives the multiplicity $\\nu_p$ as: $$\\nu_p(n!) = \\sum_{i=1}^{\\infty} \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor$$ Thus we get the implementation: int multiplicity_factorial ( int n , int p ) { int count = 0 ; do { n /= p ; count += n ; } while ( n ); return count ; } This formula can be proven very easily using the same ideas that we did in the previous sections. Remove all elements that don't contain the factor $p$ . This leaves $\\lfloor n/p \\rfloor$ element remaining. If we remove the factor $p$ from each of them, we get the product $1 \\cdot 2 \\cdots \\lfloor n/p \\rfloor = \\lfloor n/p \\rfloor !$ , and again we have a recursion.","title":"Multiplicity of $p$"},{"location":"algebra/factoring-exp.html","text":"Binary Exponentiation by Factoring \u00b6 Consider a problem of computing $ax^y \\pmod{2^d}$ , given integers $a$ , $x$ , $y$ and $d \\geq 3$ , where $x$ is odd. The algorithm below allows to solve this problem with $O(d)$ additions and binary operations and a single multiplication by $y$ . Due to the structure of the multiplicative group modulo $2^d$ , any number $x$ such that $x \\equiv 1 \\pmod 4$ can be represented as $$ x \\equiv b^{L(x)} \\pmod{2^d}, $$ where $b \\equiv 5 \\pmod 8$ . Without loss of generality we assume that $x \\equiv 1 \\pmod 4$ , as we can reduce $x \\equiv 3 \\pmod 4$ to $x \\equiv 1 \\pmod 4$ by substituting $x \\mapsto -x$ and $a \\mapsto (-1)^{y} a$ . In this notion, $ax^y$ is represented as $$ a x^y \\equiv a b^{yL(x)} \\pmod{2^d}. $$ The core idea of the algorithm is to simplify the computation of $L(x)$ and $b^{y L(x)}$ using the fact that we're working modulo $2^d$ . For reasons that will be apparent later on, we'll be working with $4L(x)$ rather than $L(x)$ , but taken modulo $2^d$ instead of $2^{d-2}$ . In this article, we will cover the implementation for $32$ -bit integers. Let mbin_log_32(r, x) be a function that computes $r+4L(x) \\pmod{2^d}$ ; mbin_exp_32(r, x) be a function that computes $r b^{\\frac{x}{4}} \\pmod{2^d}$ ; mbin_power_odd_32(a, x, y) be a function that computes $ax^y \\pmod{2^d}$ . Then mbin_power_odd_32 is implemented as follows: uint32_t mbin_power_odd_32 ( uint32_t rem , uint32_t base , uint32_t exp ) { if ( base & 2 ) { /* divider is considered negative */ base = - base ; /* check if result should be negative */ if ( exp & 1 ) { rem = - rem ; } } return ( mbin_exp_32 ( rem , mbin_log_32 ( 0 , base ) * exp )); } Computing 4L(x) from x \u00b6 Let $x$ be an odd number such that $x \\equiv 1 \\pmod 4$ . It can be represented as $$ x \\equiv (2^{a_1}+1)\\dots(2^{a_k}+1) \\pmod{2^d}, $$ where $1 < a_1 < \\dots < a_k < d$ . Here $L(\\cdot)$ is well-defined for each multiplier, as they're equal to $1$ modulo $4$ . Hence, $$ 4L(x) \\equiv 4L(2^{a_1}+1)+\\dots+4L(2^{a_k}+1) \\pmod{2^{d}}. $$ So, if we precompute $t_k = 4L(2^n+1)$ for all $1 < k < d$ , we will be able to compute $4L(x)$ for any number $x$ . For 32-bit integers, we can use the following table: const uint32_t mbin_log_32_table [ 32 ] = { 0x00000000 , 0x00000000 , 0xd3cfd984 , 0x9ee62e18 , 0xe83d9070 , 0xb59e81e0 , 0xa17407c0 , 0xce601f80 , 0xf4807f00 , 0xe701fe00 , 0xbe07fc00 , 0xfc1ff800 , 0xf87ff000 , 0xf1ffe000 , 0xe7ffc000 , 0xdfff8000 , 0xffff0000 , 0xfffe0000 , 0xfffc0000 , 0xfff80000 , 0xfff00000 , 0xffe00000 , 0xffc00000 , 0xff800000 , 0xff000000 , 0xfe000000 , 0xfc000000 , 0xf8000000 , 0xf0000000 , 0xe0000000 , 0xc0000000 , 0x80000000 , }; On practice, a slightly different approach is used than described above. Rather than finding the factorization for $x$ , we will consequently multiply $x$ with $2^n+1$ until we turn it into $1$ modulo $2^d$ . In this way, we will find the representation of $x^{-1}$ , that is $$ x (2^{a_1}+1)\\dots(2^{a_k}+1) \\equiv 1 \\pmod {2^d}. $$ To do this, we iterate over $n$ such that $1 < n < d$ . If the current $x$ has $n$ -th bit set, we multiply $x$ with $2^n+1$ , which is conveniently done in C++ as x = x + (x << n) . This won't change bits lower than $n$ , but will turn the $n$ -th bit to zero, because $x$ is odd. With all this in mind, the function mbin_log_32(r, x) is implemented as follows: uint32_t mbin_log_32 ( uint32_t r , uint32_t x ) { uint8_t n ; for ( n = 2 ; n < 32 ; n ++ ) { if ( x & ( 1 << n )) { x = x + ( x << n ); r -= mbin_log_32_table [ n ]; } } return r ; } Note that $4L(x) = -4L(x^{-1})$ , so instead of adding $4L(2^n+1)$ , we subtract it from $r$ , which initially equates to $0$ . Computing x from 4L(x) \u00b6 Note that for $k \\geq 1$ it holds that $$ (a 2^{k}+1)^2 = a^2 2^{2k} +a 2^{k+1}+1 = b2^{k+1}+1, $$ from which (by repeated squaring) we can deduce that $$ (2^a+1)^{2^b} \\equiv 1 \\pmod{2^{a+b}}. $$ Applying this result to $a=2^n+1$ and $b=d-k$ we deduce that the multiplicative order of $2^n+1$ is a divisor of $2^{d-n}$ . This, in turn, means that $L(2^n+1)$ must be divisible by $2^{n}$ , as the order of $b$ is $2^{d-2}$ and the order of $b^y$ is $2^{d-2-v}$ , where $2^v$ is the highest power of $2$ that divides $y$ , so we need $$ 2^{d-k} \\equiv 0 \\pmod{2^{d-2-v}}, $$ thus $v$ must be greater or equal than $k-2$ . This is a bit ugly and to mitigate this we said in the beginning that we multiply $L(x)$ by $4$ . Now if we know $4L(x)$ , we can uniquely decomposing it into a sum of $4L(2^n+1)$ by consequentially checking bits in $4L(x)$ . If the $n$ -th bit is set to $1$ , we will multiply the result with $2^n+1$ and reduce the current $4L(x)$ by $4L(2^n+1)$ . Thus, mbin_exp_32 is implemented as follows: uint32_t mbin_exp_32 ( uint32_t r , uint32_t x ) { uint8_t n ; for ( n = 2 ; n < 32 ; n ++ ) { if ( x & ( 1 << n )) { r = r + ( r << n ); x -= mbin_log_32_table [ n ]; } } return r ; } Further optimizations \u00b6 It is possible to halve the number of iterations if you note that $4L(2^{d-1}+1)=2^{d-1}$ and that for $2k \\geq d$ it holds that $$ (2^n+1)^2 \\equiv 2^{2n} + 2^{n+1}+1 \\equiv 2^{n+1}+1 \\pmod{2^d}, $$ which allows to deduce that $4L(2^n+1)=2^n$ for $2n \\geq d$ . So, you could simplify the algorithm by only going up to $\\frac{d}{2}$ and then use the fact above to compute the remaining part with bitwise operations: uint32_t mbin_log_32 ( uint32_t r , uint32_t x ) { uint8_t n ; for ( n = 2 ; n != 16 ; n ++ ) { if ( x & ( 1 << n )) { x = x + ( x << n ); r -= mbin_log_32_table [ n ]; } } r -= ( x & 0xFFFF0000 ); return r ; } uint32_t mbin_exp_32 ( uint32_t r , uint32_t x ) { uint8_t n ; for ( n = 2 ; n != 16 ; n ++ ) { if ( x & ( 1 << n )) { r = r + ( r << n ); x -= mbin_log_32_table [ n ]; } } r *= 1 - ( x & 0xFFFF0000 ); return r ; } Computing logarithm table \u00b6 To compute log-table, one could modify the Pohlig\u2013Hellman algorithm for the case when modulo is a power of $2$ . Our main task here is to compute $x$ such that $g^x \\equiv y \\pmod{2^d}$ , where $g=5$ and $y$ is a number of kind $2^n+1$ . Squaring both parts $k$ times we arrive to $$ g^{2^k x} \\equiv y^{2^k} \\pmod{2^d}. $$ Note that the order of $g$ is not greater than $2^{d}$ (in fact, than $2^{d-2}$ , but we will stick to $2^d$ for convenience), hence using $k=d-1$ we will have either $g^1$ or $g^0$ on the left hand side which allows us to determine the smallest bit of $x$ by comparing $y^{2^k}$ to $g$ . Now assume that $x=x_0 + 2^k x_1$ , where $x_0$ is a known part and $x_1$ is not yet known. Then $$ g^{x_0+2^k x_1} \\equiv y \\pmod{2^d}. $$ Multiplying both parts with $g^{-x_0}$ , we get $$ g^{2^k x_1} \\equiv (g^{-x_0} y) \\pmod{2^d}. $$ Now, squaring both sides $d-k-1$ times we can obtain the next bit of $x$ , eventually recovering all its bits. References \u00b6 M30, Hans Petter Selasky, 2009","title":"Factoring Exponentiation"},{"location":"algebra/factoring-exp.html#binary-exponentiation-by-factoring","text":"Consider a problem of computing $ax^y \\pmod{2^d}$ , given integers $a$ , $x$ , $y$ and $d \\geq 3$ , where $x$ is odd. The algorithm below allows to solve this problem with $O(d)$ additions and binary operations and a single multiplication by $y$ . Due to the structure of the multiplicative group modulo $2^d$ , any number $x$ such that $x \\equiv 1 \\pmod 4$ can be represented as $$ x \\equiv b^{L(x)} \\pmod{2^d}, $$ where $b \\equiv 5 \\pmod 8$ . Without loss of generality we assume that $x \\equiv 1 \\pmod 4$ , as we can reduce $x \\equiv 3 \\pmod 4$ to $x \\equiv 1 \\pmod 4$ by substituting $x \\mapsto -x$ and $a \\mapsto (-1)^{y} a$ . In this notion, $ax^y$ is represented as $$ a x^y \\equiv a b^{yL(x)} \\pmod{2^d}. $$ The core idea of the algorithm is to simplify the computation of $L(x)$ and $b^{y L(x)}$ using the fact that we're working modulo $2^d$ . For reasons that will be apparent later on, we'll be working with $4L(x)$ rather than $L(x)$ , but taken modulo $2^d$ instead of $2^{d-2}$ . In this article, we will cover the implementation for $32$ -bit integers. Let mbin_log_32(r, x) be a function that computes $r+4L(x) \\pmod{2^d}$ ; mbin_exp_32(r, x) be a function that computes $r b^{\\frac{x}{4}} \\pmod{2^d}$ ; mbin_power_odd_32(a, x, y) be a function that computes $ax^y \\pmod{2^d}$ . Then mbin_power_odd_32 is implemented as follows: uint32_t mbin_power_odd_32 ( uint32_t rem , uint32_t base , uint32_t exp ) { if ( base & 2 ) { /* divider is considered negative */ base = - base ; /* check if result should be negative */ if ( exp & 1 ) { rem = - rem ; } } return ( mbin_exp_32 ( rem , mbin_log_32 ( 0 , base ) * exp )); }","title":"Binary Exponentiation by Factoring"},{"location":"algebra/factoring-exp.html#computing-4lx-from-x","text":"Let $x$ be an odd number such that $x \\equiv 1 \\pmod 4$ . It can be represented as $$ x \\equiv (2^{a_1}+1)\\dots(2^{a_k}+1) \\pmod{2^d}, $$ where $1 < a_1 < \\dots < a_k < d$ . Here $L(\\cdot)$ is well-defined for each multiplier, as they're equal to $1$ modulo $4$ . Hence, $$ 4L(x) \\equiv 4L(2^{a_1}+1)+\\dots+4L(2^{a_k}+1) \\pmod{2^{d}}. $$ So, if we precompute $t_k = 4L(2^n+1)$ for all $1 < k < d$ , we will be able to compute $4L(x)$ for any number $x$ . For 32-bit integers, we can use the following table: const uint32_t mbin_log_32_table [ 32 ] = { 0x00000000 , 0x00000000 , 0xd3cfd984 , 0x9ee62e18 , 0xe83d9070 , 0xb59e81e0 , 0xa17407c0 , 0xce601f80 , 0xf4807f00 , 0xe701fe00 , 0xbe07fc00 , 0xfc1ff800 , 0xf87ff000 , 0xf1ffe000 , 0xe7ffc000 , 0xdfff8000 , 0xffff0000 , 0xfffe0000 , 0xfffc0000 , 0xfff80000 , 0xfff00000 , 0xffe00000 , 0xffc00000 , 0xff800000 , 0xff000000 , 0xfe000000 , 0xfc000000 , 0xf8000000 , 0xf0000000 , 0xe0000000 , 0xc0000000 , 0x80000000 , }; On practice, a slightly different approach is used than described above. Rather than finding the factorization for $x$ , we will consequently multiply $x$ with $2^n+1$ until we turn it into $1$ modulo $2^d$ . In this way, we will find the representation of $x^{-1}$ , that is $$ x (2^{a_1}+1)\\dots(2^{a_k}+1) \\equiv 1 \\pmod {2^d}. $$ To do this, we iterate over $n$ such that $1 < n < d$ . If the current $x$ has $n$ -th bit set, we multiply $x$ with $2^n+1$ , which is conveniently done in C++ as x = x + (x << n) . This won't change bits lower than $n$ , but will turn the $n$ -th bit to zero, because $x$ is odd. With all this in mind, the function mbin_log_32(r, x) is implemented as follows: uint32_t mbin_log_32 ( uint32_t r , uint32_t x ) { uint8_t n ; for ( n = 2 ; n < 32 ; n ++ ) { if ( x & ( 1 << n )) { x = x + ( x << n ); r -= mbin_log_32_table [ n ]; } } return r ; } Note that $4L(x) = -4L(x^{-1})$ , so instead of adding $4L(2^n+1)$ , we subtract it from $r$ , which initially equates to $0$ .","title":"Computing 4L(x) from x"},{"location":"algebra/factoring-exp.html#computing-x-from-4lx","text":"Note that for $k \\geq 1$ it holds that $$ (a 2^{k}+1)^2 = a^2 2^{2k} +a 2^{k+1}+1 = b2^{k+1}+1, $$ from which (by repeated squaring) we can deduce that $$ (2^a+1)^{2^b} \\equiv 1 \\pmod{2^{a+b}}. $$ Applying this result to $a=2^n+1$ and $b=d-k$ we deduce that the multiplicative order of $2^n+1$ is a divisor of $2^{d-n}$ . This, in turn, means that $L(2^n+1)$ must be divisible by $2^{n}$ , as the order of $b$ is $2^{d-2}$ and the order of $b^y$ is $2^{d-2-v}$ , where $2^v$ is the highest power of $2$ that divides $y$ , so we need $$ 2^{d-k} \\equiv 0 \\pmod{2^{d-2-v}}, $$ thus $v$ must be greater or equal than $k-2$ . This is a bit ugly and to mitigate this we said in the beginning that we multiply $L(x)$ by $4$ . Now if we know $4L(x)$ , we can uniquely decomposing it into a sum of $4L(2^n+1)$ by consequentially checking bits in $4L(x)$ . If the $n$ -th bit is set to $1$ , we will multiply the result with $2^n+1$ and reduce the current $4L(x)$ by $4L(2^n+1)$ . Thus, mbin_exp_32 is implemented as follows: uint32_t mbin_exp_32 ( uint32_t r , uint32_t x ) { uint8_t n ; for ( n = 2 ; n < 32 ; n ++ ) { if ( x & ( 1 << n )) { r = r + ( r << n ); x -= mbin_log_32_table [ n ]; } } return r ; }","title":"Computing x from 4L(x)"},{"location":"algebra/factoring-exp.html#further-optimizations","text":"It is possible to halve the number of iterations if you note that $4L(2^{d-1}+1)=2^{d-1}$ and that for $2k \\geq d$ it holds that $$ (2^n+1)^2 \\equiv 2^{2n} + 2^{n+1}+1 \\equiv 2^{n+1}+1 \\pmod{2^d}, $$ which allows to deduce that $4L(2^n+1)=2^n$ for $2n \\geq d$ . So, you could simplify the algorithm by only going up to $\\frac{d}{2}$ and then use the fact above to compute the remaining part with bitwise operations: uint32_t mbin_log_32 ( uint32_t r , uint32_t x ) { uint8_t n ; for ( n = 2 ; n != 16 ; n ++ ) { if ( x & ( 1 << n )) { x = x + ( x << n ); r -= mbin_log_32_table [ n ]; } } r -= ( x & 0xFFFF0000 ); return r ; } uint32_t mbin_exp_32 ( uint32_t r , uint32_t x ) { uint8_t n ; for ( n = 2 ; n != 16 ; n ++ ) { if ( x & ( 1 << n )) { r = r + ( r << n ); x -= mbin_log_32_table [ n ]; } } r *= 1 - ( x & 0xFFFF0000 ); return r ; }","title":"Further optimizations"},{"location":"algebra/factoring-exp.html#computing-logarithm-table","text":"To compute log-table, one could modify the Pohlig\u2013Hellman algorithm for the case when modulo is a power of $2$ . Our main task here is to compute $x$ such that $g^x \\equiv y \\pmod{2^d}$ , where $g=5$ and $y$ is a number of kind $2^n+1$ . Squaring both parts $k$ times we arrive to $$ g^{2^k x} \\equiv y^{2^k} \\pmod{2^d}. $$ Note that the order of $g$ is not greater than $2^{d}$ (in fact, than $2^{d-2}$ , but we will stick to $2^d$ for convenience), hence using $k=d-1$ we will have either $g^1$ or $g^0$ on the left hand side which allows us to determine the smallest bit of $x$ by comparing $y^{2^k}$ to $g$ . Now assume that $x=x_0 + 2^k x_1$ , where $x_0$ is a known part and $x_1$ is not yet known. Then $$ g^{x_0+2^k x_1} \\equiv y \\pmod{2^d}. $$ Multiplying both parts with $g^{-x_0}$ , we get $$ g^{2^k x_1} \\equiv (g^{-x_0} y) \\pmod{2^d}. $$ Now, squaring both sides $d-k-1$ times we can obtain the next bit of $x$ , eventually recovering all its bits.","title":"Computing logarithm table"},{"location":"algebra/factoring-exp.html#references","text":"M30, Hans Petter Selasky, 2009","title":"References"},{"location":"algebra/factorization.html","text":"Integer factorization \u00b6 In this article we list several algorithms for the factorization of integers, each of which can be either fast or varying levels of slow depending on their input. Notice, if the number that you want to factorize is actually a prime number, most of the algorithms will run very slowly. This is especially true for Fermat's, Pollard's p-1 and Pollard's rho factorization algorithms. Therefore, it makes the most sense to perform a probabilistic (or a fast deterministic) primality test before trying to factorize the number. Trial division \u00b6 This is the most basic algorithm to find a prime factorization. We divide by each possible divisor $d$ . It can be observed that it is impossible for all prime factors of a composite number $n$ to be bigger than $\\sqrt{n}$ . Therefore, we only need to test the divisors $2 \\le d \\le \\sqrt{n}$ , which gives us the prime factorization in $O(\\sqrt{n})$ . (This is pseudo-polynomial time , i.e. polynomial in the value of the input but exponential in the number of bits of the input.) The smallest divisor must be a prime number. We remove the factored number, and continue the process. If we cannot find any divisor in the range $[2; \\sqrt{n}]$ , then the number itself has to be prime. vector < long long > trial_division1 ( long long n ) { vector < long long > factorization ; for ( long long d = 2 ; d * d <= n ; d ++ ) { while ( n % d == 0 ) { factorization . push_back ( d ); n /= d ; } } if ( n > 1 ) factorization . push_back ( n ); return factorization ; } Wheel factorization \u00b6 This is an optimization of the trial division. Once we know that the number is not divisible by 2, we don't need to check other even numbers. This leaves us with only $50\\%$ of the numbers to check. After factoring out 2, and getting an odd number, we can simply start with 3 and only count other odd numbers. vector < long long > trial_division2 ( long long n ) { vector < long long > factorization ; while ( n % 2 == 0 ) { factorization . push_back ( 2 ); n /= 2 ; } for ( long long d = 3 ; d * d <= n ; d += 2 ) { while ( n % d == 0 ) { factorization . push_back ( d ); n /= d ; } } if ( n > 1 ) factorization . push_back ( n ); return factorization ; } This method can be extended further. If the number is not divisible by 3, we can also ignore all other multiples of 3 in the future computations. So we only need to check the numbers $5, 7, 11, 13, 17, 19, 23, \\dots$ . We can observe a pattern of these remaining numbers. We need to check all numbers with $d \\bmod 6 = 1$ and $d \\bmod 6 = 5$ . So this leaves us with only $33.3\\%$ percent of the numbers to check. We can implement this by factoring out the primes 2 and 3 first, after which we start with 5 and only count remainders $1$ and $5$ modulo $6$ . Here is an implementation for the prime number 2, 3 and 5. It is convenient to store the skipping strides in an array. vector < long long > trial_division3 ( long long n ) { vector < long long > factorization ; for ( int d : { 2 , 3 , 5 }) { while ( n % d == 0 ) { factorization . push_back ( d ); n /= d ; } } static array < int , 8 > increments = { 4 , 2 , 4 , 2 , 4 , 6 , 2 , 6 }; int i = 0 ; for ( long long d = 7 ; d * d <= n ; d += increments [ i ++ ]) { while ( n % d == 0 ) { factorization . push_back ( d ); n /= d ; } if ( i == 8 ) i = 0 ; } if ( n > 1 ) factorization . push_back ( n ); return factorization ; } If we continue exending this method to include even more primes, better percentages can be reached, but the skip lists will become larger. Precomputed primes \u00b6 Extending the wheel factorization method indefinitely, we will only be left with prime numbers to check. A good way of checking this is to precompute all prime numbers with the Sieve of Eratosthenes until $\\sqrt{n}$ , and test them individually. vector < long long > primes ; vector < long long > trial_division4 ( long long n ) { vector < long long > factorization ; for ( long long d : primes ) { if ( d * d > n ) break ; while ( n % d == 0 ) { factorization . push_back ( d ); n /= d ; } } if ( n > 1 ) factorization . push_back ( n ); return factorization ; } Fermat's factorization method \u00b6 We can write an odd composite number $n = p \\cdot q$ as the difference of two squares $n = a^2 - b^2$ : $$n = \\left(\\frac{p + q}{2}\\right)^2 - \\left(\\frac{p - q}{2}\\right)^2$$ Fermat's factorization method tries to exploit this fact by guessing the first square $a^2$ , and checking if the remaining part, $b^2 = a^2 - n$ , is also a square number. If it is, then we have found the factors $a - b$ and $a + b$ of $n$ . int fermat ( int n ) { int a = ceil ( sqrt ( n )); int b2 = a * a - n ; int b = round ( sqrt ( b2 )); while ( b * b != b2 ) { a = a + 1 ; b2 = a * a - n ; b = round ( sqrt ( b2 )); } return a - b ; } This factorization method can be very fast if the difference between the two factors $p$ and $q$ is small. The algorithm runs in $O(|p - q|)$ time. In practice though, this method is rarely used. Once factors become further apart, it is extremely slow. However, there are still a large number of optimization options regarding this approach. By looking at the squares $a^2$ modulo a fixed small number, it can be observed that certain values $a$ don't have to be viewed, since they cannot produce a square number $a^2 - n$ . Pollard's $p - 1$ method \u00b6 It is very likely that at least one factor of a number is $B$ -powersmooth for small $B$ . $B$ -powersmooth means that every prime power $d^k$ that divides $p-1$ is at most $B$ . E.g. the prime factorization of $4817191$ is $1303 \\cdot 3697$ . And the factors are $31$ -powersmooth and $16$ -powersmooth respectably, because $1303 - 1 = 2 \\cdot 3 \\cdot 7 \\cdot 31$ and $3697 - 1 = 2^4 \\cdot 3 \\cdot 7 \\cdot 11$ . In 1974 John Pollard invented a method to extracts $B$ -powersmooth factors from a composite number. The idea comes from Fermat's little theorem . Let a factorization of $n$ be $n = p \\cdot q$ . It says that if $a$ is coprime to $p$ , the following statement holds: $$a^{p - 1} \\equiv 1 \\pmod{p}$$ This also means that $${\\left(a^{(p - 1)}\\right)}^k \\equiv a^{k \\cdot (p - 1)} \\equiv 1 \\pmod{p}.$$ So for any $M$ with $p - 1 ~|~ M$ we know that $a^M \\equiv 1$ . This means that $a^M - 1 = p \\cdot r$ , and because of that also $p ~|~ \\gcd(a^M - 1, n)$ . Therefore, if $p - 1$ for a factor $p$ of $n$ divides $M$ , we can extract a factor using Euclid's algorithm . It is clear, that the smallest $M$ that is a multiple of every $B$ -powersmooth number is $\\text{lcm}(1,~2~,3~,4~,~\\dots,~B)$ . Or alternatively: $$M = \\prod_{\\text{prime } q \\le B} q^{\\lfloor \\log_q B \\rfloor}$$ Notice, if $p-1$ divides $M$ for all prime factors $p$ of $n$ , then $\\gcd(a^M - 1, n)$ will just be $n$ . In this case we don't receive a factor. Therefore, we will try to perform the $\\gcd$ multiple times, while we compute $M$ . Some composite numbers don't have $B$ -powersmooth factors for small $B$ . For example, the factors of the composite number $100~000~000~000~000~493 = 763~013 \\cdot 131~059~365~961$ are $190~753$ -powersmooth and $1~092~161~383$ -powersmooth. We will have to choose $B >= 190~753$ to factorize the number. In the following implementation we start with $B = 10$ and increase $B$ after each each iteration. long long pollards_p_minus_1 ( long long n ) { int B = 10 ; long long g = 1 ; while ( B <= 1000000 && g < n ) { long long a = 2 + rand () % ( n - 3 ); g = gcd ( a , n ); if ( g > 1 ) return g ; // compute a^M for ( int p : primes ) { if ( p >= B ) continue ; long long p_power = 1 ; while ( p_power * p <= B ) p_power *= p ; a = power ( a , p_power , n ); g = gcd ( a - 1 , n ); if ( g > 1 && g < n ) return g ; } B *= 2 ; } return 1 ; } Observe that this is a probabilistic algorithm. A consequence of this is that there is a possibility of the algorithm being unable to find a factor at all. The complexity is $O(B \\log B \\log^2 n)$ per iteration. Pollard's rho algorithm \u00b6 Pollard's Rho Algorithm is yet another factorization algorithm from John Pollard. Let the prime factorization of a number be $n = p q$ . The algorithm looks at a pseudo-random sequence $\\{x_i\\} = \\{x_0,~f(x_0),~f(f(x_0)),~\\dots\\}$ where $f$ is a polynomial function, usually $f(x) = (x^2 + c) \\bmod n$ is chosen with $c = 1$ . In this instance, we are not interested in the sequence $\\{x_i\\}$ . We are more interested in the sequence $\\{x_i \\bmod p\\}$ . Since $f$ is a polynomial function, and all the values are in the range $[0;~p)$ , this sequence will eventually converge into a loop. The birthday paradox actually suggests that the expected number of elements is $O(\\sqrt{p})$ until the repetition starts. If $p$ is smaller than $\\sqrt{n}$ , the repetition will likely start in $O(\\sqrt[4]{n})$ . Here is a visualization of such a sequence $\\{x_i \\bmod p\\}$ with $n = 2206637$ , $p = 317$ , $x_0 = 2$ and $f(x) = x^2 + 1$ . From the form of the sequence you can see very clearly why the algorithm is called Pollard's $\\rho$ algorithm. Yet, there is still an open question. How can we exploit the properties of the sequence $\\{x_i \\bmod p\\}$ to our advantage without even knowing the number $p$ itself? It's actually quite easy. There is a cycle in the sequence $\\{x_i \\bmod p\\}_{i \\le j}$ if and only if there are two indices $s, t \\le j$ such that $x_s \\equiv x_t \\bmod p$ . This equation can be rewritten as $x_s - x_t \\equiv 0 \\bmod p$ which is the same as $p ~|~ \\gcd(x_s - x_t, n)$ . Therefore, if we find two indices $s$ and $t$ with $g = \\gcd(x_s - x_t, n) > 1$ , we have found a cycle and also a factor $g$ of $n$ . It is possible that $g = n$ . In this case we haven't found a proper factor, so we must repeat the algorithm with a different parameter (different starting value $x_0$ , different constant $c$ in the polynomial function $f$ ). To find the cycle, we can use any common cycle detection algorithm. Floyd's cycle-finding algorithm \u00b6 This algorithm finds a cycle by using two pointers moving over the sequence at differing speeds. During each iteration, the first pointer will advance one element over, while the second pointer advances to every other element. Using this idea it is easy to observe that if there is a cycle, at some point the second pointer will come around to meet the first one during the loops. If the cycle length is $\\lambda$ and the $\\mu$ is the first index at which the cycle starts, then the algorithm will run in $O(\\lambda + \\mu)$ time. This algorithm is also known as the Tortoise and Hare algorithm , based on the tale in which a tortoise (the slow pointer) and a hare (the faster pointer) have a race. It is actually possible to determine the parameter $\\lambda$ and $\\mu$ using this algorithm (also in $O(\\lambda + \\mu)$ time and $O(1)$ space). When a cycle is detected, the algorithm will return 'True'. If the sequence doesn't have a cycle, then the function will loop endlessly. However, using Pollard's Rho Algorithm, this can be prevented. function floyd(f, x0): tortoise = x0 hare = f(x0) while tortoise != hare: tortoise = f(tortoise) hare = f(f(hare)) return true Implementation \u00b6 First, here is an implementation using the Floyd's cycle-finding algorithm . The algorithm generally runs in $O(\\sqrt[4]{n} \\log(n))$ time. long long mult ( long long a , long long b , long long mod ) { return ( __int128 ) a * b % mod ; } long long f ( long long x , long long c , long long mod ) { return ( mult ( x , x , mod ) + c ) % mod ; } long long rho ( long long n , long long x0 = 2 , long long c = 1 ) { long long x = x0 ; long long y = x0 ; long long g = 1 ; while ( g == 1 ) { x = f ( x , c , n ); y = f ( y , c , n ); y = f ( y , c , n ); g = gcd ( abs ( x - y ), n ); } return g ; } The following table shows the values of $x$ and $y$ during the algorithm for $n = 2206637$ , $x_0 = 2$ and $c = 1$ . $$ \\newcommand\\T{\\Rule{0pt}{1em}{.3em}} \\begin{array}{|l|l|l|l|l|l|} \\hline i & x_i \\bmod n & x_{2i} \\bmod n & x_i \\bmod 317 & x_{2i} \\bmod 317 & \\gcd(x_i - x_{2i}, n) \\\\ \\hline 0 & 2 & 2 & 2 & 2 & - \\\\ 1 & 5 & 26 & 5 & 26 & 1 \\\\ 2 & 26 & 458330 & 26 & 265 & 1 \\\\ 3 & 677 & 1671573 & 43 & 32 & 1 \\\\ 4 & 458330 & 641379 & 265 & 88 & 1 \\\\ 5 & 1166412 & 351937 & 169 & 67 & 1 \\\\ 6 & 1671573 & 1264682 & 32 & 169 & 1 \\\\ 7 & 2193080 & 2088470 & 74 & 74 & 317 \\\\ \\hline \\end{array}$$ The implementation uses a function mult , that multiplies two integers $\\le 10^{18}$ without overflow by using a GCC's type __int128 for 128-bit integer. If GCC is not available, you can using a similar idea as binary exponentiation . long long mult ( long long a , long long b , long long mod ) { long long result = 0 ; while ( b ) { if ( b & 1 ) result = ( result + a ) % mod ; a = ( a + a ) % mod ; b >>= 1 ; } return result ; } Alternatively you can also implement the Montgomery multiplication . As stated previously, if $n$ is composite and the algorithm returns $n$ as factor, you have to repeat the procedure with different parameters $x_0$ and $c$ . E.g. the choice $x_0 = c = 1$ will not factor $25 = 5 \\cdot 5$ . The algorithm will return $25$ . However, the choice $x_0 = 1$ , $c = 2$ will factor it. Brent's algorithm \u00b6 Brent implements a similar method to Floyd, using two pointers. The difference being that instead of advancing the pointers by one and two places respectively, they are advanced by powers of two. As soon as $2^i$ is greater than $\\lambda$ and $\\mu$ , we will find the cycle. function floyd(f, x0): tortoise = x0 hare = f(x0) l = 1 while tortoise != hare: tortoise = hare repeat l times: hare = f(hare) if tortoise == hare: return true l *= 2 return true Brent's algorithm also runs in linear time, but is generally faster than Floyd's, since it uses less evaluations of the function $f$ . Implementation \u00b6 The straightforward implementation of Brent's algorithm can be sped up by omitting the terms $x_l - x_k$ if $k < \\frac{3 \\cdot l}{2}$ . In addition, instead of performing the $\\gcd$ computation at every step, we multiply the terms and only actually check $\\gcd$ every few steps and backtrack if overshot. long long brent ( long long n , long long x0 = 2 , long long c = 1 ) { long long x = x0 ; long long g = 1 ; long long q = 1 ; long long xs , y ; int m = 128 ; int l = 1 ; while ( g == 1 ) { y = x ; for ( int i = 1 ; i < l ; i ++ ) x = f ( x , c , n ); int k = 0 ; while ( k < l && g == 1 ) { xs = x ; for ( int i = 0 ; i < m && i < l - k ; i ++ ) { x = f ( x , c , n ); q = mult ( q , abs ( y - x ), n ); } g = gcd ( q , n ); k += m ; } l *= 2 ; } if ( g == n ) { do { xs = f ( xs , c , n ); g = gcd ( abs ( xs - y ), n ); } while ( g == 1 ); } return g ; } The combination of a trial division for small prime numbers together with Brent's version of Pollard's rho algorithm makes a very powerful factorization algorithm. Practice Problems \u00b6 SPOJ - FACT0 SPOJ - FACT1 SPOJ - FACT2 GCPC 15 - Divisions","title":"Integer factorization"},{"location":"algebra/factorization.html#integer-factorization","text":"In this article we list several algorithms for the factorization of integers, each of which can be either fast or varying levels of slow depending on their input. Notice, if the number that you want to factorize is actually a prime number, most of the algorithms will run very slowly. This is especially true for Fermat's, Pollard's p-1 and Pollard's rho factorization algorithms. Therefore, it makes the most sense to perform a probabilistic (or a fast deterministic) primality test before trying to factorize the number.","title":"Integer factorization"},{"location":"algebra/factorization.html#trial-division","text":"This is the most basic algorithm to find a prime factorization. We divide by each possible divisor $d$ . It can be observed that it is impossible for all prime factors of a composite number $n$ to be bigger than $\\sqrt{n}$ . Therefore, we only need to test the divisors $2 \\le d \\le \\sqrt{n}$ , which gives us the prime factorization in $O(\\sqrt{n})$ . (This is pseudo-polynomial time , i.e. polynomial in the value of the input but exponential in the number of bits of the input.) The smallest divisor must be a prime number. We remove the factored number, and continue the process. If we cannot find any divisor in the range $[2; \\sqrt{n}]$ , then the number itself has to be prime. vector < long long > trial_division1 ( long long n ) { vector < long long > factorization ; for ( long long d = 2 ; d * d <= n ; d ++ ) { while ( n % d == 0 ) { factorization . push_back ( d ); n /= d ; } } if ( n > 1 ) factorization . push_back ( n ); return factorization ; }","title":"Trial division"},{"location":"algebra/factorization.html#wheel-factorization","text":"This is an optimization of the trial division. Once we know that the number is not divisible by 2, we don't need to check other even numbers. This leaves us with only $50\\%$ of the numbers to check. After factoring out 2, and getting an odd number, we can simply start with 3 and only count other odd numbers. vector < long long > trial_division2 ( long long n ) { vector < long long > factorization ; while ( n % 2 == 0 ) { factorization . push_back ( 2 ); n /= 2 ; } for ( long long d = 3 ; d * d <= n ; d += 2 ) { while ( n % d == 0 ) { factorization . push_back ( d ); n /= d ; } } if ( n > 1 ) factorization . push_back ( n ); return factorization ; } This method can be extended further. If the number is not divisible by 3, we can also ignore all other multiples of 3 in the future computations. So we only need to check the numbers $5, 7, 11, 13, 17, 19, 23, \\dots$ . We can observe a pattern of these remaining numbers. We need to check all numbers with $d \\bmod 6 = 1$ and $d \\bmod 6 = 5$ . So this leaves us with only $33.3\\%$ percent of the numbers to check. We can implement this by factoring out the primes 2 and 3 first, after which we start with 5 and only count remainders $1$ and $5$ modulo $6$ . Here is an implementation for the prime number 2, 3 and 5. It is convenient to store the skipping strides in an array. vector < long long > trial_division3 ( long long n ) { vector < long long > factorization ; for ( int d : { 2 , 3 , 5 }) { while ( n % d == 0 ) { factorization . push_back ( d ); n /= d ; } } static array < int , 8 > increments = { 4 , 2 , 4 , 2 , 4 , 6 , 2 , 6 }; int i = 0 ; for ( long long d = 7 ; d * d <= n ; d += increments [ i ++ ]) { while ( n % d == 0 ) { factorization . push_back ( d ); n /= d ; } if ( i == 8 ) i = 0 ; } if ( n > 1 ) factorization . push_back ( n ); return factorization ; } If we continue exending this method to include even more primes, better percentages can be reached, but the skip lists will become larger.","title":"Wheel factorization"},{"location":"algebra/factorization.html#precomputed-primes","text":"Extending the wheel factorization method indefinitely, we will only be left with prime numbers to check. A good way of checking this is to precompute all prime numbers with the Sieve of Eratosthenes until $\\sqrt{n}$ , and test them individually. vector < long long > primes ; vector < long long > trial_division4 ( long long n ) { vector < long long > factorization ; for ( long long d : primes ) { if ( d * d > n ) break ; while ( n % d == 0 ) { factorization . push_back ( d ); n /= d ; } } if ( n > 1 ) factorization . push_back ( n ); return factorization ; }","title":"Precomputed primes"},{"location":"algebra/factorization.html#fermats-factorization-method","text":"We can write an odd composite number $n = p \\cdot q$ as the difference of two squares $n = a^2 - b^2$ : $$n = \\left(\\frac{p + q}{2}\\right)^2 - \\left(\\frac{p - q}{2}\\right)^2$$ Fermat's factorization method tries to exploit this fact by guessing the first square $a^2$ , and checking if the remaining part, $b^2 = a^2 - n$ , is also a square number. If it is, then we have found the factors $a - b$ and $a + b$ of $n$ . int fermat ( int n ) { int a = ceil ( sqrt ( n )); int b2 = a * a - n ; int b = round ( sqrt ( b2 )); while ( b * b != b2 ) { a = a + 1 ; b2 = a * a - n ; b = round ( sqrt ( b2 )); } return a - b ; } This factorization method can be very fast if the difference between the two factors $p$ and $q$ is small. The algorithm runs in $O(|p - q|)$ time. In practice though, this method is rarely used. Once factors become further apart, it is extremely slow. However, there are still a large number of optimization options regarding this approach. By looking at the squares $a^2$ modulo a fixed small number, it can be observed that certain values $a$ don't have to be viewed, since they cannot produce a square number $a^2 - n$ .","title":"Fermat's factorization method"},{"location":"algebra/factorization.html#pollards-p-1-method","text":"It is very likely that at least one factor of a number is $B$ -powersmooth for small $B$ . $B$ -powersmooth means that every prime power $d^k$ that divides $p-1$ is at most $B$ . E.g. the prime factorization of $4817191$ is $1303 \\cdot 3697$ . And the factors are $31$ -powersmooth and $16$ -powersmooth respectably, because $1303 - 1 = 2 \\cdot 3 \\cdot 7 \\cdot 31$ and $3697 - 1 = 2^4 \\cdot 3 \\cdot 7 \\cdot 11$ . In 1974 John Pollard invented a method to extracts $B$ -powersmooth factors from a composite number. The idea comes from Fermat's little theorem . Let a factorization of $n$ be $n = p \\cdot q$ . It says that if $a$ is coprime to $p$ , the following statement holds: $$a^{p - 1} \\equiv 1 \\pmod{p}$$ This also means that $${\\left(a^{(p - 1)}\\right)}^k \\equiv a^{k \\cdot (p - 1)} \\equiv 1 \\pmod{p}.$$ So for any $M$ with $p - 1 ~|~ M$ we know that $a^M \\equiv 1$ . This means that $a^M - 1 = p \\cdot r$ , and because of that also $p ~|~ \\gcd(a^M - 1, n)$ . Therefore, if $p - 1$ for a factor $p$ of $n$ divides $M$ , we can extract a factor using Euclid's algorithm . It is clear, that the smallest $M$ that is a multiple of every $B$ -powersmooth number is $\\text{lcm}(1,~2~,3~,4~,~\\dots,~B)$ . Or alternatively: $$M = \\prod_{\\text{prime } q \\le B} q^{\\lfloor \\log_q B \\rfloor}$$ Notice, if $p-1$ divides $M$ for all prime factors $p$ of $n$ , then $\\gcd(a^M - 1, n)$ will just be $n$ . In this case we don't receive a factor. Therefore, we will try to perform the $\\gcd$ multiple times, while we compute $M$ . Some composite numbers don't have $B$ -powersmooth factors for small $B$ . For example, the factors of the composite number $100~000~000~000~000~493 = 763~013 \\cdot 131~059~365~961$ are $190~753$ -powersmooth and $1~092~161~383$ -powersmooth. We will have to choose $B >= 190~753$ to factorize the number. In the following implementation we start with $B = 10$ and increase $B$ after each each iteration. long long pollards_p_minus_1 ( long long n ) { int B = 10 ; long long g = 1 ; while ( B <= 1000000 && g < n ) { long long a = 2 + rand () % ( n - 3 ); g = gcd ( a , n ); if ( g > 1 ) return g ; // compute a^M for ( int p : primes ) { if ( p >= B ) continue ; long long p_power = 1 ; while ( p_power * p <= B ) p_power *= p ; a = power ( a , p_power , n ); g = gcd ( a - 1 , n ); if ( g > 1 && g < n ) return g ; } B *= 2 ; } return 1 ; } Observe that this is a probabilistic algorithm. A consequence of this is that there is a possibility of the algorithm being unable to find a factor at all. The complexity is $O(B \\log B \\log^2 n)$ per iteration.","title":"Pollard's p - 1 method"},{"location":"algebra/factorization.html#pollards-rho-algorithm","text":"Pollard's Rho Algorithm is yet another factorization algorithm from John Pollard. Let the prime factorization of a number be $n = p q$ . The algorithm looks at a pseudo-random sequence $\\{x_i\\} = \\{x_0,~f(x_0),~f(f(x_0)),~\\dots\\}$ where $f$ is a polynomial function, usually $f(x) = (x^2 + c) \\bmod n$ is chosen with $c = 1$ . In this instance, we are not interested in the sequence $\\{x_i\\}$ . We are more interested in the sequence $\\{x_i \\bmod p\\}$ . Since $f$ is a polynomial function, and all the values are in the range $[0;~p)$ , this sequence will eventually converge into a loop. The birthday paradox actually suggests that the expected number of elements is $O(\\sqrt{p})$ until the repetition starts. If $p$ is smaller than $\\sqrt{n}$ , the repetition will likely start in $O(\\sqrt[4]{n})$ . Here is a visualization of such a sequence $\\{x_i \\bmod p\\}$ with $n = 2206637$ , $p = 317$ , $x_0 = 2$ and $f(x) = x^2 + 1$ . From the form of the sequence you can see very clearly why the algorithm is called Pollard's $\\rho$ algorithm. Yet, there is still an open question. How can we exploit the properties of the sequence $\\{x_i \\bmod p\\}$ to our advantage without even knowing the number $p$ itself? It's actually quite easy. There is a cycle in the sequence $\\{x_i \\bmod p\\}_{i \\le j}$ if and only if there are two indices $s, t \\le j$ such that $x_s \\equiv x_t \\bmod p$ . This equation can be rewritten as $x_s - x_t \\equiv 0 \\bmod p$ which is the same as $p ~|~ \\gcd(x_s - x_t, n)$ . Therefore, if we find two indices $s$ and $t$ with $g = \\gcd(x_s - x_t, n) > 1$ , we have found a cycle and also a factor $g$ of $n$ . It is possible that $g = n$ . In this case we haven't found a proper factor, so we must repeat the algorithm with a different parameter (different starting value $x_0$ , different constant $c$ in the polynomial function $f$ ). To find the cycle, we can use any common cycle detection algorithm.","title":"Pollard's rho algorithm"},{"location":"algebra/factorization.html#floyds-cycle-finding-algorithm","text":"This algorithm finds a cycle by using two pointers moving over the sequence at differing speeds. During each iteration, the first pointer will advance one element over, while the second pointer advances to every other element. Using this idea it is easy to observe that if there is a cycle, at some point the second pointer will come around to meet the first one during the loops. If the cycle length is $\\lambda$ and the $\\mu$ is the first index at which the cycle starts, then the algorithm will run in $O(\\lambda + \\mu)$ time. This algorithm is also known as the Tortoise and Hare algorithm , based on the tale in which a tortoise (the slow pointer) and a hare (the faster pointer) have a race. It is actually possible to determine the parameter $\\lambda$ and $\\mu$ using this algorithm (also in $O(\\lambda + \\mu)$ time and $O(1)$ space). When a cycle is detected, the algorithm will return 'True'. If the sequence doesn't have a cycle, then the function will loop endlessly. However, using Pollard's Rho Algorithm, this can be prevented. function floyd(f, x0): tortoise = x0 hare = f(x0) while tortoise != hare: tortoise = f(tortoise) hare = f(f(hare)) return true","title":"Floyd's cycle-finding algorithm"},{"location":"algebra/factorization.html#implementation","text":"First, here is an implementation using the Floyd's cycle-finding algorithm . The algorithm generally runs in $O(\\sqrt[4]{n} \\log(n))$ time. long long mult ( long long a , long long b , long long mod ) { return ( __int128 ) a * b % mod ; } long long f ( long long x , long long c , long long mod ) { return ( mult ( x , x , mod ) + c ) % mod ; } long long rho ( long long n , long long x0 = 2 , long long c = 1 ) { long long x = x0 ; long long y = x0 ; long long g = 1 ; while ( g == 1 ) { x = f ( x , c , n ); y = f ( y , c , n ); y = f ( y , c , n ); g = gcd ( abs ( x - y ), n ); } return g ; } The following table shows the values of $x$ and $y$ during the algorithm for $n = 2206637$ , $x_0 = 2$ and $c = 1$ . $$ \\newcommand\\T{\\Rule{0pt}{1em}{.3em}} \\begin{array}{|l|l|l|l|l|l|} \\hline i & x_i \\bmod n & x_{2i} \\bmod n & x_i \\bmod 317 & x_{2i} \\bmod 317 & \\gcd(x_i - x_{2i}, n) \\\\ \\hline 0 & 2 & 2 & 2 & 2 & - \\\\ 1 & 5 & 26 & 5 & 26 & 1 \\\\ 2 & 26 & 458330 & 26 & 265 & 1 \\\\ 3 & 677 & 1671573 & 43 & 32 & 1 \\\\ 4 & 458330 & 641379 & 265 & 88 & 1 \\\\ 5 & 1166412 & 351937 & 169 & 67 & 1 \\\\ 6 & 1671573 & 1264682 & 32 & 169 & 1 \\\\ 7 & 2193080 & 2088470 & 74 & 74 & 317 \\\\ \\hline \\end{array}$$ The implementation uses a function mult , that multiplies two integers $\\le 10^{18}$ without overflow by using a GCC's type __int128 for 128-bit integer. If GCC is not available, you can using a similar idea as binary exponentiation . long long mult ( long long a , long long b , long long mod ) { long long result = 0 ; while ( b ) { if ( b & 1 ) result = ( result + a ) % mod ; a = ( a + a ) % mod ; b >>= 1 ; } return result ; } Alternatively you can also implement the Montgomery multiplication . As stated previously, if $n$ is composite and the algorithm returns $n$ as factor, you have to repeat the procedure with different parameters $x_0$ and $c$ . E.g. the choice $x_0 = c = 1$ will not factor $25 = 5 \\cdot 5$ . The algorithm will return $25$ . However, the choice $x_0 = 1$ , $c = 2$ will factor it.","title":"Implementation"},{"location":"algebra/factorization.html#brents-algorithm","text":"Brent implements a similar method to Floyd, using two pointers. The difference being that instead of advancing the pointers by one and two places respectively, they are advanced by powers of two. As soon as $2^i$ is greater than $\\lambda$ and $\\mu$ , we will find the cycle. function floyd(f, x0): tortoise = x0 hare = f(x0) l = 1 while tortoise != hare: tortoise = hare repeat l times: hare = f(hare) if tortoise == hare: return true l *= 2 return true Brent's algorithm also runs in linear time, but is generally faster than Floyd's, since it uses less evaluations of the function $f$ .","title":"Brent's algorithm"},{"location":"algebra/factorization.html#implementation_1","text":"The straightforward implementation of Brent's algorithm can be sped up by omitting the terms $x_l - x_k$ if $k < \\frac{3 \\cdot l}{2}$ . In addition, instead of performing the $\\gcd$ computation at every step, we multiply the terms and only actually check $\\gcd$ every few steps and backtrack if overshot. long long brent ( long long n , long long x0 = 2 , long long c = 1 ) { long long x = x0 ; long long g = 1 ; long long q = 1 ; long long xs , y ; int m = 128 ; int l = 1 ; while ( g == 1 ) { y = x ; for ( int i = 1 ; i < l ; i ++ ) x = f ( x , c , n ); int k = 0 ; while ( k < l && g == 1 ) { xs = x ; for ( int i = 0 ; i < m && i < l - k ; i ++ ) { x = f ( x , c , n ); q = mult ( q , abs ( y - x ), n ); } g = gcd ( q , n ); k += m ; } l *= 2 ; } if ( g == n ) { do { xs = f ( xs , c , n ); g = gcd ( abs ( xs - y ), n ); } while ( g == 1 ); } return g ; } The combination of a trial division for small prime numbers together with Brent's version of Pollard's rho algorithm makes a very powerful factorization algorithm.","title":"Implementation"},{"location":"algebra/factorization.html#practice-problems","text":"SPOJ - FACT0 SPOJ - FACT1 SPOJ - FACT2 GCPC 15 - Divisions","title":"Practice Problems"},{"location":"algebra/fft.html","text":"Fast Fourier transform \u00b6 In this article we will discuss an algorithm that allows us to multiply two polynomials of length $n$ in $O(n \\log n)$ time, which is better than the trivial multiplication which takes $O(n^2)$ time. Obviously also multiplying two long numbers can be reduced to multiplying polynomials, so also two long numbers can be multiplied in $O(n \\log n)$ time (where $n$ is the number of digits in the numbers). The discovery of the Fast Fourier transformation (FFT) is attributed to Cooley and Tukey, who published an algorithm in 1965. But in fact the FFT has been discovered repeatedly before, but the importance of it was not understood before the inventions of modern computers. Some researchers attribute the discovery of the FFT to Runge and K\u00f6nig in 1924. But actually Gauss developed such a method already in 1805, but never published it. Notice, that the FFT algorithm presented here runs in $O(n \\log n)$ time, but it doesn't work for multiplying arbitrary big polynomials with arbitrary large coefficients or for multiplying arbitrary big integers. It can easily handle polynomials of size $10^5$ with small coefficients, or multiplying two numbers of size $10^6$ , which is usually enough for solving competitive programming problems. Beyond the scale of multiplying numbers with $10^6$ bits, the range and precision of the floating point numbers used during the computation will not be enough to give accurate final results, though there are more complex variations that can perform arbitrary large polynomial/integer multiplications. E.g. in 1971 Sch\u00f6nhage and Strasser developed a variation for multiplying arbitrary large numbers that applies the FFT recursively in rings structures running in $O(n \\log n \\log \\log n)$ . And recently (in 2019) Harvey and van der Hoeven published an algorithm that runs in true $O(n \\log n)$ . Discrete Fourier transform \u00b6 Let there be a polynomial of degree $n - 1$ : $$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}$$ Without loss of generality we assume that $n$ - the number of coefficients - is a power of $2$ . If $n$ is not a power of $2$ , then we simply add the missing terms $a_i x^i$ and set the coefficients $a_i$ to $0$ . The theory of complex numbers tells us that the equation $x^n = 1$ has $n$ complex solutions (called the $n$ -th roots of unity), and the solutions are of the form $w_{n, k} = e^{\\frac{2 k \\pi i}{n}}$ with $k = 0 \\dots n-1$ . Additionally these complex numbers have some very interesting properties: e.g. the principal $n$ -th root $w_n = w_{n, 1} = e^{\\frac{2 \\pi i}{n}}$ can be used to describe all other $n$ -th roots: $w_{n, k} = (w_n)^k$ . The discrete Fourier transform (DFT) of the polynomial $A(x)$ (or equivalently the vector of coefficients $(a_0, a_1, \\dots, a_{n-1})$ is defined as the values of the polynomial at the points $x = w_{n, k}$ , i.e. it is the vector: $$\\begin{align} \\text{DFT}(a_0, a_1, \\dots, a_{n-1}) &= (y_0, y_1, \\dots, y_{n-1}) \\\\ &= (A(w_{n, 0}), A(w_{n, 1}), \\dots, A(w_{n, n-1})) \\\\ &= (A(w_n^0), A(w_n^1), \\dots, A(w_n^{n-1})) \\end{align}$$ Similarly the inverse discrete Fourier transform is defined: The inverse DFT of values of the polynomial $(y_0, y_1, \\dots, y_{n-1})$ are the coefficients of the polynomial $(a_0, a_1, \\dots, a_{n-1})$ . $$\\text{InverseDFT}(y_0, y_1, \\dots, y_{n-1}) = (a_0, a_1, \\dots, a_{n-1})$$ Thus, if a direct DFT computes the values of the polynomial at the points at the $n$ -th roots, the inverse DFT can restore the coefficients of the polynomial using those values. Application of the DFT: fast multiplication of polynomials \u00b6 Let there be two polynomials $A$ and $B$ . We compute the DFT for each of them: $\\text{DFT}(A)$ and $\\text{DFT}(B)$ . What happens if we multiply these polynomials? Obviously at each point the values are simply multiplied, i.e. $$(A \\cdot B)(x) = A(x) \\cdot B(x).$$ This means that if we multiply the vectors $\\text{DFT}(A)$ and $\\text{DFT}(B)$ - by multiplying each element of one vector by the corresponding element of the other vector - then we get nothing other than the DFT of the polynomial $\\text{DFT}(A \\cdot B)$ : $$\\text{DFT}(A \\cdot B) = \\text{DFT}(A) \\cdot \\text{DFT}(B)$$ Finally, applying the inverse DFT, we obtain: $$A \\cdot B = \\text{InverseDFT}(\\text{DFT}(A) \\cdot \\text{DFT}(B))$$ On the right the product of the two DFTs we mean the pairwise product of the vector elements. This can be computed in $O(n)$ time. If we can compute the DFT and the inverse DFT in $O(n \\log n)$ , then we can compute the product of the two polynomials (and consequently also two long numbers) with the same time complexity. It should be noted, that the two polynomials should have the same degree. Otherwise the two result vectors of the DFT have different length. We can accomplish this by adding coefficients with the value $0$ . And also, since the result of the product of two polynomials is a polynomial of degree $2 (n - 1)$ , we have to double the degrees of each polynomial (again by padding $0$ s). From a vector with $n$ values we cannot reconstruct the desired polynomial with $2n - 1$ coefficients. Fast Fourier Transform \u00b6 The fast Fourier transform is a method that allows computing the DFT in $O(n \\log n)$ time. The basic idea of the FFT is to apply divide and conquer. We divide the coefficient vector of the polynomial into two vectors, recursively compute the DFT for each of them, and combine the results to compute the DFT of the complete polynomial. So let there be a polynomial $A(x)$ with degree $n - 1$ , where $n$ is a power of $2$ , and $n > 1$ : $$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}$$ We divide it into two smaller polynomials, the one containing only the coefficients of the even positions, and the one containing the coefficients of the odd positions: $$\\begin{align} A_0(x) &= a_0 x^0 + a_2 x^1 + \\dots + a_{n-2} x^{\\frac{n}{2}-1} \\\\ A_1(x) &= a_1 x^0 + a_3 x^1 + \\dots + a_{n-1} x^{\\frac{n}{2}-1} \\end{align}$$ It is easy to see that $$A(x) = A_0(x^2) + x A_1(x^2).$$ The polynomials $A_0$ and $A_1$ are only half as much coefficients as the polynomial $A$ . If we can compute the $\\text{DFT}(A)$ in linear time using $\\text{DFT}(A_0)$ and $\\text{DFT}(A_1)$ , then we get the recurrence $T_{\\text{DFT}}(n) = 2 T_{\\text{DFT}}\\left(\\frac{n}{2}\\right) + O(n)$ for the time complexity, which results in $T_{\\text{DFT}}(n) = O(n \\log n)$ by the master theorem . Let's learn how we can accomplish that. Suppose we have computed the vectors $\\left(y_k^0\\right)_{k=0}^{n/2-1} = \\text{DFT}(A_0)$ and $\\left(y_k^1\\right)_{k=0}^{n/2-1} = \\text{DFT}(A_1)$ . Let us find a expression for $\\left(y_k\\right)_{k=0}^{n-1} = \\text{DFT}(A)$ . For the first $\\frac{n}{2}$ values we can just use the previously noted equation $A(x) = A_0(x^2) + x A_1(x^2)$ : $$y_k = y_k^0 + w_n^k y_k^1, \\quad k = 0 \\dots \\frac{n}{2} - 1.$$ However for the second $\\frac{n}{2}$ values we need to find a slightly, different expression: $$\\begin{align} y_{k+n/2} &= A\\left(w_n^{k+n/2}\\right) \\\\ &= A_0\\left(w_n^{2k+n}\\right) + w_n^{k + n/2} A_1\\left(w_n^{2k+n}\\right) \\\\ &= A_0\\left(w_n^{2k} w_n^n\\right) + w_n^k w_n^{n/2} A_1\\left(w_n^{2k} w_n^n\\right) \\\\ &= A_0\\left(w_n^{2k}\\right) - w_n^k A_1\\left(w_n^{2k}\\right) \\\\ &= y_k^0 - w_n^k y_k^1 \\end{align}$$ Here we used again $A(x) = A_0(x^2) + x A_1(x^2)$ and the two identities $w_n^n = 1$ and $w_n^{n/2} = -1$ . Therefore we get the desired formulas for computing the whole vector $(y_k)$ : $$\\begin{align} y_k &= y_k^0 + w_n^k y_k^1, &\\quad k = 0 \\dots \\frac{n}{2} - 1, \\\\ y_{k+n/2} &= y_k^0 - w_n^k y_k^1, &\\quad k = 0 \\dots \\frac{n}{2} - 1. \\end{align}$$ (This pattern $a + b$ and $a - b$ is sometimes called a butterfly .) Thus we learned how to compute the DFT in $O(n \\log n)$ time. Inverse FFT \u00b6 Let the vector $(y_0, y_1, \\dots y_{n-1})$ - the values of polynomial $A$ of degree $n - 1$ in the points $x = w_n^k$ - be given. We want to restore the coefficients $(a_0, a_1, \\dots, a_{n-1})$ of the polynomial. This known problem is called interpolation , and there are general algorithms for solving it. But in this special case (since we know the values of the points at the roots of unity), we can obtains a much simpler algorithm (that is practically the same as the direct FFT). We can write the DFT, according to its definition, in the matrix form: $$ \\begin{pmatrix} w_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\ w_n^0 & w_n^1 & w_n^2 & w_n^3 & \\cdots & w_n^{n-1} \\\\ w_n^0 & w_n^2 & w_n^4 & w_n^6 & \\cdots & w_n^{2(n-1)} \\\\ w_n^0 & w_n^3 & w_n^6 & w_n^9 & \\cdots & w_n^{3(n-1)} \\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ w_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \\cdots & w_n^{(n-1)(n-1)} \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1} \\end{pmatrix} = \\begin{pmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1} \\end{pmatrix} $$ This matrix is called the Vandermonde matrix . Thus we can compute the vector $(a_0, a_1, \\dots, a_{n-1})$ by multiplying the vector $(y_0, y_1, \\dots y_{n-1})$ from the left with the inverse of the matrix: $$ \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1} \\end{pmatrix} = \\begin{pmatrix} w_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\ w_n^0 & w_n^1 & w_n^2 & w_n^3 & \\cdots & w_n^{n-1} \\\\ w_n^0 & w_n^2 & w_n^4 & w_n^6 & \\cdots & w_n^{2(n-1)} \\\\ w_n^0 & w_n^3 & w_n^6 & w_n^9 & \\cdots & w_n^{3(n-1)} \\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ w_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \\cdots & w_n^{(n-1)(n-1)} \\end{pmatrix}^{-1} \\begin{pmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1} \\end{pmatrix} $$ A quick check can verify that the inverse of the matrix has the following form: $$ \\frac{1}{n} \\begin{pmatrix} w_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\ w_n^0 & w_n^{-1} & w_n^{-2} & w_n^{-3} & \\cdots & w_n^{-(n-1)} \\\\ w_n^0 & w_n^{-2} & w_n^{-4} & w_n^{-6} & \\cdots & w_n^{-2(n-1)} \\\\ w_n^0 & w_n^{-3} & w_n^{-6} & w_n^{-9} & \\cdots & w_n^{-3(n-1)} \\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ w_n^0 & w_n^{-(n-1)} & w_n^{-2(n-1)} & w_n^{-3(n-1)} & \\cdots & w_n^{-(n-1)(n-1)} \\end{pmatrix} $$ Thus we obtain the formula: $$a_k = \\frac{1}{n} \\sum_{j=0}^{n-1} y_j w_n^{-k j}$$ Comparing this to the formula for $y_k$ $$y_k = \\sum_{j=0}^{n-1} a_j w_n^{k j},$$ we notice that these problems are almost the same, so the coefficients $a_k$ can be found by the same divide and conquer algorithm, as well as the direct FFT, only instead of $w_n^k$ we have to use $w_n^{-k}$ , and at the end we need to divide the resulting coefficients by $n$ . Thus the computation of the inverse DFT is almost the same as the calculation of the direct DFT, and it also can be performed in $O(n \\log n)$ time. Implementation \u00b6 Here we present a simple recursive implementation of the FFT and the inverse FFT, both in one function, since the difference between the forward and the inverse FFT are so minimal. To store the complex numbers we use the complex type in the C++ STL. using cd = complex < double > ; const double PI = acos ( -1 ); void fft ( vector < cd > & a , bool invert ) { int n = a . size (); if ( n == 1 ) return ; vector < cd > a0 ( n / 2 ), a1 ( n / 2 ); for ( int i = 0 ; 2 * i < n ; i ++ ) { a0 [ i ] = a [ 2 * i ]; a1 [ i ] = a [ 2 * i + 1 ]; } fft ( a0 , invert ); fft ( a1 , invert ); double ang = 2 * PI / n * ( invert ? -1 : 1 ); cd w ( 1 ), wn ( cos ( ang ), sin ( ang )); for ( int i = 0 ; 2 * i < n ; i ++ ) { a [ i ] = a0 [ i ] + w * a1 [ i ]; a [ i + n / 2 ] = a0 [ i ] - w * a1 [ i ]; if ( invert ) { a [ i ] /= 2 ; a [ i + n / 2 ] /= 2 ; } w *= wn ; } } The function gets passed a vector of coefficients, and the function will compute the DFT or inverse DFT and store the result again in this vector. The argument $\\text{invert}$ shows whether the direct or the inverse DFT should be computed. Inside the function we first check if the length of the vector is equal to one, if this is the case then we don't have to do anything. Otherwise we divide the vector $a$ into two vectors $a0$ and $a1$ and compute the DFT for both recursively. Then we initialize the value $wn$ and a variable $w$ , which will contain the current power of $wn$ . Then the values of the resulting DFT are computed using the above formulas. If the flag $\\text{invert}$ is set, then we replace $wn$ with $wn^{-1}$ , and each of the values of the result is divided by $2$ (since this will be done in each level of the recursion, this will end up dividing the final values by $n$ ). Using this function we can create a function for multiplying two polynomials : vector < int > multiply ( vector < int > const & a , vector < int > const & b ) { vector < cd > fa ( a . begin (), a . end ()), fb ( b . begin (), b . end ()); int n = 1 ; while ( n < a . size () + b . size ()) n <<= 1 ; fa . resize ( n ); fb . resize ( n ); fft ( fa , false ); fft ( fb , false ); for ( int i = 0 ; i < n ; i ++ ) fa [ i ] *= fb [ i ]; fft ( fa , true ); vector < int > result ( n ); for ( int i = 0 ; i < n ; i ++ ) result [ i ] = round ( fa [ i ]. real ()); return result ; } This function works with polynomials with integer coefficients, however you can also adjust it to work with other types. Since there is some error when working with complex numbers, we need round the resulting coefficients at the end. Finally the function for multiplying two long numbers practically doesn't differ from the function for multiplying polynomials. The only thing we have to do afterwards, is to normalize the number: int carry = 0 ; for ( int i = 0 ; i < n ; i ++ ) result [ i ] += carry ; carry = result [ i ] / 10 ; result [ i ] %= 10 ; } Since the length of the product of two numbers never exceed the total length of both numbers, the size of the vector is enough to perform all carry operations. Improved implementation: in-place computation \u00b6 To increase the efficiency we will switch from the recursive implementation to an iterative one. In the above recursive implementation we explicitly separated the vector $a$ into two vectors - the element on the even positions got assigned to one temporary vector, and the elements on odd positions to another. However if we reorder the elements in a certain way, we don't need to create these temporary vectors (i.e. all the calculations can be done \"in-place\", right in the vector $A$ itself). Note that at the first recursion level, the elements whose lowest bit of the position was zero got assigned to the vector $a_0$ , and the ones with a one as the lowest bit of the position got assigned to $a_1$ . In the second recursion level the same thing happens, but with the second lowest bit instead, etc. Therefore if we reverse the bits of the position of each coefficient, and sort them by these reversed values, we get the desired order (it is called the bit-reversal permutation). For example the desired order for $n = 8$ has the form: $$a = \\bigg\\{ \\Big[ (a_0, a_4), (a_2, a_6) \\Big], \\Big[ (a_1, a_5), (a_3, a_7) \\Big] \\bigg\\}$$ Indeed in the first recursion level (surrounded by curly braces), the vector gets divided into two parts $[a_0, a_2, a_4, a_6]$ and $[a_1, a_3, a_5, a_7]$ . As we see, in the bit-reversal permutation this corresponds to simply dividing the vector into two halves: the first $\\frac{n}{2}$ elements and the last $\\frac{n}{2}$ elements. Then there is a recursive call for each halve. Let the resulting DFT for each of them be returned in place of the elements themselves (i.e. the first half and the second half of the vector $a$ respectively. $$a = \\bigg\\{ \\Big[y_0^0, y_1^0, y_2^0, y_3^0\\Big], \\Big[y_0^1, y_1^1, y_2^1, y_3^1 \\Big] \\bigg\\}$$ Now we want to combine the two DFTs into one for the complete vector. The order of the elements is ideal, and we can also perform the union directly in this vector. We can take the elements $y_0^0$ and $y_0^1$ and perform the butterfly transform. The place of the resulting two values is the same as the place of the two initial values, so we get: $$a = \\bigg\\{ \\Big[y_0^0 + w_n^0 y_0^1, y_1^0, y_2^0, y_3^0\\Big], \\Big[y_0^0 - w_n^0 y_0^1, y_1^1, y_2^1, y_3^1\\Big] \\bigg\\}$$ Similarly we can compute the butterfly transform of $y_1^0$ and $y_1^1$ and put the results in their place, and so on. As a result we get: $$a = \\bigg\\{ \\Big[y_0^0 + w_n^0 y_0^1, y_1^0 + w_n^1 y_1^1, y_2^0 + w_n^2 y_2^1, y_3^0 + w_n^3 y_3^1\\Big], \\Big[y_0^0 - w_n^0 y_0^1, y_1^0 - w_n^1 y_1^1, y_2^0 - w_n^2 y_2^1, y_3^0 - w_n^3 y_3^1\\Big] \\bigg\\}$$ Thus we computed the required DFT from the vector $a$ . Here we described the process of computing the DFT only at the first recursion level, but the same works obviously also for all other levels. Thus, after applying the bit-reversal permutation, we can compute the DFT in-place, without any additional memory. This additionally allows us to get rid of the recursion. We just start at the lowest level, i.e. we divide the vector into pairs and apply the butterfly transform to them. This results with the vector $a$ with the work of the last level applied. In the next step we divide the vector into vectors of size $4$ , and again apply the butterfly transform, which gives us the DFT for each block of size $4$ . And so on. Finally in the last step we obtained the result of the DFTs of both halves of $a$ , and by applying the butterfly transform we obtain the DFT for the complete vector $a$ . using cd = complex < double > ; const double PI = acos ( -1 ); int reverse ( int num , int lg_n ) { int res = 0 ; for ( int i = 0 ; i < lg_n ; i ++ ) { if ( num & ( 1 << i )) res |= 1 << ( lg_n - 1 - i ); } return res ; } void fft ( vector < cd > & a , bool invert ) { int n = a . size (); int lg_n = 0 ; while (( 1 << lg_n ) < n ) lg_n ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < reverse ( i , lg_n )) swap ( a [ i ], a [ reverse ( i , lg_n )]); } for ( int len = 2 ; len <= n ; len <<= 1 ) { double ang = 2 * PI / len * ( invert ? -1 : 1 ); cd wlen ( cos ( ang ), sin ( ang )); for ( int i = 0 ; i < n ; i += len ) { cd w ( 1 ); for ( int j = 0 ; j < len / 2 ; j ++ ) { cd u = a [ i + j ], v = a [ i + j + len / 2 ] * w ; a [ i + j ] = u + v ; a [ i + j + len / 2 ] = u - v ; w *= wlen ; } } } if ( invert ) { for ( cd & x : a ) x /= n ; } } At first we apply the bit-reversal permutation by swapping the each element with the element of the reversed position. Then the $\\log n - 1$ states of the algorithm we compute the DFT for each block of the corresponding size $\\text{len}$ . For all those blocks we have the same root of unity $\\text{wlen}$ . We iterate all blocks and perform the butterfly transform on each of them. We can further optimize the reversal of the bits. In the previous implementation we iterated all bits of the index and created the bitwise reversed index. However we can reverse the bits in a different way. Suppose that $j$ already contains the reverse of $i$ . Then by to go to $i + 1$ , we have to increment $i$ , and we also have to increment $j$ , but in a \"reversed\" number system. Adding one in the conventional binary system is equivalent to flip all tailing ones into zeros and flipping the zero right before them into a one. Equivalently in the \"reversed\" number system, we flip all leading ones, and the also the next zero. Thus we get the following implementation: using cd = complex < double > ; const double PI = acos ( -1 ); void fft ( vector < cd > & a , bool invert ) { int n = a . size (); for ( int i = 1 , j = 0 ; i < n ; i ++ ) { int bit = n >> 1 ; for (; j & bit ; bit >>= 1 ) j ^= bit ; j ^= bit ; if ( i < j ) swap ( a [ i ], a [ j ]); } for ( int len = 2 ; len <= n ; len <<= 1 ) { double ang = 2 * PI / len * ( invert ? -1 : 1 ); cd wlen ( cos ( ang ), sin ( ang )); for ( int i = 0 ; i < n ; i += len ) { cd w ( 1 ); for ( int j = 0 ; j < len / 2 ; j ++ ) { cd u = a [ i + j ], v = a [ i + j + len / 2 ] * w ; a [ i + j ] = u + v ; a [ i + j + len / 2 ] = u - v ; w *= wlen ; } } } if ( invert ) { for ( cd & x : a ) x /= n ; } } Additionally we can precompute the bit-reversal permutation beforehand. This is especially useful when the size $n$ is the same for all calls. But even when we only have three calls (which are necessary for multiplying two polynomials), the effect is noticeable. Also we can precompute all roots of unity and their powers. Number theoretic transform \u00b6 Now we switch the objective a little bit. We still want to multiply two polynomials in $O(n \\log n)$ time, but this time we want to compute the coefficients modulo some prime number $p$ . Of course for this task we can use the normal DFT and apply the modulo operator to the result. However, doing so might lead to rounding errors, especially when dealing with large numbers. The number theoretic transform (NTT) has the advantage, that it only works with integer, and therefore the result are guaranteed to be correct. The discrete Fourier transform is based on complex numbers, and the $n$ -th roots of unity. To efficiently compute it, we extensively use properties of the roots (e.g. that there is one root that generates all other roots by exponentiation). But the same properties hold for the $n$ -th roots of unity in modular arithmetic. A $n$ -th root of unity under a primitive field is such a number $w_n$ that satisfies: $$\\begin{align} (w_n)^n &= 1 \\pmod{p}, \\\\ (w_n)^k &\\ne 1 \\pmod{p}, \\quad 1 \\le k < n. \\end{align}$$ The other $n-1$ roots can be obtained as powers of the root $w_n$ . To apply it in the fast Fourier transform algorithm, we need a root to exist for some $n$ , which is a power of $2$ , and also for all smaller powers. We can notice the following interesting property: $$\\begin{align} (w_n^2)^m = w_n^n &= 1 \\pmod{p}, \\quad \\text{with } m = \\frac{n}{2}\\\\ (w_n^2)^k = w_n^{2k} &\\ne 1 \\pmod{p}, \\quad 1 \\le k < m. \\end{align}$$ Thus if $w_n$ is a $n$ -th root of unity, then $w_n^2$ is a $\\frac{n}{2}$ -th root of unity. And consequently for all smaller powers of two there exist roots of the required degree, and they can be computed using $w_n$ . For computing the inverse DFT, we need the inverse $w_n^{-1}$ of $w_n$ . But for a prime modulus the inverse always exists. Thus all the properties that we need from the complex roots are also available in modular arithmetic, provided that we have a large enough module $p$ for which a $n$ -th root of unity exists. For example we can take the following values: module $p = 7340033$ , $w_{2^{20}} = 5$ . If this module is not enough, we need to find a different pair. We can use that fact that for modules of the form $p = c 2^k + 1$ (and $p$ is prime), there always exists the $2^k$ -th root of unity. It can be shown that $g^c$ is such a $2^k$ -th root of unity, where $g$ is a primitive root of $p$ . const int mod = 7340033 ; const int root = 5 ; const int root_1 = 4404020 ; const int root_pw = 1 << 20 ; void fft ( vector < int > & a , bool invert ) { int n = a . size (); for ( int i = 1 , j = 0 ; i < n ; i ++ ) { int bit = n >> 1 ; for (; j & bit ; bit >>= 1 ) j ^= bit ; j ^= bit ; if ( i < j ) swap ( a [ i ], a [ j ]); } for ( int len = 2 ; len <= n ; len <<= 1 ) { int wlen = invert ? root_1 : root ; for ( int i = len ; i < root_pw ; i <<= 1 ) wlen = ( int )( 1L L * wlen * wlen % mod ); for ( int i = 0 ; i < n ; i += len ) { int w = 1 ; for ( int j = 0 ; j < len / 2 ; j ++ ) { int u = a [ i + j ], v = ( int )( 1L L * a [ i + j + len / 2 ] * w % mod ); a [ i + j ] = u + v < mod ? u + v : u + v - mod ; a [ i + j + len / 2 ] = u - v >= 0 ? u - v : u - v + mod ; w = ( int )( 1L L * w * wlen % mod ); } } } if ( invert ) { int n_1 = inverse ( n , mod ); for ( int & x : a ) x = ( int )( 1L L * x * n_1 % mod ); } } Here the function inverse computes the modular inverse (see Modular Multiplicative Inverse ). The constants mod , root , root_pw determine the module and the root, and root_1 is the inverse of root modulo mod . In practice this implementation is slower than the implementation using complex numbers (due to the huge number of modulo operations), but it has some advantages such as less memory usage and no rounding errors. Multiplication with arbitrary modulus \u00b6 Here we want to achieve the same goal as in previous section. Multiplying two polynomial $A(x)$ and $B(x)$ , and computing the coefficients modulo some number $M$ . The number theoretic transform only works for certain prime numbers. What about the case when the modulus is not of the desired form? One option would be to perform multiple number theoretic transforms with different prime numbers of the form $c 2^k + 1$ , then apply the Chinese Remainder Theorem to compute the final coefficients. Another options is to distribute the polynomials $A(x)$ and $B(x)$ into two smaller polynomials each $$\\begin{align} A(x) &= A_1(x) + A_2(x) \\cdot C \\\\ B(x) &= B_1(x) + B_2(x) \\cdot C \\end{align}$$ with $C \\approx \\sqrt{M}$ . Then the product of $A(x)$ and $B(x)$ can then be represented as: $$A(x) \\cdot B(x) = A_1(x) \\cdot B_1(x) + \\left(A_1(x) \\cdot B_2(x) + A_2(x) \\cdot B_1(x)\\right)\\cdot C + \\left(A_2(x) \\cdot B_2(x)\\right)\\cdot C^2$$ The polynomials $A_1(x)$ , $A_2(x)$ , $B_1(x)$ and $B_2(x)$ contain only coefficients smaller than $\\sqrt{M}$ , therefore the coefficients of all the appearing products are smaller than $M \\cdot n$ , which is usually small enough to handle with typical floating point types. This approach therefore requires computing the products of polynomials with smaller coefficients (by using the normal FFT and inverse FFT), and then the original product can be restored using modular addition and multiplication in $O(n)$ time. Applications \u00b6 DFT can be used in a huge variety of other problems, which at the first glance have nothing to do with multiplying polynomials. All possible sums \u00b6 We are given two arrays $a[]$ and $b[]$ . We have to find all possible sums $a[i] + b[j]$ , and for each sum count how often it appears. For example for $a = [1,~ 2,~ 3]$ and $b = [2,~ 4]$ we get: then sum $3$ can be obtained in $1$ way, the sum $4$ also in $1$ way, $5$ in $2$ , $6$ in $1$ , $7$ in $1$ . We construct for the arrays $a$ and $b$ two polynomials $A$ and $B$ . The numbers of the array will act as the exponents in the polynomial ( $a[i] \\Rightarrow x^{a[i]}$ ); and the coefficients of this term will be how often the number appears in the array. Then, by multiplying these two polynomials in $O(n \\log n)$ time, we get a polynomial $C$ , where the exponents will tell us which sums can be obtained, and the coefficients tell us how often. To demonstrate this on the example: $$(1 x^1 + 1 x^2 + 1 x^3) (1 x^2 + 1 x^4) = 1 x^3 + 1 x^4 + 2 x^5 + 1 x^6 + 1 x^7$$ All possible scalar products \u00b6 We are given two arrays $a[]$ and $b[]$ of length $n$ . We have to compute the products of $a$ with every cyclic shift of $b$ . We generate two new arrays of size $2n$ : We reverse $a$ and append $n$ zeros to it. And we just append $b$ to itself. When we multiply these two arrays as polynomials, and look at the coefficients $c[n-1],~ c[n],~ \\dots,~ c[2n-2]$ of the product $c$ , we get: $$c[k] = \\sum_{i+j=k} a[i] b[j]$$ And since all the elements $a[i] = 0$ for $i \\ge n$ : $$c[k] = \\sum_{i=0}^{n-1} a[i] b[k-i]$$ It is easy to see that this sum is just the scalar product of the vector $a$ with the $(k - (n - 1))$ -th cyclic left shift of $b$ . Thus these coefficients are the answer to the problem, and we were still able to obtain it in $O(n \\log n)$ time. Note here that $c[2n-1]$ also gives us the $n$ -th cyclic shift but that is the same as the $0$ -th cyclic shift so we don't need to consider that separately into our answer. Two stripes \u00b6 We are given two Boolean stripes (cyclic arrays of values $0$ and $1$ ) $a$ and $b$ . We want to find all ways to attach the first stripe to the second one, such that at no position we have a $1$ of the first stripe next to a $1$ of the second stripe. The problem doesn't actually differ much from the previous problem. Attaching two stripes just means that we perform a cyclic shift on the second array, and we can attach the two stripes, if scalar product of the two arrays is $0$ . String matching \u00b6 We are given two strings, a text $T$ and a pattern $P$ , consisting of lowercase letters. We have to compute all the occurrences of the pattern in the text. We create a polynomial for each string ( $T[i]$ and $P[I]$ are numbers between $0$ and $25$ corresponding to the $26$ letters of the alphabet): $$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}, \\quad n = |T|$$ with $$a_i = \\cos(\\alpha_i) + i \\sin(\\alpha_i), \\quad \\alpha_i = \\frac{2 \\pi T[i]}{26}.$$ And $$B(x) = b_0 x^0 + b_1 x^1 + \\dots + b_{m-1} x^{m-1}, \\quad m = |P|$$ with $$b_i = \\cos(\\beta_i) - i \\sin(\\beta_i), \\quad \\beta_i = \\frac{2 \\pi P[m-i-1]}{26}.$$ Notice that with the expression $P[m-i-1]$ explicitly reverses the pattern. The $(m-1+i)$ th coefficients of the product of the two polynomials $C(x) = A(x) \\cdot B(x)$ will tell us, if the pattern appears in the text at position $i$ . $$c_{m-1+i} = \\sum_{j = 0}^{m-1} a_{i+j} \\cdot b_{m-1-j} = \\sum_{j=0}^{m-1} \\left(\\cos(\\alpha_{i+j}) + i \\sin(\\alpha_{i+j})\\right) \\cdot \\left(\\cos(\\beta_j) - i \\sin(\\beta_j)\\right)$$ with $\\alpha_{i+j} = \\frac{2 \\pi T[i+j]}{26}$ and $\\beta_j = \\frac{2 \\pi P[j]}{26}$ If there is a match, than $T[i+j] = P[j]$ , and therefore $\\alpha_{i+j} = \\beta_j$ . This gives (using the Pythagorean trigonometric identity): $$\\begin{align} c_{m-1+i} &= \\sum_{j = 0}^{m-1} \\left(\\cos(\\alpha_{i+j}) + i \\sin(\\alpha_{i+j})\\right) \\cdot \\left(\\cos(\\alpha_{i+j}) - i \\sin(\\alpha_{i+j})\\right) \\\\ &= \\sum_{j = 0}^{m-1} \\cos(\\alpha_{i+j})^2 + \\sin(\\alpha_{i+j})^2 = \\sum_{j = 0}^{m-1} 1 = m \\end{align}$$ If there isn't a match, then at least a character is different, which leads that one of the products $a_{i+1} \\cdot b_{m-1-j}$ is not equal to $1$ , which leads to the coefficient $c_{m-1+i} \\ne m$ . String matching with wildcards \u00b6 This is an extension of the previous problem. This time we allow that the pattern contains the wildcard character $\\*$ , which can match every possible letter. E.g. the pattern $a*c$ appears in the text $abccaacc$ at exactly three positions, at index $0$ , index $4$ and index $5$ . We create the exact same polynomials, except that we set $b_i = 0$ if $P[m-i-1] = *$ . If $x$ is the number of wildcards in $P$ , then we will have a match of $P$ in $T$ at index $i$ if $c_{m-1+i} = m - x$ . Practice problems \u00b6 SPOJ - POLYMUL SPOJ - MAXMATCH SPOJ - ADAMATCH Codeforces - Yet Another String Matching Problem Codeforces - Lightsabers (hard) Codeforces - Running Competition Kattis - A+B Problem Kattis - K-Inversions Codeforces - Dasha and cyclic table CodeChef - Expected Number of Customers CodeChef - Power Sum Codeforces - Centroid Probabilities","title":"Fast Fourier transform"},{"location":"algebra/fft.html#fast-fourier-transform","text":"In this article we will discuss an algorithm that allows us to multiply two polynomials of length $n$ in $O(n \\log n)$ time, which is better than the trivial multiplication which takes $O(n^2)$ time. Obviously also multiplying two long numbers can be reduced to multiplying polynomials, so also two long numbers can be multiplied in $O(n \\log n)$ time (where $n$ is the number of digits in the numbers). The discovery of the Fast Fourier transformation (FFT) is attributed to Cooley and Tukey, who published an algorithm in 1965. But in fact the FFT has been discovered repeatedly before, but the importance of it was not understood before the inventions of modern computers. Some researchers attribute the discovery of the FFT to Runge and K\u00f6nig in 1924. But actually Gauss developed such a method already in 1805, but never published it. Notice, that the FFT algorithm presented here runs in $O(n \\log n)$ time, but it doesn't work for multiplying arbitrary big polynomials with arbitrary large coefficients or for multiplying arbitrary big integers. It can easily handle polynomials of size $10^5$ with small coefficients, or multiplying two numbers of size $10^6$ , which is usually enough for solving competitive programming problems. Beyond the scale of multiplying numbers with $10^6$ bits, the range and precision of the floating point numbers used during the computation will not be enough to give accurate final results, though there are more complex variations that can perform arbitrary large polynomial/integer multiplications. E.g. in 1971 Sch\u00f6nhage and Strasser developed a variation for multiplying arbitrary large numbers that applies the FFT recursively in rings structures running in $O(n \\log n \\log \\log n)$ . And recently (in 2019) Harvey and van der Hoeven published an algorithm that runs in true $O(n \\log n)$ .","title":"Fast Fourier transform"},{"location":"algebra/fft.html#discrete-fourier-transform","text":"Let there be a polynomial of degree $n - 1$ : $$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}$$ Without loss of generality we assume that $n$ - the number of coefficients - is a power of $2$ . If $n$ is not a power of $2$ , then we simply add the missing terms $a_i x^i$ and set the coefficients $a_i$ to $0$ . The theory of complex numbers tells us that the equation $x^n = 1$ has $n$ complex solutions (called the $n$ -th roots of unity), and the solutions are of the form $w_{n, k} = e^{\\frac{2 k \\pi i}{n}}$ with $k = 0 \\dots n-1$ . Additionally these complex numbers have some very interesting properties: e.g. the principal $n$ -th root $w_n = w_{n, 1} = e^{\\frac{2 \\pi i}{n}}$ can be used to describe all other $n$ -th roots: $w_{n, k} = (w_n)^k$ . The discrete Fourier transform (DFT) of the polynomial $A(x)$ (or equivalently the vector of coefficients $(a_0, a_1, \\dots, a_{n-1})$ is defined as the values of the polynomial at the points $x = w_{n, k}$ , i.e. it is the vector: $$\\begin{align} \\text{DFT}(a_0, a_1, \\dots, a_{n-1}) &= (y_0, y_1, \\dots, y_{n-1}) \\\\ &= (A(w_{n, 0}), A(w_{n, 1}), \\dots, A(w_{n, n-1})) \\\\ &= (A(w_n^0), A(w_n^1), \\dots, A(w_n^{n-1})) \\end{align}$$ Similarly the inverse discrete Fourier transform is defined: The inverse DFT of values of the polynomial $(y_0, y_1, \\dots, y_{n-1})$ are the coefficients of the polynomial $(a_0, a_1, \\dots, a_{n-1})$ . $$\\text{InverseDFT}(y_0, y_1, \\dots, y_{n-1}) = (a_0, a_1, \\dots, a_{n-1})$$ Thus, if a direct DFT computes the values of the polynomial at the points at the $n$ -th roots, the inverse DFT can restore the coefficients of the polynomial using those values.","title":"Discrete Fourier transform"},{"location":"algebra/fft.html#application-of-the-dft-fast-multiplication-of-polynomials","text":"Let there be two polynomials $A$ and $B$ . We compute the DFT for each of them: $\\text{DFT}(A)$ and $\\text{DFT}(B)$ . What happens if we multiply these polynomials? Obviously at each point the values are simply multiplied, i.e. $$(A \\cdot B)(x) = A(x) \\cdot B(x).$$ This means that if we multiply the vectors $\\text{DFT}(A)$ and $\\text{DFT}(B)$ - by multiplying each element of one vector by the corresponding element of the other vector - then we get nothing other than the DFT of the polynomial $\\text{DFT}(A \\cdot B)$ : $$\\text{DFT}(A \\cdot B) = \\text{DFT}(A) \\cdot \\text{DFT}(B)$$ Finally, applying the inverse DFT, we obtain: $$A \\cdot B = \\text{InverseDFT}(\\text{DFT}(A) \\cdot \\text{DFT}(B))$$ On the right the product of the two DFTs we mean the pairwise product of the vector elements. This can be computed in $O(n)$ time. If we can compute the DFT and the inverse DFT in $O(n \\log n)$ , then we can compute the product of the two polynomials (and consequently also two long numbers) with the same time complexity. It should be noted, that the two polynomials should have the same degree. Otherwise the two result vectors of the DFT have different length. We can accomplish this by adding coefficients with the value $0$ . And also, since the result of the product of two polynomials is a polynomial of degree $2 (n - 1)$ , we have to double the degrees of each polynomial (again by padding $0$ s). From a vector with $n$ values we cannot reconstruct the desired polynomial with $2n - 1$ coefficients.","title":"Application of the DFT: fast multiplication of polynomials"},{"location":"algebra/fft.html#fast-fourier-transform_1","text":"The fast Fourier transform is a method that allows computing the DFT in $O(n \\log n)$ time. The basic idea of the FFT is to apply divide and conquer. We divide the coefficient vector of the polynomial into two vectors, recursively compute the DFT for each of them, and combine the results to compute the DFT of the complete polynomial. So let there be a polynomial $A(x)$ with degree $n - 1$ , where $n$ is a power of $2$ , and $n > 1$ : $$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}$$ We divide it into two smaller polynomials, the one containing only the coefficients of the even positions, and the one containing the coefficients of the odd positions: $$\\begin{align} A_0(x) &= a_0 x^0 + a_2 x^1 + \\dots + a_{n-2} x^{\\frac{n}{2}-1} \\\\ A_1(x) &= a_1 x^0 + a_3 x^1 + \\dots + a_{n-1} x^{\\frac{n}{2}-1} \\end{align}$$ It is easy to see that $$A(x) = A_0(x^2) + x A_1(x^2).$$ The polynomials $A_0$ and $A_1$ are only half as much coefficients as the polynomial $A$ . If we can compute the $\\text{DFT}(A)$ in linear time using $\\text{DFT}(A_0)$ and $\\text{DFT}(A_1)$ , then we get the recurrence $T_{\\text{DFT}}(n) = 2 T_{\\text{DFT}}\\left(\\frac{n}{2}\\right) + O(n)$ for the time complexity, which results in $T_{\\text{DFT}}(n) = O(n \\log n)$ by the master theorem . Let's learn how we can accomplish that. Suppose we have computed the vectors $\\left(y_k^0\\right)_{k=0}^{n/2-1} = \\text{DFT}(A_0)$ and $\\left(y_k^1\\right)_{k=0}^{n/2-1} = \\text{DFT}(A_1)$ . Let us find a expression for $\\left(y_k\\right)_{k=0}^{n-1} = \\text{DFT}(A)$ . For the first $\\frac{n}{2}$ values we can just use the previously noted equation $A(x) = A_0(x^2) + x A_1(x^2)$ : $$y_k = y_k^0 + w_n^k y_k^1, \\quad k = 0 \\dots \\frac{n}{2} - 1.$$ However for the second $\\frac{n}{2}$ values we need to find a slightly, different expression: $$\\begin{align} y_{k+n/2} &= A\\left(w_n^{k+n/2}\\right) \\\\ &= A_0\\left(w_n^{2k+n}\\right) + w_n^{k + n/2} A_1\\left(w_n^{2k+n}\\right) \\\\ &= A_0\\left(w_n^{2k} w_n^n\\right) + w_n^k w_n^{n/2} A_1\\left(w_n^{2k} w_n^n\\right) \\\\ &= A_0\\left(w_n^{2k}\\right) - w_n^k A_1\\left(w_n^{2k}\\right) \\\\ &= y_k^0 - w_n^k y_k^1 \\end{align}$$ Here we used again $A(x) = A_0(x^2) + x A_1(x^2)$ and the two identities $w_n^n = 1$ and $w_n^{n/2} = -1$ . Therefore we get the desired formulas for computing the whole vector $(y_k)$ : $$\\begin{align} y_k &= y_k^0 + w_n^k y_k^1, &\\quad k = 0 \\dots \\frac{n}{2} - 1, \\\\ y_{k+n/2} &= y_k^0 - w_n^k y_k^1, &\\quad k = 0 \\dots \\frac{n}{2} - 1. \\end{align}$$ (This pattern $a + b$ and $a - b$ is sometimes called a butterfly .) Thus we learned how to compute the DFT in $O(n \\log n)$ time.","title":"Fast Fourier Transform"},{"location":"algebra/fft.html#inverse-fft","text":"Let the vector $(y_0, y_1, \\dots y_{n-1})$ - the values of polynomial $A$ of degree $n - 1$ in the points $x = w_n^k$ - be given. We want to restore the coefficients $(a_0, a_1, \\dots, a_{n-1})$ of the polynomial. This known problem is called interpolation , and there are general algorithms for solving it. But in this special case (since we know the values of the points at the roots of unity), we can obtains a much simpler algorithm (that is practically the same as the direct FFT). We can write the DFT, according to its definition, in the matrix form: $$ \\begin{pmatrix} w_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\ w_n^0 & w_n^1 & w_n^2 & w_n^3 & \\cdots & w_n^{n-1} \\\\ w_n^0 & w_n^2 & w_n^4 & w_n^6 & \\cdots & w_n^{2(n-1)} \\\\ w_n^0 & w_n^3 & w_n^6 & w_n^9 & \\cdots & w_n^{3(n-1)} \\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ w_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \\cdots & w_n^{(n-1)(n-1)} \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1} \\end{pmatrix} = \\begin{pmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1} \\end{pmatrix} $$ This matrix is called the Vandermonde matrix . Thus we can compute the vector $(a_0, a_1, \\dots, a_{n-1})$ by multiplying the vector $(y_0, y_1, \\dots y_{n-1})$ from the left with the inverse of the matrix: $$ \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1} \\end{pmatrix} = \\begin{pmatrix} w_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\ w_n^0 & w_n^1 & w_n^2 & w_n^3 & \\cdots & w_n^{n-1} \\\\ w_n^0 & w_n^2 & w_n^4 & w_n^6 & \\cdots & w_n^{2(n-1)} \\\\ w_n^0 & w_n^3 & w_n^6 & w_n^9 & \\cdots & w_n^{3(n-1)} \\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ w_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \\cdots & w_n^{(n-1)(n-1)} \\end{pmatrix}^{-1} \\begin{pmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1} \\end{pmatrix} $$ A quick check can verify that the inverse of the matrix has the following form: $$ \\frac{1}{n} \\begin{pmatrix} w_n^0 & w_n^0 & w_n^0 & w_n^0 & \\cdots & w_n^0 \\\\ w_n^0 & w_n^{-1} & w_n^{-2} & w_n^{-3} & \\cdots & w_n^{-(n-1)} \\\\ w_n^0 & w_n^{-2} & w_n^{-4} & w_n^{-6} & \\cdots & w_n^{-2(n-1)} \\\\ w_n^0 & w_n^{-3} & w_n^{-6} & w_n^{-9} & \\cdots & w_n^{-3(n-1)} \\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ w_n^0 & w_n^{-(n-1)} & w_n^{-2(n-1)} & w_n^{-3(n-1)} & \\cdots & w_n^{-(n-1)(n-1)} \\end{pmatrix} $$ Thus we obtain the formula: $$a_k = \\frac{1}{n} \\sum_{j=0}^{n-1} y_j w_n^{-k j}$$ Comparing this to the formula for $y_k$ $$y_k = \\sum_{j=0}^{n-1} a_j w_n^{k j},$$ we notice that these problems are almost the same, so the coefficients $a_k$ can be found by the same divide and conquer algorithm, as well as the direct FFT, only instead of $w_n^k$ we have to use $w_n^{-k}$ , and at the end we need to divide the resulting coefficients by $n$ . Thus the computation of the inverse DFT is almost the same as the calculation of the direct DFT, and it also can be performed in $O(n \\log n)$ time.","title":"Inverse FFT"},{"location":"algebra/fft.html#implementation","text":"Here we present a simple recursive implementation of the FFT and the inverse FFT, both in one function, since the difference between the forward and the inverse FFT are so minimal. To store the complex numbers we use the complex type in the C++ STL. using cd = complex < double > ; const double PI = acos ( -1 ); void fft ( vector < cd > & a , bool invert ) { int n = a . size (); if ( n == 1 ) return ; vector < cd > a0 ( n / 2 ), a1 ( n / 2 ); for ( int i = 0 ; 2 * i < n ; i ++ ) { a0 [ i ] = a [ 2 * i ]; a1 [ i ] = a [ 2 * i + 1 ]; } fft ( a0 , invert ); fft ( a1 , invert ); double ang = 2 * PI / n * ( invert ? -1 : 1 ); cd w ( 1 ), wn ( cos ( ang ), sin ( ang )); for ( int i = 0 ; 2 * i < n ; i ++ ) { a [ i ] = a0 [ i ] + w * a1 [ i ]; a [ i + n / 2 ] = a0 [ i ] - w * a1 [ i ]; if ( invert ) { a [ i ] /= 2 ; a [ i + n / 2 ] /= 2 ; } w *= wn ; } } The function gets passed a vector of coefficients, and the function will compute the DFT or inverse DFT and store the result again in this vector. The argument $\\text{invert}$ shows whether the direct or the inverse DFT should be computed. Inside the function we first check if the length of the vector is equal to one, if this is the case then we don't have to do anything. Otherwise we divide the vector $a$ into two vectors $a0$ and $a1$ and compute the DFT for both recursively. Then we initialize the value $wn$ and a variable $w$ , which will contain the current power of $wn$ . Then the values of the resulting DFT are computed using the above formulas. If the flag $\\text{invert}$ is set, then we replace $wn$ with $wn^{-1}$ , and each of the values of the result is divided by $2$ (since this will be done in each level of the recursion, this will end up dividing the final values by $n$ ). Using this function we can create a function for multiplying two polynomials : vector < int > multiply ( vector < int > const & a , vector < int > const & b ) { vector < cd > fa ( a . begin (), a . end ()), fb ( b . begin (), b . end ()); int n = 1 ; while ( n < a . size () + b . size ()) n <<= 1 ; fa . resize ( n ); fb . resize ( n ); fft ( fa , false ); fft ( fb , false ); for ( int i = 0 ; i < n ; i ++ ) fa [ i ] *= fb [ i ]; fft ( fa , true ); vector < int > result ( n ); for ( int i = 0 ; i < n ; i ++ ) result [ i ] = round ( fa [ i ]. real ()); return result ; } This function works with polynomials with integer coefficients, however you can also adjust it to work with other types. Since there is some error when working with complex numbers, we need round the resulting coefficients at the end. Finally the function for multiplying two long numbers practically doesn't differ from the function for multiplying polynomials. The only thing we have to do afterwards, is to normalize the number: int carry = 0 ; for ( int i = 0 ; i < n ; i ++ ) result [ i ] += carry ; carry = result [ i ] / 10 ; result [ i ] %= 10 ; } Since the length of the product of two numbers never exceed the total length of both numbers, the size of the vector is enough to perform all carry operations.","title":"Implementation"},{"location":"algebra/fft.html#improved-implementation-in-place-computation","text":"To increase the efficiency we will switch from the recursive implementation to an iterative one. In the above recursive implementation we explicitly separated the vector $a$ into two vectors - the element on the even positions got assigned to one temporary vector, and the elements on odd positions to another. However if we reorder the elements in a certain way, we don't need to create these temporary vectors (i.e. all the calculations can be done \"in-place\", right in the vector $A$ itself). Note that at the first recursion level, the elements whose lowest bit of the position was zero got assigned to the vector $a_0$ , and the ones with a one as the lowest bit of the position got assigned to $a_1$ . In the second recursion level the same thing happens, but with the second lowest bit instead, etc. Therefore if we reverse the bits of the position of each coefficient, and sort them by these reversed values, we get the desired order (it is called the bit-reversal permutation). For example the desired order for $n = 8$ has the form: $$a = \\bigg\\{ \\Big[ (a_0, a_4), (a_2, a_6) \\Big], \\Big[ (a_1, a_5), (a_3, a_7) \\Big] \\bigg\\}$$ Indeed in the first recursion level (surrounded by curly braces), the vector gets divided into two parts $[a_0, a_2, a_4, a_6]$ and $[a_1, a_3, a_5, a_7]$ . As we see, in the bit-reversal permutation this corresponds to simply dividing the vector into two halves: the first $\\frac{n}{2}$ elements and the last $\\frac{n}{2}$ elements. Then there is a recursive call for each halve. Let the resulting DFT for each of them be returned in place of the elements themselves (i.e. the first half and the second half of the vector $a$ respectively. $$a = \\bigg\\{ \\Big[y_0^0, y_1^0, y_2^0, y_3^0\\Big], \\Big[y_0^1, y_1^1, y_2^1, y_3^1 \\Big] \\bigg\\}$$ Now we want to combine the two DFTs into one for the complete vector. The order of the elements is ideal, and we can also perform the union directly in this vector. We can take the elements $y_0^0$ and $y_0^1$ and perform the butterfly transform. The place of the resulting two values is the same as the place of the two initial values, so we get: $$a = \\bigg\\{ \\Big[y_0^0 + w_n^0 y_0^1, y_1^0, y_2^0, y_3^0\\Big], \\Big[y_0^0 - w_n^0 y_0^1, y_1^1, y_2^1, y_3^1\\Big] \\bigg\\}$$ Similarly we can compute the butterfly transform of $y_1^0$ and $y_1^1$ and put the results in their place, and so on. As a result we get: $$a = \\bigg\\{ \\Big[y_0^0 + w_n^0 y_0^1, y_1^0 + w_n^1 y_1^1, y_2^0 + w_n^2 y_2^1, y_3^0 + w_n^3 y_3^1\\Big], \\Big[y_0^0 - w_n^0 y_0^1, y_1^0 - w_n^1 y_1^1, y_2^0 - w_n^2 y_2^1, y_3^0 - w_n^3 y_3^1\\Big] \\bigg\\}$$ Thus we computed the required DFT from the vector $a$ . Here we described the process of computing the DFT only at the first recursion level, but the same works obviously also for all other levels. Thus, after applying the bit-reversal permutation, we can compute the DFT in-place, without any additional memory. This additionally allows us to get rid of the recursion. We just start at the lowest level, i.e. we divide the vector into pairs and apply the butterfly transform to them. This results with the vector $a$ with the work of the last level applied. In the next step we divide the vector into vectors of size $4$ , and again apply the butterfly transform, which gives us the DFT for each block of size $4$ . And so on. Finally in the last step we obtained the result of the DFTs of both halves of $a$ , and by applying the butterfly transform we obtain the DFT for the complete vector $a$ . using cd = complex < double > ; const double PI = acos ( -1 ); int reverse ( int num , int lg_n ) { int res = 0 ; for ( int i = 0 ; i < lg_n ; i ++ ) { if ( num & ( 1 << i )) res |= 1 << ( lg_n - 1 - i ); } return res ; } void fft ( vector < cd > & a , bool invert ) { int n = a . size (); int lg_n = 0 ; while (( 1 << lg_n ) < n ) lg_n ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < reverse ( i , lg_n )) swap ( a [ i ], a [ reverse ( i , lg_n )]); } for ( int len = 2 ; len <= n ; len <<= 1 ) { double ang = 2 * PI / len * ( invert ? -1 : 1 ); cd wlen ( cos ( ang ), sin ( ang )); for ( int i = 0 ; i < n ; i += len ) { cd w ( 1 ); for ( int j = 0 ; j < len / 2 ; j ++ ) { cd u = a [ i + j ], v = a [ i + j + len / 2 ] * w ; a [ i + j ] = u + v ; a [ i + j + len / 2 ] = u - v ; w *= wlen ; } } } if ( invert ) { for ( cd & x : a ) x /= n ; } } At first we apply the bit-reversal permutation by swapping the each element with the element of the reversed position. Then the $\\log n - 1$ states of the algorithm we compute the DFT for each block of the corresponding size $\\text{len}$ . For all those blocks we have the same root of unity $\\text{wlen}$ . We iterate all blocks and perform the butterfly transform on each of them. We can further optimize the reversal of the bits. In the previous implementation we iterated all bits of the index and created the bitwise reversed index. However we can reverse the bits in a different way. Suppose that $j$ already contains the reverse of $i$ . Then by to go to $i + 1$ , we have to increment $i$ , and we also have to increment $j$ , but in a \"reversed\" number system. Adding one in the conventional binary system is equivalent to flip all tailing ones into zeros and flipping the zero right before them into a one. Equivalently in the \"reversed\" number system, we flip all leading ones, and the also the next zero. Thus we get the following implementation: using cd = complex < double > ; const double PI = acos ( -1 ); void fft ( vector < cd > & a , bool invert ) { int n = a . size (); for ( int i = 1 , j = 0 ; i < n ; i ++ ) { int bit = n >> 1 ; for (; j & bit ; bit >>= 1 ) j ^= bit ; j ^= bit ; if ( i < j ) swap ( a [ i ], a [ j ]); } for ( int len = 2 ; len <= n ; len <<= 1 ) { double ang = 2 * PI / len * ( invert ? -1 : 1 ); cd wlen ( cos ( ang ), sin ( ang )); for ( int i = 0 ; i < n ; i += len ) { cd w ( 1 ); for ( int j = 0 ; j < len / 2 ; j ++ ) { cd u = a [ i + j ], v = a [ i + j + len / 2 ] * w ; a [ i + j ] = u + v ; a [ i + j + len / 2 ] = u - v ; w *= wlen ; } } } if ( invert ) { for ( cd & x : a ) x /= n ; } } Additionally we can precompute the bit-reversal permutation beforehand. This is especially useful when the size $n$ is the same for all calls. But even when we only have three calls (which are necessary for multiplying two polynomials), the effect is noticeable. Also we can precompute all roots of unity and their powers.","title":"Improved implementation: in-place computation"},{"location":"algebra/fft.html#number-theoretic-transform","text":"Now we switch the objective a little bit. We still want to multiply two polynomials in $O(n \\log n)$ time, but this time we want to compute the coefficients modulo some prime number $p$ . Of course for this task we can use the normal DFT and apply the modulo operator to the result. However, doing so might lead to rounding errors, especially when dealing with large numbers. The number theoretic transform (NTT) has the advantage, that it only works with integer, and therefore the result are guaranteed to be correct. The discrete Fourier transform is based on complex numbers, and the $n$ -th roots of unity. To efficiently compute it, we extensively use properties of the roots (e.g. that there is one root that generates all other roots by exponentiation). But the same properties hold for the $n$ -th roots of unity in modular arithmetic. A $n$ -th root of unity under a primitive field is such a number $w_n$ that satisfies: $$\\begin{align} (w_n)^n &= 1 \\pmod{p}, \\\\ (w_n)^k &\\ne 1 \\pmod{p}, \\quad 1 \\le k < n. \\end{align}$$ The other $n-1$ roots can be obtained as powers of the root $w_n$ . To apply it in the fast Fourier transform algorithm, we need a root to exist for some $n$ , which is a power of $2$ , and also for all smaller powers. We can notice the following interesting property: $$\\begin{align} (w_n^2)^m = w_n^n &= 1 \\pmod{p}, \\quad \\text{with } m = \\frac{n}{2}\\\\ (w_n^2)^k = w_n^{2k} &\\ne 1 \\pmod{p}, \\quad 1 \\le k < m. \\end{align}$$ Thus if $w_n$ is a $n$ -th root of unity, then $w_n^2$ is a $\\frac{n}{2}$ -th root of unity. And consequently for all smaller powers of two there exist roots of the required degree, and they can be computed using $w_n$ . For computing the inverse DFT, we need the inverse $w_n^{-1}$ of $w_n$ . But for a prime modulus the inverse always exists. Thus all the properties that we need from the complex roots are also available in modular arithmetic, provided that we have a large enough module $p$ for which a $n$ -th root of unity exists. For example we can take the following values: module $p = 7340033$ , $w_{2^{20}} = 5$ . If this module is not enough, we need to find a different pair. We can use that fact that for modules of the form $p = c 2^k + 1$ (and $p$ is prime), there always exists the $2^k$ -th root of unity. It can be shown that $g^c$ is such a $2^k$ -th root of unity, where $g$ is a primitive root of $p$ . const int mod = 7340033 ; const int root = 5 ; const int root_1 = 4404020 ; const int root_pw = 1 << 20 ; void fft ( vector < int > & a , bool invert ) { int n = a . size (); for ( int i = 1 , j = 0 ; i < n ; i ++ ) { int bit = n >> 1 ; for (; j & bit ; bit >>= 1 ) j ^= bit ; j ^= bit ; if ( i < j ) swap ( a [ i ], a [ j ]); } for ( int len = 2 ; len <= n ; len <<= 1 ) { int wlen = invert ? root_1 : root ; for ( int i = len ; i < root_pw ; i <<= 1 ) wlen = ( int )( 1L L * wlen * wlen % mod ); for ( int i = 0 ; i < n ; i += len ) { int w = 1 ; for ( int j = 0 ; j < len / 2 ; j ++ ) { int u = a [ i + j ], v = ( int )( 1L L * a [ i + j + len / 2 ] * w % mod ); a [ i + j ] = u + v < mod ? u + v : u + v - mod ; a [ i + j + len / 2 ] = u - v >= 0 ? u - v : u - v + mod ; w = ( int )( 1L L * w * wlen % mod ); } } } if ( invert ) { int n_1 = inverse ( n , mod ); for ( int & x : a ) x = ( int )( 1L L * x * n_1 % mod ); } } Here the function inverse computes the modular inverse (see Modular Multiplicative Inverse ). The constants mod , root , root_pw determine the module and the root, and root_1 is the inverse of root modulo mod . In practice this implementation is slower than the implementation using complex numbers (due to the huge number of modulo operations), but it has some advantages such as less memory usage and no rounding errors.","title":"Number theoretic transform"},{"location":"algebra/fft.html#multiplication-with-arbitrary-modulus","text":"Here we want to achieve the same goal as in previous section. Multiplying two polynomial $A(x)$ and $B(x)$ , and computing the coefficients modulo some number $M$ . The number theoretic transform only works for certain prime numbers. What about the case when the modulus is not of the desired form? One option would be to perform multiple number theoretic transforms with different prime numbers of the form $c 2^k + 1$ , then apply the Chinese Remainder Theorem to compute the final coefficients. Another options is to distribute the polynomials $A(x)$ and $B(x)$ into two smaller polynomials each $$\\begin{align} A(x) &= A_1(x) + A_2(x) \\cdot C \\\\ B(x) &= B_1(x) + B_2(x) \\cdot C \\end{align}$$ with $C \\approx \\sqrt{M}$ . Then the product of $A(x)$ and $B(x)$ can then be represented as: $$A(x) \\cdot B(x) = A_1(x) \\cdot B_1(x) + \\left(A_1(x) \\cdot B_2(x) + A_2(x) \\cdot B_1(x)\\right)\\cdot C + \\left(A_2(x) \\cdot B_2(x)\\right)\\cdot C^2$$ The polynomials $A_1(x)$ , $A_2(x)$ , $B_1(x)$ and $B_2(x)$ contain only coefficients smaller than $\\sqrt{M}$ , therefore the coefficients of all the appearing products are smaller than $M \\cdot n$ , which is usually small enough to handle with typical floating point types. This approach therefore requires computing the products of polynomials with smaller coefficients (by using the normal FFT and inverse FFT), and then the original product can be restored using modular addition and multiplication in $O(n)$ time.","title":"Multiplication with arbitrary modulus"},{"location":"algebra/fft.html#applications","text":"DFT can be used in a huge variety of other problems, which at the first glance have nothing to do with multiplying polynomials.","title":"Applications"},{"location":"algebra/fft.html#all-possible-sums","text":"We are given two arrays $a[]$ and $b[]$ . We have to find all possible sums $a[i] + b[j]$ , and for each sum count how often it appears. For example for $a = [1,~ 2,~ 3]$ and $b = [2,~ 4]$ we get: then sum $3$ can be obtained in $1$ way, the sum $4$ also in $1$ way, $5$ in $2$ , $6$ in $1$ , $7$ in $1$ . We construct for the arrays $a$ and $b$ two polynomials $A$ and $B$ . The numbers of the array will act as the exponents in the polynomial ( $a[i] \\Rightarrow x^{a[i]}$ ); and the coefficients of this term will be how often the number appears in the array. Then, by multiplying these two polynomials in $O(n \\log n)$ time, we get a polynomial $C$ , where the exponents will tell us which sums can be obtained, and the coefficients tell us how often. To demonstrate this on the example: $$(1 x^1 + 1 x^2 + 1 x^3) (1 x^2 + 1 x^4) = 1 x^3 + 1 x^4 + 2 x^5 + 1 x^6 + 1 x^7$$","title":"All possible sums"},{"location":"algebra/fft.html#all-possible-scalar-products","text":"We are given two arrays $a[]$ and $b[]$ of length $n$ . We have to compute the products of $a$ with every cyclic shift of $b$ . We generate two new arrays of size $2n$ : We reverse $a$ and append $n$ zeros to it. And we just append $b$ to itself. When we multiply these two arrays as polynomials, and look at the coefficients $c[n-1],~ c[n],~ \\dots,~ c[2n-2]$ of the product $c$ , we get: $$c[k] = \\sum_{i+j=k} a[i] b[j]$$ And since all the elements $a[i] = 0$ for $i \\ge n$ : $$c[k] = \\sum_{i=0}^{n-1} a[i] b[k-i]$$ It is easy to see that this sum is just the scalar product of the vector $a$ with the $(k - (n - 1))$ -th cyclic left shift of $b$ . Thus these coefficients are the answer to the problem, and we were still able to obtain it in $O(n \\log n)$ time. Note here that $c[2n-1]$ also gives us the $n$ -th cyclic shift but that is the same as the $0$ -th cyclic shift so we don't need to consider that separately into our answer.","title":"All possible scalar products"},{"location":"algebra/fft.html#two-stripes","text":"We are given two Boolean stripes (cyclic arrays of values $0$ and $1$ ) $a$ and $b$ . We want to find all ways to attach the first stripe to the second one, such that at no position we have a $1$ of the first stripe next to a $1$ of the second stripe. The problem doesn't actually differ much from the previous problem. Attaching two stripes just means that we perform a cyclic shift on the second array, and we can attach the two stripes, if scalar product of the two arrays is $0$ .","title":"Two stripes"},{"location":"algebra/fft.html#string-matching","text":"We are given two strings, a text $T$ and a pattern $P$ , consisting of lowercase letters. We have to compute all the occurrences of the pattern in the text. We create a polynomial for each string ( $T[i]$ and $P[I]$ are numbers between $0$ and $25$ corresponding to the $26$ letters of the alphabet): $$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}, \\quad n = |T|$$ with $$a_i = \\cos(\\alpha_i) + i \\sin(\\alpha_i), \\quad \\alpha_i = \\frac{2 \\pi T[i]}{26}.$$ And $$B(x) = b_0 x^0 + b_1 x^1 + \\dots + b_{m-1} x^{m-1}, \\quad m = |P|$$ with $$b_i = \\cos(\\beta_i) - i \\sin(\\beta_i), \\quad \\beta_i = \\frac{2 \\pi P[m-i-1]}{26}.$$ Notice that with the expression $P[m-i-1]$ explicitly reverses the pattern. The $(m-1+i)$ th coefficients of the product of the two polynomials $C(x) = A(x) \\cdot B(x)$ will tell us, if the pattern appears in the text at position $i$ . $$c_{m-1+i} = \\sum_{j = 0}^{m-1} a_{i+j} \\cdot b_{m-1-j} = \\sum_{j=0}^{m-1} \\left(\\cos(\\alpha_{i+j}) + i \\sin(\\alpha_{i+j})\\right) \\cdot \\left(\\cos(\\beta_j) - i \\sin(\\beta_j)\\right)$$ with $\\alpha_{i+j} = \\frac{2 \\pi T[i+j]}{26}$ and $\\beta_j = \\frac{2 \\pi P[j]}{26}$ If there is a match, than $T[i+j] = P[j]$ , and therefore $\\alpha_{i+j} = \\beta_j$ . This gives (using the Pythagorean trigonometric identity): $$\\begin{align} c_{m-1+i} &= \\sum_{j = 0}^{m-1} \\left(\\cos(\\alpha_{i+j}) + i \\sin(\\alpha_{i+j})\\right) \\cdot \\left(\\cos(\\alpha_{i+j}) - i \\sin(\\alpha_{i+j})\\right) \\\\ &= \\sum_{j = 0}^{m-1} \\cos(\\alpha_{i+j})^2 + \\sin(\\alpha_{i+j})^2 = \\sum_{j = 0}^{m-1} 1 = m \\end{align}$$ If there isn't a match, then at least a character is different, which leads that one of the products $a_{i+1} \\cdot b_{m-1-j}$ is not equal to $1$ , which leads to the coefficient $c_{m-1+i} \\ne m$ .","title":"String matching"},{"location":"algebra/fft.html#string-matching-with-wildcards","text":"This is an extension of the previous problem. This time we allow that the pattern contains the wildcard character $\\*$ , which can match every possible letter. E.g. the pattern $a*c$ appears in the text $abccaacc$ at exactly three positions, at index $0$ , index $4$ and index $5$ . We create the exact same polynomials, except that we set $b_i = 0$ if $P[m-i-1] = *$ . If $x$ is the number of wildcards in $P$ , then we will have a match of $P$ in $T$ at index $i$ if $c_{m-1+i} = m - x$ .","title":"String matching with wildcards"},{"location":"algebra/fft.html#practice-problems","text":"SPOJ - POLYMUL SPOJ - MAXMATCH SPOJ - ADAMATCH Codeforces - Yet Another String Matching Problem Codeforces - Lightsabers (hard) Codeforces - Running Competition Kattis - A+B Problem Kattis - K-Inversions Codeforces - Dasha and cyclic table CodeChef - Expected Number of Customers CodeChef - Power Sum Codeforces - Centroid Probabilities","title":"Practice problems"},{"location":"algebra/fibonacci-numbers.html","text":"Fibonacci Numbers \u00b6 The Fibonacci sequence is defined as follows: $$F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}$$ The first elements of the sequence ( OEIS A000045 ) are: $$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...$$ Properties \u00b6 Fibonacci numbers possess a lot of interesting properties. Here are a few of them: Cassini's identity: $$F_{n-1} F_{n+1} - F_n^2 = (-1)^n$$ The \"addition\" rule: $$F_{n+k} = F_k F_{n+1} + F_{k-1} F_n$$ Applying the previous identity to the case $k = n$ , we get: $$F_{2n} = F_n (F_{n+1} + F_{n-1})$$ From this we can prove by induction that for any positive integer $k$ , $F_{nk}$ is multiple of $F_n$ . The inverse is also true: if $F_m$ is multiple of $F_n$ , then $m$ is multiple of $n$ . GCD identity: $$GCD(F_m, F_n) = F_{GCD(m, n)}$$ Fibonacci numbers are the worst possible inputs for Euclidean algorithm (see Lame's theorem in Euclidean algorithm ) Fibonacci Coding \u00b6 We can use the sequence to encode positive integers into binary code words. According to Zeckendorf's theorem, any natural number $n$ can be uniquely represented as a sum of Fibonacci numbers: $$N = F_{k_1} + F_{k_2} + \\ldots + F_{k_r}$$ such that $k_1 \\ge k_2 + 2,\\ k_2 \\ge k_3 + 2,\\ \\ldots,\\ k_r \\ge 2$ (i.e.: the representation cannot use two consecutive Fibonacci numbers). It follows that any number can be uniquely encoded in the Fibonacci coding. And we can describe this representation with binary codes $d_0 d_1 d_2 \\dots d_s 1$ , where $d_i$ is $1$ if $F_{i+2}$ is used in the representation. The code will be appended by a $1$ to indicate the end of the code word. Notice that this is the only occurrence where two consecutive 1-bits appear. $$\\begin{eqnarray} 1 &=& 1 &=& F_2 &=& (11)_F \\\\ 2 &=& 2 &=& F_3 &=& (011)_F \\\\ 6 &=& 5 + 1 &=& F_5 + F_2 &=& (10011)_F \\\\ 8 &=& 8 &=& F_6 &=& (000011)_F \\\\ 9 &=& 8 + 1 &=& F_6 + F_2 &=& (100011)_F \\\\ 19 &=& 13 + 5 + 1 &=& F_7 + F_5 + F_2 &=& (1001011)_F \\end{eqnarray}$$ The encoding of an integer $n$ can be done with a simple greedy algorithm: Iterate through the Fibonacci numbers from the largest to the smallest until you find one less than or equal to $n$ . Suppose this number was $F_i$ . Subtract $F_i$ from $n$ and put a $1$ in the $i-2$ position of the code word (indexing from 0 from the leftmost to the rightmost bit). Repeat until there is no remainder. Add a final $1$ to the codeword to indicate its end. To decode a code word, first remove the final $1$ . Then, if the $i$ -th bit is set (indexing from 0 from the leftmost to the rightmost bit), sum $F_{i+2}$ to the number. Formulas for the $n^{\\text{th}}$ Fibonacci number \u00b6 Closed-form expression \u00b6 There is a formula known as \"Binet's formula\", even though it was already known by Moivre: $$F_n = \\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}$$ This formula is easy to prove by induction, but it can be deduced with the help of the concept of generating functions or by solving a functional equation. You can immediately notice that the second term's absolute value is always less than $1$ , and it also decreases very rapidly (exponentially). Hence the value of the first term alone is \"almost\" $F_n$ . This can be written strictly as: $$F_n = \\left[\\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}\\right]$$ where the square brackets denote rounding to the nearest integer. As these two formulas would require very high accuracy when working with fractional numbers, they are of little use in practical calculations. Fibonacci in linear time \u00b6 The $n$ -th Fibonacci number can be easily found in $O(n)$ by computing the numbers one by one up to $n$ . However, there are also faster ways, as we will see. We can start from an iterative approach, to take advantage of the use of the formula $F_n = F_{n-1} + F_{n-2}$ , therefore, we will simply precalculate those values in an array. Taking into account the base cases for $F_0$ and $F_1$ . int fib ( int n ) { int a = 0 ; int b = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = a + b ; a = b ; b = tmp ; } return a ; } In this way, we obtain a linear solution, $O(n)$ time, saving all the values prior to $n$ in the sequence. Matrix form \u00b6 It is easy to prove the following relation: $$\\begin{pmatrix} 1 & 1 \\cr 1 & 0 \\cr\\end{pmatrix} ^ n = \\begin{pmatrix} F_{n+1} & F_{n} \\cr F_{n} & F_{n-1} \\cr\\end{pmatrix}$$ Thus, in order to find $F_n$ in $O(log n)$ time, we must raise the matrix to n. (See Binary exponentiation ) struct matrix { long long mat [ 2 ][ 2 ]; matrix friend operator * ( const matrix & a , const matrix & b ){ matrix c ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { c . mat [ i ][ j ] = 0 ; for ( int k = 0 ; k < 2 ; k ++ ) { c . mat [ i ][ j ] += a . mat [ i ][ k ] * b . mat [ k ][ j ]; } } } return c ; } }; matrix matpow ( matrix base , long long n ) { matrix ans { { { 1 , 0 }, { 0 , 1 } } }; while ( n ) { if ( n & 1 ) ans = ans * base ; base = base * base ; n >>= 1 ; } return ans ; } long long fib ( int n ) { matrix base { { { 1 , 1 }, { 1 , 0 } } }; return matpow ( base , n ). mat [ 0 ][ 1 ]; } Fast Doubling Method \u00b6 By expanding the above matrix expression for $n = 2\\cdot k$ $$ \\begin{pmatrix} F_{2k+1} & F_{2k}\\\\ F_{2k} & F_{2k-1} \\end{pmatrix} = \\begin{pmatrix} 1 & 1\\\\ 1 & 0 \\end{pmatrix}^{2k} = \\begin{pmatrix} F_{k+1} & F_{k}\\\\ F_{k} & F_{k-1} \\end{pmatrix} ^2 $$ we can find these simpler equations: $$ \\begin{align} F_{2k+1} &= F_{k+1}^2 + F_{k}^2 \\\\ F_{2k} &= F_k(F_{k+1}+F_{k-1}) = F_k (2F_{k+1} - F_{k})\\\\ \\end{align}.$$ Thus using above two equations Fibonacci numbers can be calculated easily by the following code: pair < int , int > fib ( int n ) { if ( n == 0 ) return { 0 , 1 }; auto p = fib ( n >> 1 ); int c = p . first * ( 2 * p . second - p . first ); int d = p . first * p . first + p . second * p . second ; if ( n & 1 ) return { d , c + d }; else return { c , d }; } The above code returns $F_n$ and $F_{n+1}$ as a pair. Periodicity modulo p \u00b6 Consider the Fibonacci sequence modulo $p$ . We will prove the sequence is periodic. Let us prove this by contradiction. Consider the first $p^2 + 1$ pairs of Fibonacci numbers taken modulo $p$ : $$(F_0,\\ F_1),\\ (F_1,\\ F_2),\\ \\ldots,\\ (F_{p^2},\\ F_{p^2 + 1})$$ There can only be $p$ different remainders modulo $p$ , and at most $p^2$ different pairs of remainders, so there are at least two identical pairs among them. This is sufficient to prove the sequence is periodic, as a Fibonacci number is only determined by its two predecessors. Hence if two pairs of consecutive numbers repeat, that would also mean the numbers after the pair will repeat in the same fashion. We now choose two pairs of identical remainders with the smallest indices in the sequence. Let the pairs be $(F_a,\\ F_{a + 1})$ and $(F_b,\\ F_{b + 1})$ . We will prove that $a = 0$ . If this was false, there would be two previous pairs $(F_{a-1},\\ F_a)$ and $(F_{b-1},\\ F_b)$ , which, by the property of Fibonacci numbers, would also be equal. However, this contradicts the fact that we had chosen pairs with the smallest indices, completing our proof that there is no pre-period (i.e the numbers are periodic starting from $F_0$ ). Practice Problems \u00b6 SPOJ - Euclid Algorithm Revisited SPOJ - Fibonacci Sum HackerRank - Is Fibo Project Euler - Even Fibonacci numbers DMOJ - Fibonacci Sequence DMOJ - Fibonacci Sequence (Harder) DMOJ UCLV - Numbered sequence of pencils DMOJ UCLV - Fibonacci 2D DMOJ UCLV - fibonacci calculation LightOJ - Number Sequence Codeforces - C. Fibonacci Codeforces - A. Hexadecimal's theorem Codeforces - B. Blackboard Fibonacci Codeforces - E. Fibonacci Number","title":"Fibonacci Numbers"},{"location":"algebra/fibonacci-numbers.html#fibonacci-numbers","text":"The Fibonacci sequence is defined as follows: $$F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}$$ The first elements of the sequence ( OEIS A000045 ) are: $$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...$$","title":"Fibonacci Numbers"},{"location":"algebra/fibonacci-numbers.html#properties","text":"Fibonacci numbers possess a lot of interesting properties. Here are a few of them: Cassini's identity: $$F_{n-1} F_{n+1} - F_n^2 = (-1)^n$$ The \"addition\" rule: $$F_{n+k} = F_k F_{n+1} + F_{k-1} F_n$$ Applying the previous identity to the case $k = n$ , we get: $$F_{2n} = F_n (F_{n+1} + F_{n-1})$$ From this we can prove by induction that for any positive integer $k$ , $F_{nk}$ is multiple of $F_n$ . The inverse is also true: if $F_m$ is multiple of $F_n$ , then $m$ is multiple of $n$ . GCD identity: $$GCD(F_m, F_n) = F_{GCD(m, n)}$$ Fibonacci numbers are the worst possible inputs for Euclidean algorithm (see Lame's theorem in Euclidean algorithm )","title":"Properties"},{"location":"algebra/fibonacci-numbers.html#fibonacci-coding","text":"We can use the sequence to encode positive integers into binary code words. According to Zeckendorf's theorem, any natural number $n$ can be uniquely represented as a sum of Fibonacci numbers: $$N = F_{k_1} + F_{k_2} + \\ldots + F_{k_r}$$ such that $k_1 \\ge k_2 + 2,\\ k_2 \\ge k_3 + 2,\\ \\ldots,\\ k_r \\ge 2$ (i.e.: the representation cannot use two consecutive Fibonacci numbers). It follows that any number can be uniquely encoded in the Fibonacci coding. And we can describe this representation with binary codes $d_0 d_1 d_2 \\dots d_s 1$ , where $d_i$ is $1$ if $F_{i+2}$ is used in the representation. The code will be appended by a $1$ to indicate the end of the code word. Notice that this is the only occurrence where two consecutive 1-bits appear. $$\\begin{eqnarray} 1 &=& 1 &=& F_2 &=& (11)_F \\\\ 2 &=& 2 &=& F_3 &=& (011)_F \\\\ 6 &=& 5 + 1 &=& F_5 + F_2 &=& (10011)_F \\\\ 8 &=& 8 &=& F_6 &=& (000011)_F \\\\ 9 &=& 8 + 1 &=& F_6 + F_2 &=& (100011)_F \\\\ 19 &=& 13 + 5 + 1 &=& F_7 + F_5 + F_2 &=& (1001011)_F \\end{eqnarray}$$ The encoding of an integer $n$ can be done with a simple greedy algorithm: Iterate through the Fibonacci numbers from the largest to the smallest until you find one less than or equal to $n$ . Suppose this number was $F_i$ . Subtract $F_i$ from $n$ and put a $1$ in the $i-2$ position of the code word (indexing from 0 from the leftmost to the rightmost bit). Repeat until there is no remainder. Add a final $1$ to the codeword to indicate its end. To decode a code word, first remove the final $1$ . Then, if the $i$ -th bit is set (indexing from 0 from the leftmost to the rightmost bit), sum $F_{i+2}$ to the number.","title":"Fibonacci Coding"},{"location":"algebra/fibonacci-numbers.html#formulas-for-the-ntextth-fibonacci-number","text":"","title":"Formulas for the n-th Fibonacci number"},{"location":"algebra/fibonacci-numbers.html#closed-form-expression","text":"There is a formula known as \"Binet's formula\", even though it was already known by Moivre: $$F_n = \\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}$$ This formula is easy to prove by induction, but it can be deduced with the help of the concept of generating functions or by solving a functional equation. You can immediately notice that the second term's absolute value is always less than $1$ , and it also decreases very rapidly (exponentially). Hence the value of the first term alone is \"almost\" $F_n$ . This can be written strictly as: $$F_n = \\left[\\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}\\right]$$ where the square brackets denote rounding to the nearest integer. As these two formulas would require very high accuracy when working with fractional numbers, they are of little use in practical calculations.","title":"Closed-form expression"},{"location":"algebra/fibonacci-numbers.html#fibonacci-in-linear-time","text":"The $n$ -th Fibonacci number can be easily found in $O(n)$ by computing the numbers one by one up to $n$ . However, there are also faster ways, as we will see. We can start from an iterative approach, to take advantage of the use of the formula $F_n = F_{n-1} + F_{n-2}$ , therefore, we will simply precalculate those values in an array. Taking into account the base cases for $F_0$ and $F_1$ . int fib ( int n ) { int a = 0 ; int b = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = a + b ; a = b ; b = tmp ; } return a ; } In this way, we obtain a linear solution, $O(n)$ time, saving all the values prior to $n$ in the sequence.","title":"Fibonacci in linear time"},{"location":"algebra/fibonacci-numbers.html#matrix-form","text":"It is easy to prove the following relation: $$\\begin{pmatrix} 1 & 1 \\cr 1 & 0 \\cr\\end{pmatrix} ^ n = \\begin{pmatrix} F_{n+1} & F_{n} \\cr F_{n} & F_{n-1} \\cr\\end{pmatrix}$$ Thus, in order to find $F_n$ in $O(log n)$ time, we must raise the matrix to n. (See Binary exponentiation ) struct matrix { long long mat [ 2 ][ 2 ]; matrix friend operator * ( const matrix & a , const matrix & b ){ matrix c ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { c . mat [ i ][ j ] = 0 ; for ( int k = 0 ; k < 2 ; k ++ ) { c . mat [ i ][ j ] += a . mat [ i ][ k ] * b . mat [ k ][ j ]; } } } return c ; } }; matrix matpow ( matrix base , long long n ) { matrix ans { { { 1 , 0 }, { 0 , 1 } } }; while ( n ) { if ( n & 1 ) ans = ans * base ; base = base * base ; n >>= 1 ; } return ans ; } long long fib ( int n ) { matrix base { { { 1 , 1 }, { 1 , 0 } } }; return matpow ( base , n ). mat [ 0 ][ 1 ]; }","title":"Matrix form"},{"location":"algebra/fibonacci-numbers.html#fast-doubling-method","text":"By expanding the above matrix expression for $n = 2\\cdot k$ $$ \\begin{pmatrix} F_{2k+1} & F_{2k}\\\\ F_{2k} & F_{2k-1} \\end{pmatrix} = \\begin{pmatrix} 1 & 1\\\\ 1 & 0 \\end{pmatrix}^{2k} = \\begin{pmatrix} F_{k+1} & F_{k}\\\\ F_{k} & F_{k-1} \\end{pmatrix} ^2 $$ we can find these simpler equations: $$ \\begin{align} F_{2k+1} &= F_{k+1}^2 + F_{k}^2 \\\\ F_{2k} &= F_k(F_{k+1}+F_{k-1}) = F_k (2F_{k+1} - F_{k})\\\\ \\end{align}.$$ Thus using above two equations Fibonacci numbers can be calculated easily by the following code: pair < int , int > fib ( int n ) { if ( n == 0 ) return { 0 , 1 }; auto p = fib ( n >> 1 ); int c = p . first * ( 2 * p . second - p . first ); int d = p . first * p . first + p . second * p . second ; if ( n & 1 ) return { d , c + d }; else return { c , d }; } The above code returns $F_n$ and $F_{n+1}$ as a pair.","title":"Fast Doubling Method"},{"location":"algebra/fibonacci-numbers.html#periodicity-modulo-p","text":"Consider the Fibonacci sequence modulo $p$ . We will prove the sequence is periodic. Let us prove this by contradiction. Consider the first $p^2 + 1$ pairs of Fibonacci numbers taken modulo $p$ : $$(F_0,\\ F_1),\\ (F_1,\\ F_2),\\ \\ldots,\\ (F_{p^2},\\ F_{p^2 + 1})$$ There can only be $p$ different remainders modulo $p$ , and at most $p^2$ different pairs of remainders, so there are at least two identical pairs among them. This is sufficient to prove the sequence is periodic, as a Fibonacci number is only determined by its two predecessors. Hence if two pairs of consecutive numbers repeat, that would also mean the numbers after the pair will repeat in the same fashion. We now choose two pairs of identical remainders with the smallest indices in the sequence. Let the pairs be $(F_a,\\ F_{a + 1})$ and $(F_b,\\ F_{b + 1})$ . We will prove that $a = 0$ . If this was false, there would be two previous pairs $(F_{a-1},\\ F_a)$ and $(F_{b-1},\\ F_b)$ , which, by the property of Fibonacci numbers, would also be equal. However, this contradicts the fact that we had chosen pairs with the smallest indices, completing our proof that there is no pre-period (i.e the numbers are periodic starting from $F_0$ ).","title":"Periodicity modulo p"},{"location":"algebra/fibonacci-numbers.html#practice-problems","text":"SPOJ - Euclid Algorithm Revisited SPOJ - Fibonacci Sum HackerRank - Is Fibo Project Euler - Even Fibonacci numbers DMOJ - Fibonacci Sequence DMOJ - Fibonacci Sequence (Harder) DMOJ UCLV - Numbered sequence of pencils DMOJ UCLV - Fibonacci 2D DMOJ UCLV - fibonacci calculation LightOJ - Number Sequence Codeforces - C. Fibonacci Codeforces - A. Hexadecimal's theorem Codeforces - B. Blackboard Fibonacci Codeforces - E. Fibonacci Number","title":"Practice Problems"},{"location":"algebra/garners-algorithm.html","text":"Garner's algorithm \u00b6 A consequence of the Chinese Remainder Theorem is, that we can represent big numbers using an array of small integers. For example, let $p$ be the product of the first $1000$ primes. $p$ has around $3000$ digits. Any number $a$ less than $p$ can be represented as an array $a_1, \\ldots, a_k$ , where $a_i \\equiv a \\pmod{p_i}$ . But to do this we obviously need to know how to get back the number $a$ from its representation. One way is discussed in the article about the Chinese Remainder Theorem. In this article we discuss an alternative, Garner's Algorithm, which can also be used for this purpose. Mixed Radix Representation \u00b6 We can represent the number $a$ in the mixed radix representation: $$a = x_1 + x_2 p_1 + x_3 p_1 p_2 + \\ldots + x_k p_1 \\cdots p_{k-1} \\text{ with }x_i \\in [0, p_i)$$ A mixed radix representation is a positional numeral system, that's a generalization of the typical number systems, like the binary numeral system or the decimal numeral system. For instance the decimal numeral system is a positional numeral system with the radix (or base) 10. Every a number is represented as a string of digits $d_1 d_2 d_3 \\dots d_n$ between $0$ and $9$ , and E.g. the string $415$ represents the number $4 \\cdot 10^2 + 1 \\cdot 10^1 + 5 \\cdot 10^0$ . In general the string of digits $d_1 d_2 d_3 \\dots d_n$ represents the number $d_1 b^{n-1} + d_2 b^{n-2} + \\cdots + d_n b^0$ in the positional numeral system with radix $b$ . In a mixed radix system, we don't have one radix any more. The base varies from position to position. Garner's algorithm \u00b6 Garner's algorithm computes the digits $x_1, \\ldots, x_k$ . Notice, that the digits are relatively small. The digit $x_i$ is an integer between $0$ and $p_i - 1$ . Let $r_{ij}$ denote the inverse of $p_i$ modulo $p_j$ $$r_{ij} = (p_i)^{-1} \\pmod{p_j}$$ which can be found using the algorithm described in Modular Inverse . Substituting $a$ from the mixed radix representation into the first congruence equation we obtain $$a_1 \\equiv x_1 \\pmod{p_1}.$$ Substituting into the second equation yields $$a_2 \\equiv x_1 + x_2 p_1 \\pmod{p_2},$$ which can be rewritten by subtracting $x_1$ and dividing by $p_1$ to get $$\\begin{array}{rclr} a_2 - x_1 &\\equiv& x_2 p_1 &\\pmod{p_2} \\\\ (a_2 - x_1) r_{12} &\\equiv& x_2 &\\pmod{p_2} \\\\ x_2 &\\equiv& (a_2 - x_1) r_{12} &\\pmod{p_2} \\end{array}$$ Similarly we get that $$x_3 \\equiv ((a_3 - x_1) r_{13} - x_2) r_{23} \\pmod{p_3}.$$ Now, we can clearly see an emerging pattern, which can be expressed by the following code: for ( int i = 0 ; i < k ; ++ i ) { x [ i ] = a [ i ]; for ( int j = 0 ; j < i ; ++ j ) { x [ i ] = r [ j ][ i ] * ( x [ i ] - x [ j ]); x [ i ] = x [ i ] % p [ i ]; if ( x [ i ] < 0 ) x [ i ] += p [ i ]; } } So we learned how to calculate digits $x_i$ in $O(k^2)$ time. The number $a$ can now be calculated using the previously mentioned formula $$a = x_1 + x_2 \\cdot p_1 + x_3 \\cdot p_1 \\cdot p_2 + \\ldots + x_k \\cdot p_1 \\cdots p_{k-1}$$ It is worth noting that in practice, we almost probably need to compute the answer $a$ using Arbitrary-Precision Arithmetic , but the digits $x_i$ (because they are small) can usually be calculated using built-in types, and therefore Garner's algorithm is very efficient. Implementation of Garner's Algorithm \u00b6 It is convenient to implement this algorithm using Java, because it has built-in support for large numbers through the BigInteger class. Here we show an implementation that can store big numbers in the form of a set of congruence equations. It supports addition, subtraction and multiplication. And with Garner's algorithm we can convert the set of equations into the unique integer. In this code, we take 100 prime numbers greater than $10^9$ , which allows representing numbers as large as $10^{900}$ . final int SZ = 100 ; int pr [] = new int [ SZ ] ; int r [][] = new int [ SZ ][ SZ ] ; void init () { for ( int x = 1000 * 1000 * 1000 , i = 0 ; i < SZ ; ++ x ) if ( BigInteger . valueOf ( x ). isProbablePrime ( 100 )) pr [ i ++] = x ; for ( int i = 0 ; i < SZ ; ++ i ) for ( int j = i + 1 ; j < SZ ; ++ j ) r [ i ][ j ] = BigInteger . valueOf ( pr [ i ] ). modInverse ( BigInteger . valueOf ( pr [ j ] )). intValue (); } class Number { int a [] = new int [ SZ ] ; public Number () { } public Number ( int n ) { for ( int i = 0 ; i < SZ ; ++ i ) a [ i ] = n % pr [ i ] ; } public Number ( BigInteger n ) { for ( int i = 0 ; i < SZ ; ++ i ) a [ i ] = n . mod ( BigInteger . valueOf ( pr [ i ] )). intValue (); } public Number add ( Number n ) { Number result = new Number (); for ( int i = 0 ; i < SZ ; ++ i ) result . a [ i ] = ( a [ i ] + n . a [ i ] ) % pr [ i ] ; return result ; } public Number subtract ( Number n ) { Number result = new Number (); for ( int i = 0 ; i < SZ ; ++ i ) result . a [ i ] = ( a [ i ] - n . a [ i ] + pr [ i ] ) % pr [ i ] ; return result ; } public Number multiply ( Number n ) { Number result = new Number (); for ( int i = 0 ; i < SZ ; ++ i ) result . a [ i ] = ( int )(( a [ i ] * 1l * n . a [ i ] ) % pr [ i ] ); return result ; } public BigInteger bigIntegerValue ( boolean can_be_negative ) { BigInteger result = BigInteger . ZERO , mult = BigInteger . ONE ; int x [] = new int [ SZ ] ; for ( int i = 0 ; i < SZ ; ++ i ) { x [ i ] = a [ i ] ; for ( int j = 0 ; j < i ; ++ j ) { long cur = ( x [ i ] - x [ j ] ) * 1l * r [ j ][ i ] ; x [ i ] = ( int )(( cur % pr [ i ] + pr [ i ] ) % pr [ i ] ); } result = result . add ( mult . multiply ( BigInteger . valueOf ( x [ i ] ))); mult = mult . multiply ( BigInteger . valueOf ( pr [ i ] )); } if ( can_be_negative ) if ( result . compareTo ( mult . shiftRight ( 1 )) >= 0 ) result = result . subtract ( mult ); return result ; } }","title":"Garner's Algorithm"},{"location":"algebra/garners-algorithm.html#garners-algorithm","text":"A consequence of the Chinese Remainder Theorem is, that we can represent big numbers using an array of small integers. For example, let $p$ be the product of the first $1000$ primes. $p$ has around $3000$ digits. Any number $a$ less than $p$ can be represented as an array $a_1, \\ldots, a_k$ , where $a_i \\equiv a \\pmod{p_i}$ . But to do this we obviously need to know how to get back the number $a$ from its representation. One way is discussed in the article about the Chinese Remainder Theorem. In this article we discuss an alternative, Garner's Algorithm, which can also be used for this purpose.","title":"Garner's algorithm"},{"location":"algebra/garners-algorithm.html#mixed-radix-representation","text":"We can represent the number $a$ in the mixed radix representation: $$a = x_1 + x_2 p_1 + x_3 p_1 p_2 + \\ldots + x_k p_1 \\cdots p_{k-1} \\text{ with }x_i \\in [0, p_i)$$ A mixed radix representation is a positional numeral system, that's a generalization of the typical number systems, like the binary numeral system or the decimal numeral system. For instance the decimal numeral system is a positional numeral system with the radix (or base) 10. Every a number is represented as a string of digits $d_1 d_2 d_3 \\dots d_n$ between $0$ and $9$ , and E.g. the string $415$ represents the number $4 \\cdot 10^2 + 1 \\cdot 10^1 + 5 \\cdot 10^0$ . In general the string of digits $d_1 d_2 d_3 \\dots d_n$ represents the number $d_1 b^{n-1} + d_2 b^{n-2} + \\cdots + d_n b^0$ in the positional numeral system with radix $b$ . In a mixed radix system, we don't have one radix any more. The base varies from position to position.","title":"Mixed Radix Representation"},{"location":"algebra/garners-algorithm.html#garners-algorithm_1","text":"Garner's algorithm computes the digits $x_1, \\ldots, x_k$ . Notice, that the digits are relatively small. The digit $x_i$ is an integer between $0$ and $p_i - 1$ . Let $r_{ij}$ denote the inverse of $p_i$ modulo $p_j$ $$r_{ij} = (p_i)^{-1} \\pmod{p_j}$$ which can be found using the algorithm described in Modular Inverse . Substituting $a$ from the mixed radix representation into the first congruence equation we obtain $$a_1 \\equiv x_1 \\pmod{p_1}.$$ Substituting into the second equation yields $$a_2 \\equiv x_1 + x_2 p_1 \\pmod{p_2},$$ which can be rewritten by subtracting $x_1$ and dividing by $p_1$ to get $$\\begin{array}{rclr} a_2 - x_1 &\\equiv& x_2 p_1 &\\pmod{p_2} \\\\ (a_2 - x_1) r_{12} &\\equiv& x_2 &\\pmod{p_2} \\\\ x_2 &\\equiv& (a_2 - x_1) r_{12} &\\pmod{p_2} \\end{array}$$ Similarly we get that $$x_3 \\equiv ((a_3 - x_1) r_{13} - x_2) r_{23} \\pmod{p_3}.$$ Now, we can clearly see an emerging pattern, which can be expressed by the following code: for ( int i = 0 ; i < k ; ++ i ) { x [ i ] = a [ i ]; for ( int j = 0 ; j < i ; ++ j ) { x [ i ] = r [ j ][ i ] * ( x [ i ] - x [ j ]); x [ i ] = x [ i ] % p [ i ]; if ( x [ i ] < 0 ) x [ i ] += p [ i ]; } } So we learned how to calculate digits $x_i$ in $O(k^2)$ time. The number $a$ can now be calculated using the previously mentioned formula $$a = x_1 + x_2 \\cdot p_1 + x_3 \\cdot p_1 \\cdot p_2 + \\ldots + x_k \\cdot p_1 \\cdots p_{k-1}$$ It is worth noting that in practice, we almost probably need to compute the answer $a$ using Arbitrary-Precision Arithmetic , but the digits $x_i$ (because they are small) can usually be calculated using built-in types, and therefore Garner's algorithm is very efficient.","title":"Garner's algorithm"},{"location":"algebra/garners-algorithm.html#implementation-of-garners-algorithm","text":"It is convenient to implement this algorithm using Java, because it has built-in support for large numbers through the BigInteger class. Here we show an implementation that can store big numbers in the form of a set of congruence equations. It supports addition, subtraction and multiplication. And with Garner's algorithm we can convert the set of equations into the unique integer. In this code, we take 100 prime numbers greater than $10^9$ , which allows representing numbers as large as $10^{900}$ . final int SZ = 100 ; int pr [] = new int [ SZ ] ; int r [][] = new int [ SZ ][ SZ ] ; void init () { for ( int x = 1000 * 1000 * 1000 , i = 0 ; i < SZ ; ++ x ) if ( BigInteger . valueOf ( x ). isProbablePrime ( 100 )) pr [ i ++] = x ; for ( int i = 0 ; i < SZ ; ++ i ) for ( int j = i + 1 ; j < SZ ; ++ j ) r [ i ][ j ] = BigInteger . valueOf ( pr [ i ] ). modInverse ( BigInteger . valueOf ( pr [ j ] )). intValue (); } class Number { int a [] = new int [ SZ ] ; public Number () { } public Number ( int n ) { for ( int i = 0 ; i < SZ ; ++ i ) a [ i ] = n % pr [ i ] ; } public Number ( BigInteger n ) { for ( int i = 0 ; i < SZ ; ++ i ) a [ i ] = n . mod ( BigInteger . valueOf ( pr [ i ] )). intValue (); } public Number add ( Number n ) { Number result = new Number (); for ( int i = 0 ; i < SZ ; ++ i ) result . a [ i ] = ( a [ i ] + n . a [ i ] ) % pr [ i ] ; return result ; } public Number subtract ( Number n ) { Number result = new Number (); for ( int i = 0 ; i < SZ ; ++ i ) result . a [ i ] = ( a [ i ] - n . a [ i ] + pr [ i ] ) % pr [ i ] ; return result ; } public Number multiply ( Number n ) { Number result = new Number (); for ( int i = 0 ; i < SZ ; ++ i ) result . a [ i ] = ( int )(( a [ i ] * 1l * n . a [ i ] ) % pr [ i ] ); return result ; } public BigInteger bigIntegerValue ( boolean can_be_negative ) { BigInteger result = BigInteger . ZERO , mult = BigInteger . ONE ; int x [] = new int [ SZ ] ; for ( int i = 0 ; i < SZ ; ++ i ) { x [ i ] = a [ i ] ; for ( int j = 0 ; j < i ; ++ j ) { long cur = ( x [ i ] - x [ j ] ) * 1l * r [ j ][ i ] ; x [ i ] = ( int )(( cur % pr [ i ] + pr [ i ] ) % pr [ i ] ); } result = result . add ( mult . multiply ( BigInteger . valueOf ( x [ i ] ))); mult = mult . multiply ( BigInteger . valueOf ( pr [ i ] )); } if ( can_be_negative ) if ( result . compareTo ( mult . shiftRight ( 1 )) >= 0 ) result = result . subtract ( mult ); return result ; } }","title":"Implementation of Garner's Algorithm"},{"location":"algebra/gray-code.html","text":"Gray code \u00b6 Gray code is a binary numeral system where two successive values differ in only one bit. For example, the sequence of Gray codes for 3-bit numbers is: 000, 001, 011, 010, 110, 111, 101, 100, so $G(4) = 6$ . This code was invented by Frank Gray in 1953. Finding Gray code \u00b6 Let's look at the bits of number $n$ and the bits of number $G(n)$ . Notice that $i$ -th bit of $G(n)$ equals 1 only when $i$ -th bit of $n$ equals 1 and $i + 1$ -th bit equals 0 or the other way around ( $i$ -th bit equals 0 and $i + 1$ -th bit equals 1). Thus, $G(n) = n \\oplus (n >> 1)$ : int g ( int n ) { return n ^ ( n >> 1 ); } Finding inverse Gray code \u00b6 Given Gray code $g$ , restore the original number $n$ . We will move from the most significant bits to the least significant ones (the least significant bit has index 1 and the most significant bit has index $k$ ). The relation between the bits $n_i$ of number $n$ and the bits $g_i$ of number $g$ : $$\\begin{align} n_k &= g_k, \\\\ n_{k-1} &= g_{k-1} \\oplus n_k = g_k \\oplus g_{k-1}, \\\\ n_{k-2} &= g_{k-2} \\oplus n_{k-1} = g_k \\oplus g_{k-1} \\oplus g_{k-2}, \\\\ n_{k-3} &= g_{k-3} \\oplus n_{k-2} = g_k \\oplus g_{k-1} \\oplus g_{k-2} \\oplus g_{k-3}, \\vdots \\end{align}$$ The easiest way to write it in code is: int rev_g ( int g ) { int n = 0 ; for (; g ; g >>= 1 ) n ^= g ; return n ; } Practical applications \u00b6 Gray codes have some useful applications, sometimes quite unexpected: Gray code of $n$ bits forms a Hamiltonian cycle on a hypercube, where each bit corresponds to one dimension. Gray codes are used to minimize the errors in digital-to-analog signals conversion (for example, in sensors). Gray code can be used to solve the Towers of Hanoi problem. Let $n$ denote number of disks. Start with Gray code of length $n$ which consists of all zeroes ( $G(0)$ ) and move between consecutive Gray codes (from $G(i)$ to $G(i+1)$ ). Let $i$ -th bit of current Gray code represent $n$ -th disk (the least significant bit corresponds to the smallest disk and the most significant bit to the biggest disk). Since exactly one bit changes on each step, we can treat changing $i$ -th bit as moving $i$ -th disk. Notice that there is exactly one move option for each disk (except the smallest one) on each step (except start and finish positions). There are always two move options for the smallest disk but there is a strategy which will always lead to answer: if $n$ is odd then sequence of the smallest disk moves looks like $f \\to t \\to r \\to f \\to t \\to r \\to ...$ where $f$ is the initial rod, $t$ is the terminal rod and $r$ is the remaining rod), and if $n$ is even: $f \\to r \\to t \\to f \\to r \\to t \\to ...$ . Gray codes are also used in genetic algorithms theory. Practice Problems \u00b6 Gray Code [Difficulty: easy] SGU #249 \"Matrix\" [Difficulty: medium]","title":"Gray code"},{"location":"algebra/gray-code.html#gray-code","text":"Gray code is a binary numeral system where two successive values differ in only one bit. For example, the sequence of Gray codes for 3-bit numbers is: 000, 001, 011, 010, 110, 111, 101, 100, so $G(4) = 6$ . This code was invented by Frank Gray in 1953.","title":"Gray code"},{"location":"algebra/gray-code.html#finding-gray-code","text":"Let's look at the bits of number $n$ and the bits of number $G(n)$ . Notice that $i$ -th bit of $G(n)$ equals 1 only when $i$ -th bit of $n$ equals 1 and $i + 1$ -th bit equals 0 or the other way around ( $i$ -th bit equals 0 and $i + 1$ -th bit equals 1). Thus, $G(n) = n \\oplus (n >> 1)$ : int g ( int n ) { return n ^ ( n >> 1 ); }","title":"Finding Gray code"},{"location":"algebra/gray-code.html#finding-inverse-gray-code","text":"Given Gray code $g$ , restore the original number $n$ . We will move from the most significant bits to the least significant ones (the least significant bit has index 1 and the most significant bit has index $k$ ). The relation between the bits $n_i$ of number $n$ and the bits $g_i$ of number $g$ : $$\\begin{align} n_k &= g_k, \\\\ n_{k-1} &= g_{k-1} \\oplus n_k = g_k \\oplus g_{k-1}, \\\\ n_{k-2} &= g_{k-2} \\oplus n_{k-1} = g_k \\oplus g_{k-1} \\oplus g_{k-2}, \\\\ n_{k-3} &= g_{k-3} \\oplus n_{k-2} = g_k \\oplus g_{k-1} \\oplus g_{k-2} \\oplus g_{k-3}, \\vdots \\end{align}$$ The easiest way to write it in code is: int rev_g ( int g ) { int n = 0 ; for (; g ; g >>= 1 ) n ^= g ; return n ; }","title":"Finding inverse Gray code"},{"location":"algebra/gray-code.html#practical-applications","text":"Gray codes have some useful applications, sometimes quite unexpected: Gray code of $n$ bits forms a Hamiltonian cycle on a hypercube, where each bit corresponds to one dimension. Gray codes are used to minimize the errors in digital-to-analog signals conversion (for example, in sensors). Gray code can be used to solve the Towers of Hanoi problem. Let $n$ denote number of disks. Start with Gray code of length $n$ which consists of all zeroes ( $G(0)$ ) and move between consecutive Gray codes (from $G(i)$ to $G(i+1)$ ). Let $i$ -th bit of current Gray code represent $n$ -th disk (the least significant bit corresponds to the smallest disk and the most significant bit to the biggest disk). Since exactly one bit changes on each step, we can treat changing $i$ -th bit as moving $i$ -th disk. Notice that there is exactly one move option for each disk (except the smallest one) on each step (except start and finish positions). There are always two move options for the smallest disk but there is a strategy which will always lead to answer: if $n$ is odd then sequence of the smallest disk moves looks like $f \\to t \\to r \\to f \\to t \\to r \\to ...$ where $f$ is the initial rod, $t$ is the terminal rod and $r$ is the remaining rod), and if $n$ is even: $f \\to r \\to t \\to f \\to r \\to t \\to ...$ . Gray codes are also used in genetic algorithms theory.","title":"Practical applications"},{"location":"algebra/gray-code.html#practice-problems","text":"Gray Code [Difficulty: easy] SGU #249 \"Matrix\" [Difficulty: medium]","title":"Practice Problems"},{"location":"algebra/linear-diophantine-equation.html","text":"Linear Diophantine Equation \u00b6 A Linear Diophantine Equation (in two variables) is an equation of the general form: $$ax + by = c$$ where $a$ , $b$ , $c$ are given integers, and $x$ , $y$ are unknown integers. In this article, we consider several classical problems on these equations: finding one solution finding all solutions finding the number of solutions and the solutions themselves in a given interval finding a solution with minimum value of $x + y$ The degenerate case \u00b6 A degenerate case that need to be taken care of is when $a = b = 0$ . It is easy to see that we either have no solutions or infinitely many solutions, depending on whether $c = 0$ or not. In the rest of this article, we will ignore this case. Analytic solution \u00b6 When $a \\neq 0$ and $b \\neq 0$ , the equation $ax+by=c$ can be equivalently treated as either of the following: $$\\begin{align} ax &\\equiv c \\pmod b \\\\ by &\\equiv c \\pmod a \\end{align}$$ Without loss of generality, assume that $b \\neq 0$ and consider the first equation. When $a$ and $b$ are co-prime, the solution to it is given as $$x \\equiv ca^{-1} \\pmod b,$$ where $a^{-1}$ is the modular inverse of $a$ modulo $b$ . When $a$ and $b$ are not co-prime, values of $ax$ modulo $b$ for all integer $x$ are divisible by $g=\\gcd(a, b)$ , so the solution only exists when $c$ is divisible by $g$ . In this case, one of solutions can be found by reducing the equation by $g$ : $$(a/g) x \\equiv (c/g) \\pmod{b/g}.$$ By the definition of $g$ , the numbers $a/g$ and $b/g$ are co-prime, so the solution is given explicitly as $$\\begin{cases} x \\equiv (c/g)(a/g)^{-1}\\pmod{b/g},\\\\ y = \\frac{c-ax}{b}. \\end{cases}$$ Algorithmic solution \u00b6 B\u00e9zout's lemma (also called B\u00e9zout's identity) is a useful result that can be used to understand the following solution. Let $g = \\gcd(a,b)$ . Then there exist integers $x,y$ such that $ax + by = g$ . Moreover, $g$ is the least such positive integer that can be written as $ax + by$ ; all integers of the form $ax + by$ are multiples of $g$ . To find one solution of the Diophantine equation with 2 unknowns, you can use the Extended Euclidean algorithm . First, assume that $a$ and $b$ are non-negative. When we apply Extended Euclidean algorithm for $a$ and $b$ , we can find their greatest common divisor $g$ and 2 numbers $x_g$ and $y_g$ such that: $$a x_g + b y_g = g$$ If $c$ is divisible by $g = \\gcd(a, b)$ , then the given Diophantine equation has a solution, otherwise it does not have any solution. The proof is straight-forward: a linear combination of two numbers is divisible by their common divisor. Now supposed that $c$ is divisible by $g$ , then we have: $$a \\cdot x_g \\cdot \\frac{c}{g} + b \\cdot y_g \\cdot \\frac{c}{g} = c$$ Therefore one of the solutions of the Diophantine equation is: $$x_0 = x_g \\cdot \\frac{c}{g},$$ $$y_0 = y_g \\cdot \\frac{c}{g}.$$ The above idea still works when $a$ or $b$ or both of them are negative. We only need to change the sign of $x_0$ and $y_0$ when necessary. Finally, we can implement this idea as follows (note that this code does not consider the case $a = b = 0$ ): int gcd ( int a , int b , int & x , int & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } int x1 , y1 ; int d = gcd ( b , a % b , x1 , y1 ); x = y1 ; y = x1 - y1 * ( a / b ); return d ; } bool find_any_solution ( int a , int b , int c , int & x0 , int & y0 , int & g ) { g = gcd ( abs ( a ), abs ( b ), x0 , y0 ); if ( c % g ) { return false ; } x0 *= c / g ; y0 *= c / g ; if ( a < 0 ) x0 = - x0 ; if ( b < 0 ) y0 = - y0 ; return true ; } Getting all solutions \u00b6 From one solution $(x_0, y_0)$ , we can obtain all the solutions of the given equation. Let $g = \\gcd(a, b)$ and let $x_0, y_0$ be integers which satisfy the following: $$a \\cdot x_0 + b \\cdot y_0 = c$$ Now, we should see that adding $b / g$ to $x_0$ , and, at the same time subtracting $a / g$ from $y_0$ will not break the equality: $$a \\cdot \\left(x_0 + \\frac{b}{g}\\right) + b \\cdot \\left(y_0 - \\frac{a}{g}\\right) = a \\cdot x_0 + b \\cdot y_0 + a \\cdot \\frac{b}{g} - b \\cdot \\frac{a}{g} = c$$ Obviously, this process can be repeated again, so all the numbers of the form: $$x = x_0 + k \\cdot \\frac{b}{g}$$ $$y = y_0 - k \\cdot \\frac{a}{g}$$ are solutions of the given Diophantine equation. Since the equation is linear, all solutions lie on the same line, and by the definition of $g$ this is the set of all possible solutions of the given Diophantine equation. Finding the number of solutions and the solutions in a given interval \u00b6 From previous section, it should be clear that if we don't impose any restrictions on the solutions, there would be infinite number of them. So in this section, we add some restrictions on the interval of $x$ and $y$ , and we will try to count and enumerate all the solutions. Let there be two intervals: $[min_x; max_x]$ and $[min_y; max_y]$ and let's say we only want to find the solutions in these two intervals. Note that if $a$ or $b$ is $0$ , then the problem only has one solution. We don't consider this case here. First, we can find a solution which has minimum value of $x$ , such that $x \\ge min_x$ . To do this, we first find any solution of the Diophantine equation. Then, we shift this solution to get $x \\ge min_x$ (using what we know about the set of all solutions in previous section). This can be done in $O(1)$ . Denote this minimum value of $x$ by $l_{x1}$ . Similarly, we can find the maximum value of $x$ which satisfies $x \\le max_x$ . Denote this maximum value of $x$ by $r_{x1}$ . Similarly, we can find the minimum value of $y$ $(y \\ge min_y)$ and maximum value of $y$ $(y \\le max_y)$ . Denote the corresponding values of $x$ by $l_{x2}$ and $r_{x2}$ . The final solution is all solutions with x in intersection of $[l_{x1}, r_{x1}]$ and $[l_{x2}, r_{x2}]$ . Let denote this intersection by $[l_x, r_x]$ . Following is the code implementing this idea. Notice that we divide $a$ and $b$ at the beginning by $g$ . Since the equation $a x + b y = c$ is equivalent to the equation $\\frac{a}{g} x + \\frac{b}{g} y = \\frac{c}{g}$ , we can use this one instead and have $\\gcd(\\frac{a}{g}, \\frac{b}{g}) = 1$ , which simplifies the formulas. void shift_solution ( int & x , int & y , int a , int b , int cnt ) { x += cnt * b ; y -= cnt * a ; } int find_all_solutions ( int a , int b , int c , int minx , int maxx , int miny , int maxy ) { int x , y , g ; if ( ! find_any_solution ( a , b , c , x , y , g )) return 0 ; a /= g ; b /= g ; int sign_a = a > 0 ? + 1 : -1 ; int sign_b = b > 0 ? + 1 : -1 ; shift_solution ( x , y , a , b , ( minx - x ) / b ); if ( x < minx ) shift_solution ( x , y , a , b , sign_b ); if ( x > maxx ) return 0 ; int lx1 = x ; shift_solution ( x , y , a , b , ( maxx - x ) / b ); if ( x > maxx ) shift_solution ( x , y , a , b , - sign_b ); int rx1 = x ; shift_solution ( x , y , a , b , - ( miny - y ) / a ); if ( y < miny ) shift_solution ( x , y , a , b , - sign_a ); if ( y > maxy ) return 0 ; int lx2 = x ; shift_solution ( x , y , a , b , - ( maxy - y ) / a ); if ( y > maxy ) shift_solution ( x , y , a , b , sign_a ); int rx2 = x ; if ( lx2 > rx2 ) swap ( lx2 , rx2 ); int lx = max ( lx1 , lx2 ); int rx = min ( rx1 , rx2 ); if ( lx > rx ) return 0 ; return ( rx - lx ) / abs ( b ) + 1 ; } Once we have $l_x$ and $r_x$ , it is also simple to enumerate through all the solutions. Just need to iterate through $x = l_x + k \\cdot \\frac{b}{g}$ for all $k \\ge 0$ until $x = r_x$ , and find the corresponding $y$ values using the equation $a x + b y = c$ . Find the solution with minimum value of $x + y$ \u00b6 Here, $x$ and $y$ also need to be given some restriction, otherwise, the answer may become negative infinity. The idea is similar to previous section: We find any solution of the Diophantine equation, and then shift the solution to satisfy some conditions. Finally, use the knowledge of the set of all solutions to find the minimum: $$x' = x + k \\cdot \\frac{b}{g},$$ $$y' = y - k \\cdot \\frac{a}{g}.$$ Note that $x + y$ change as follows: $$x' + y' = x + y + k \\cdot \\left(\\frac{b}{g} - \\frac{a}{g}\\right) = x + y + k \\cdot \\frac{b-a}{g}$$ If $a < b$ , we need to select smallest possible value of $k$ . If $a > b$ , we need to select the largest possible value of $k$ . If $a = b$ , all solution will have the same sum $x + y$ . Practice Problems \u00b6 Spoj - Crucial Equation SGU 106 Codeforces - Ebony and Ivory Codechef - Get AC in one go LightOj - Solutions to an equation Atcoder - F - S = 1","title":"Linear Diophantine Equations"},{"location":"algebra/linear-diophantine-equation.html#linear-diophantine-equation","text":"A Linear Diophantine Equation (in two variables) is an equation of the general form: $$ax + by = c$$ where $a$ , $b$ , $c$ are given integers, and $x$ , $y$ are unknown integers. In this article, we consider several classical problems on these equations: finding one solution finding all solutions finding the number of solutions and the solutions themselves in a given interval finding a solution with minimum value of $x + y$","title":"Linear Diophantine Equation"},{"location":"algebra/linear-diophantine-equation.html#the-degenerate-case","text":"A degenerate case that need to be taken care of is when $a = b = 0$ . It is easy to see that we either have no solutions or infinitely many solutions, depending on whether $c = 0$ or not. In the rest of this article, we will ignore this case.","title":"The degenerate case"},{"location":"algebra/linear-diophantine-equation.html#analytic-solution","text":"When $a \\neq 0$ and $b \\neq 0$ , the equation $ax+by=c$ can be equivalently treated as either of the following: $$\\begin{align} ax &\\equiv c \\pmod b \\\\ by &\\equiv c \\pmod a \\end{align}$$ Without loss of generality, assume that $b \\neq 0$ and consider the first equation. When $a$ and $b$ are co-prime, the solution to it is given as $$x \\equiv ca^{-1} \\pmod b,$$ where $a^{-1}$ is the modular inverse of $a$ modulo $b$ . When $a$ and $b$ are not co-prime, values of $ax$ modulo $b$ for all integer $x$ are divisible by $g=\\gcd(a, b)$ , so the solution only exists when $c$ is divisible by $g$ . In this case, one of solutions can be found by reducing the equation by $g$ : $$(a/g) x \\equiv (c/g) \\pmod{b/g}.$$ By the definition of $g$ , the numbers $a/g$ and $b/g$ are co-prime, so the solution is given explicitly as $$\\begin{cases} x \\equiv (c/g)(a/g)^{-1}\\pmod{b/g},\\\\ y = \\frac{c-ax}{b}. \\end{cases}$$","title":"Analytic solution"},{"location":"algebra/linear-diophantine-equation.html#algorithmic-solution","text":"B\u00e9zout's lemma (also called B\u00e9zout's identity) is a useful result that can be used to understand the following solution. Let $g = \\gcd(a,b)$ . Then there exist integers $x,y$ such that $ax + by = g$ . Moreover, $g$ is the least such positive integer that can be written as $ax + by$ ; all integers of the form $ax + by$ are multiples of $g$ . To find one solution of the Diophantine equation with 2 unknowns, you can use the Extended Euclidean algorithm . First, assume that $a$ and $b$ are non-negative. When we apply Extended Euclidean algorithm for $a$ and $b$ , we can find their greatest common divisor $g$ and 2 numbers $x_g$ and $y_g$ such that: $$a x_g + b y_g = g$$ If $c$ is divisible by $g = \\gcd(a, b)$ , then the given Diophantine equation has a solution, otherwise it does not have any solution. The proof is straight-forward: a linear combination of two numbers is divisible by their common divisor. Now supposed that $c$ is divisible by $g$ , then we have: $$a \\cdot x_g \\cdot \\frac{c}{g} + b \\cdot y_g \\cdot \\frac{c}{g} = c$$ Therefore one of the solutions of the Diophantine equation is: $$x_0 = x_g \\cdot \\frac{c}{g},$$ $$y_0 = y_g \\cdot \\frac{c}{g}.$$ The above idea still works when $a$ or $b$ or both of them are negative. We only need to change the sign of $x_0$ and $y_0$ when necessary. Finally, we can implement this idea as follows (note that this code does not consider the case $a = b = 0$ ): int gcd ( int a , int b , int & x , int & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } int x1 , y1 ; int d = gcd ( b , a % b , x1 , y1 ); x = y1 ; y = x1 - y1 * ( a / b ); return d ; } bool find_any_solution ( int a , int b , int c , int & x0 , int & y0 , int & g ) { g = gcd ( abs ( a ), abs ( b ), x0 , y0 ); if ( c % g ) { return false ; } x0 *= c / g ; y0 *= c / g ; if ( a < 0 ) x0 = - x0 ; if ( b < 0 ) y0 = - y0 ; return true ; }","title":"Algorithmic solution"},{"location":"algebra/linear-diophantine-equation.html#getting-all-solutions","text":"From one solution $(x_0, y_0)$ , we can obtain all the solutions of the given equation. Let $g = \\gcd(a, b)$ and let $x_0, y_0$ be integers which satisfy the following: $$a \\cdot x_0 + b \\cdot y_0 = c$$ Now, we should see that adding $b / g$ to $x_0$ , and, at the same time subtracting $a / g$ from $y_0$ will not break the equality: $$a \\cdot \\left(x_0 + \\frac{b}{g}\\right) + b \\cdot \\left(y_0 - \\frac{a}{g}\\right) = a \\cdot x_0 + b \\cdot y_0 + a \\cdot \\frac{b}{g} - b \\cdot \\frac{a}{g} = c$$ Obviously, this process can be repeated again, so all the numbers of the form: $$x = x_0 + k \\cdot \\frac{b}{g}$$ $$y = y_0 - k \\cdot \\frac{a}{g}$$ are solutions of the given Diophantine equation. Since the equation is linear, all solutions lie on the same line, and by the definition of $g$ this is the set of all possible solutions of the given Diophantine equation.","title":"Getting all solutions"},{"location":"algebra/linear-diophantine-equation.html#finding-the-number-of-solutions-and-the-solutions-in-a-given-interval","text":"From previous section, it should be clear that if we don't impose any restrictions on the solutions, there would be infinite number of them. So in this section, we add some restrictions on the interval of $x$ and $y$ , and we will try to count and enumerate all the solutions. Let there be two intervals: $[min_x; max_x]$ and $[min_y; max_y]$ and let's say we only want to find the solutions in these two intervals. Note that if $a$ or $b$ is $0$ , then the problem only has one solution. We don't consider this case here. First, we can find a solution which has minimum value of $x$ , such that $x \\ge min_x$ . To do this, we first find any solution of the Diophantine equation. Then, we shift this solution to get $x \\ge min_x$ (using what we know about the set of all solutions in previous section). This can be done in $O(1)$ . Denote this minimum value of $x$ by $l_{x1}$ . Similarly, we can find the maximum value of $x$ which satisfies $x \\le max_x$ . Denote this maximum value of $x$ by $r_{x1}$ . Similarly, we can find the minimum value of $y$ $(y \\ge min_y)$ and maximum value of $y$ $(y \\le max_y)$ . Denote the corresponding values of $x$ by $l_{x2}$ and $r_{x2}$ . The final solution is all solutions with x in intersection of $[l_{x1}, r_{x1}]$ and $[l_{x2}, r_{x2}]$ . Let denote this intersection by $[l_x, r_x]$ . Following is the code implementing this idea. Notice that we divide $a$ and $b$ at the beginning by $g$ . Since the equation $a x + b y = c$ is equivalent to the equation $\\frac{a}{g} x + \\frac{b}{g} y = \\frac{c}{g}$ , we can use this one instead and have $\\gcd(\\frac{a}{g}, \\frac{b}{g}) = 1$ , which simplifies the formulas. void shift_solution ( int & x , int & y , int a , int b , int cnt ) { x += cnt * b ; y -= cnt * a ; } int find_all_solutions ( int a , int b , int c , int minx , int maxx , int miny , int maxy ) { int x , y , g ; if ( ! find_any_solution ( a , b , c , x , y , g )) return 0 ; a /= g ; b /= g ; int sign_a = a > 0 ? + 1 : -1 ; int sign_b = b > 0 ? + 1 : -1 ; shift_solution ( x , y , a , b , ( minx - x ) / b ); if ( x < minx ) shift_solution ( x , y , a , b , sign_b ); if ( x > maxx ) return 0 ; int lx1 = x ; shift_solution ( x , y , a , b , ( maxx - x ) / b ); if ( x > maxx ) shift_solution ( x , y , a , b , - sign_b ); int rx1 = x ; shift_solution ( x , y , a , b , - ( miny - y ) / a ); if ( y < miny ) shift_solution ( x , y , a , b , - sign_a ); if ( y > maxy ) return 0 ; int lx2 = x ; shift_solution ( x , y , a , b , - ( maxy - y ) / a ); if ( y > maxy ) shift_solution ( x , y , a , b , sign_a ); int rx2 = x ; if ( lx2 > rx2 ) swap ( lx2 , rx2 ); int lx = max ( lx1 , lx2 ); int rx = min ( rx1 , rx2 ); if ( lx > rx ) return 0 ; return ( rx - lx ) / abs ( b ) + 1 ; } Once we have $l_x$ and $r_x$ , it is also simple to enumerate through all the solutions. Just need to iterate through $x = l_x + k \\cdot \\frac{b}{g}$ for all $k \\ge 0$ until $x = r_x$ , and find the corresponding $y$ values using the equation $a x + b y = c$ .","title":"Finding the number of solutions and the solutions in a given interval"},{"location":"algebra/linear-diophantine-equation.html#find-the-solution-with-minimum-value-of-x-y","text":"Here, $x$ and $y$ also need to be given some restriction, otherwise, the answer may become negative infinity. The idea is similar to previous section: We find any solution of the Diophantine equation, and then shift the solution to satisfy some conditions. Finally, use the knowledge of the set of all solutions to find the minimum: $$x' = x + k \\cdot \\frac{b}{g},$$ $$y' = y - k \\cdot \\frac{a}{g}.$$ Note that $x + y$ change as follows: $$x' + y' = x + y + k \\cdot \\left(\\frac{b}{g} - \\frac{a}{g}\\right) = x + y + k \\cdot \\frac{b-a}{g}$$ If $a < b$ , we need to select smallest possible value of $k$ . If $a > b$ , we need to select the largest possible value of $k$ . If $a = b$ , all solution will have the same sum $x + y$ .","title":"Find the solution with minimum value of x + y"},{"location":"algebra/linear-diophantine-equation.html#practice-problems","text":"Spoj - Crucial Equation SGU 106 Codeforces - Ebony and Ivory Codechef - Get AC in one go LightOj - Solutions to an equation Atcoder - F - S = 1","title":"Practice Problems"},{"location":"algebra/linear_congruence_equation.html","text":"Linear Congruence Equation \u00b6 This equation is of the form: $$a \\cdot x \\equiv b \\pmod n,$$ where $a$ , $b$ and $n$ are given integers and $x$ is an unknown integer. It is required to find the value $x$ from the interval $[0, n-1]$ (clearly, on the entire number line there can be infinitely many solutions that will differ from each other in $n \\cdot k$ , where $k$ is any integer). If the solution is not unique, then we will consider how to get all the solutions. Solution by finding the inverse element \u00b6 Let us first consider a simpler case where $a$ and $n$ are coprime ( $\\gcd(a, n) = 1$ ). Then one can find the inverse of $a$ , and multiplying both sides of the equation with the inverse, and we can get a unique solution. $$x \\equiv b \\cdot a ^ {- 1} \\pmod n$$ Now consider the case where $a$ and $n$ are not coprime ( $\\gcd(a, n) \\ne 1$ ). Then the solution will not always exist (for example $2 \\cdot x \\equiv 1 \\pmod 4$ has no solution). Let $g = \\gcd(a, n)$ , i.e. the greatest common divisor of $a$ and $n$ (which in this case is greater than one). Then, if $b$ is not divisible by $g$ , there is no solution. In fact, for any $x$ the left side of the equation $a \\cdot x \\pmod n$ , is always divisible by $g$ , while the right-hand side is not divisible by it, hence it follows that there are no solutions. If $g$ divides $b$ , then by dividing both sides of the equation by $g$ (i.e. dividing $a$ , $b$ and $n$ by $g$ ), we receive a new equation: $$a^\\prime \\cdot x \\equiv b^\\prime \\pmod{n^\\prime}$$ in which $a^\\prime$ and $n^\\prime$ are already relatively prime, and we have already learned how to handle such an equation. We get $x^\\prime$ as solution for $x$ . It is clear that this $x^\\prime$ will also be a solution of the original equation. However it will not be the only solution . It can be shown that the original equation has exactly $g$ solutions, and they will look like this: $$x_i \\equiv (x^\\prime + i\\cdot n^\\prime) \\pmod n \\quad \\text{for } i = 0 \\ldots g-1$$ Summarizing, we can say that the number of solutions of the linear congruence equation is equal to either $g = \\gcd(a, n)$ or to zero. Solution with the Extended Euclidean Algorithm \u00b6 We can rewrite the linear congruence to the following Diophantine equation: $$a \\cdot x + n \\cdot k = b,$$ where $x$ and $k$ are unknown integers. The method of solving this equation is described in the corresponding article Linear Diophantine equations and it consists of applying the Extended Euclidean Algorithm . It also describes the method of obtaining all solutions of this equation from one found solution, and incidentally this method, when carefully considered, is absolutely equivalent to the method described in the previous section.","title":"Linear Congruence Equation"},{"location":"algebra/linear_congruence_equation.html#linear-congruence-equation","text":"This equation is of the form: $$a \\cdot x \\equiv b \\pmod n,$$ where $a$ , $b$ and $n$ are given integers and $x$ is an unknown integer. It is required to find the value $x$ from the interval $[0, n-1]$ (clearly, on the entire number line there can be infinitely many solutions that will differ from each other in $n \\cdot k$ , where $k$ is any integer). If the solution is not unique, then we will consider how to get all the solutions.","title":"Linear Congruence Equation"},{"location":"algebra/linear_congruence_equation.html#solution-by-finding-the-inverse-element","text":"Let us first consider a simpler case where $a$ and $n$ are coprime ( $\\gcd(a, n) = 1$ ). Then one can find the inverse of $a$ , and multiplying both sides of the equation with the inverse, and we can get a unique solution. $$x \\equiv b \\cdot a ^ {- 1} \\pmod n$$ Now consider the case where $a$ and $n$ are not coprime ( $\\gcd(a, n) \\ne 1$ ). Then the solution will not always exist (for example $2 \\cdot x \\equiv 1 \\pmod 4$ has no solution). Let $g = \\gcd(a, n)$ , i.e. the greatest common divisor of $a$ and $n$ (which in this case is greater than one). Then, if $b$ is not divisible by $g$ , there is no solution. In fact, for any $x$ the left side of the equation $a \\cdot x \\pmod n$ , is always divisible by $g$ , while the right-hand side is not divisible by it, hence it follows that there are no solutions. If $g$ divides $b$ , then by dividing both sides of the equation by $g$ (i.e. dividing $a$ , $b$ and $n$ by $g$ ), we receive a new equation: $$a^\\prime \\cdot x \\equiv b^\\prime \\pmod{n^\\prime}$$ in which $a^\\prime$ and $n^\\prime$ are already relatively prime, and we have already learned how to handle such an equation. We get $x^\\prime$ as solution for $x$ . It is clear that this $x^\\prime$ will also be a solution of the original equation. However it will not be the only solution . It can be shown that the original equation has exactly $g$ solutions, and they will look like this: $$x_i \\equiv (x^\\prime + i\\cdot n^\\prime) \\pmod n \\quad \\text{for } i = 0 \\ldots g-1$$ Summarizing, we can say that the number of solutions of the linear congruence equation is equal to either $g = \\gcd(a, n)$ or to zero.","title":"Solution by finding the inverse element"},{"location":"algebra/linear_congruence_equation.html#solution-with-the-extended-euclidean-algorithm","text":"We can rewrite the linear congruence to the following Diophantine equation: $$a \\cdot x + n \\cdot k = b,$$ where $x$ and $k$ are unknown integers. The method of solving this equation is described in the corresponding article Linear Diophantine equations and it consists of applying the Extended Euclidean Algorithm . It also describes the method of obtaining all solutions of this equation from one found solution, and incidentally this method, when carefully considered, is absolutely equivalent to the method described in the previous section.","title":"Solution with the Extended Euclidean Algorithm"},{"location":"algebra/module-inverse.html","text":"Modular Multiplicative Inverse \u00b6 Definition \u00b6 A modular multiplicative inverse of an integer $a$ is an integer $x$ such that $a \\cdot x$ is congruent to $1$ modular some modulus $m$ . To write it in a formal way: we want to find an integer $x$ so that $$a \\cdot x \\equiv 1 \\mod m.$$ We will also denote $x$ simply with $a^{-1}$ . We should note that the modular inverse does not always exist. For example, let $m = 4$ , $a = 2$ . By checking all possible values modulo $m$ , it should become clear that we cannot find $a^{-1}$ satisfying the above equation. It can be proven that the modular inverse exists if and only if $a$ and $m$ are relatively prime (i.e. $\\gcd(a, m) = 1$ ). In this article, we present two methods for finding the modular inverse in case it exists, and one method for finding the modular inverse for all numbers in linear time. Finding the Modular Inverse using Extended Euclidean algorithm \u00b6 Consider the following equation (with unknown $x$ and $y$ ): $$a \\cdot x + m \\cdot y = 1$$ This is a Linear Diophantine equation in two variables . As shown in the linked article, when $\\gcd(a, m) = 1$ , the equation has a solution which can be found using the extended Euclidean algorithm . Note that $\\gcd(a, m) = 1$ is also the condition for the modular inverse to exist. Now, if we take modulo $m$ of both sides, we can get rid of $m \\cdot y$ , and the equation becomes: $$a \\cdot x \\equiv 1 \\mod m$$ Thus, the modular inverse of $a$ is $x$ . The implementation is as follows: int x , y ; int g = extended_euclidean ( a , m , x , y ); if ( g != 1 ) { cout << \"No solution!\" ; } else { x = ( x % m + m ) % m ; cout << x << endl ; } Notice that the way we modify x . The resulting x from the extended Euclidean algorithm may be negative, so x % m might also be negative, and we first have to add m to make it positive. Finding the Modular Inverse using Binary Exponentiation \u00b6 Another method for finding modular inverse is to use Euler's theorem, which states that the following congruence is true if $a$ and $m$ are relatively prime: $$a^{\\phi (m)} \\equiv 1 \\mod m$$ $\\phi$ is Euler's Totient function . Again, note that $a$ and $m$ being relative prime was also the condition for the modular inverse to exist. If $m$ is a prime number, this simplifies to Fermat's little theorem : $$a^{m - 1} \\equiv 1 \\mod m$$ Multiply both sides of the above equations by $a^{-1}$ , and we get: For an arbitrary (but coprime) modulus $m$ : $a ^ {\\phi (m) - 1} \\equiv a ^{-1} \\mod m$ For a prime modulus $m$ : $a ^ {m - 2} \\equiv a ^ {-1} \\mod m$ From these results, we can easily find the modular inverse using the binary exponentiation algorithm , which works in $O(\\log m)$ time. Even though this method is easier to understand than the method described in previous paragraph, in the case when $m$ is not a prime number, we need to calculate Euler phi function, which involves factorization of $m$ , which might be very hard. If the prime factorization of $m$ is known, then the complexity of this method is $O(\\log m)$ . Finding the modular inverse for prime moduli using Euclidean Division \u00b6 Given a prime modulus $m > a$ (or we can apply modulo to make it smaller in 1 step), according to Euclidean Division $$m = k \\cdot a + r$$ where $k = \\left\\lfloor \\frac{m}{a} \\right\\rfloor$ and $r = m \\bmod a$ , then $$ \\begin{align*} & \\implies & 0 & \\equiv k \\cdot a + r & \\mod m \\\\ & \\iff & r & \\equiv -k \\cdot a & \\mod m \\\\ & \\iff & r \\cdot a^{-1} & \\equiv -k & \\mod m \\\\ & \\iff & a^{-1} & \\equiv -k \\cdot r^{-1} & \\mod m \\end{align*} $$ Note that this reasoning does not hold if $m$ is not prime, since the existence of $a^{-1}$ does not imply the existence of $r^{-1}$ in the general case. To see this, lets try to calculate $5^{-1}$ modulo $12$ with the above formula. We would like to arrive at $5$ , since $5 \\cdot 5 \\equiv 1 \\bmod 12$ . However, $12 = 2 \\cdot 5 + 2$ , and we have $k=2$ and $r=2$ , with $2$ being not invertible modulo $12$ . If the modulus is prime however, all $a$ with $0 < a < m$ are invertible modulo $m$ , and we can have the following recursive function (in C++) for computing the modular inverse for number $a$ with respect to $m$ int inv ( int a ) { return a <= 1 ? a : m - ( long long )( m / a ) * inv ( m % a ) % m ; } The exact time complexity of the this recursion is not known. It's is somewhere between $O(\\frac{\\log m}{\\log\\log m})$ and $O(m^{\\frac{1}{3} - \\frac{2}{177} + \\epsilon})$ . See On the length of Pierce expansions . In practice this implementation is fast, e.g. for the modulus $10^9 + 7$ it will always finish in less than 50 iterations. Applying this formula, we can also precompute the modular inverse for every number in the range $[1, m-1]$ in $O(m)$ . inv [ 1 ] = 1 ; for ( int a = 2 ; a < m ; ++ a ) inv [ a ] = m - ( long long )( m / a ) * inv [ m % a ] % m ; Finding the modular inverse for array of numbers modulo $m$ \u00b6 Suppose we are given an array and we want to find modular inverse for all numbers in it (all of them are invertible). Instead of computing the inverse for every number, we can expand the fraction by the prefix product (excluding itself) and suffix product (excluding itself), and end up only computing a single inverse instead. $$ \\begin{align} x_i^{-1} &= \\frac{1}{x_i} = \\frac{\\overbrace{x_1 \\cdot x_2 \\cdots x_{i-1}}^{\\text{prefix}_{i-1}} \\cdot ~1~ \\cdot \\overbrace{x_{i+1} \\cdot x_{i+2} \\cdots x_n}^{\\text{suffix}_{i+1}}}{x_1 \\cdot x_2 \\cdots x_{i-1} \\cdot x_i \\cdot x_{i+1} \\cdot x_{i+2} \\cdots x_n} \\\\ &= \\text{prefix}_{i-1} \\cdot \\text{suffix}_{i+1} \\cdot \\left(x_1 \\cdot x_2 \\cdots x_n\\right)^{-1} \\end{align} $$ In the code we can just make a prefix product array (exclude itself, start from the identity element), compute the modular inverse for the product of all numbers and than multiply it by the prefix product and suffix product (exclude itself). The suffix product is computed by iterating from the back to the front. std :: vector < int > invs ( const std :: vector < int > & a , int m ) { int n = a . size (); if ( n == 0 ) return {}; std :: vector < int > b ( n ); int v = 1 ; for ( int i = 0 ; i != n ; ++ i ) { b [ i ] = v ; v = static_cast < long long > ( v ) * a [ i ] % m ; } int x , y ; extended_euclidean ( v , m , x , y ); x = ( x % m + m ) % m ; for ( int i = n - 1 ; i >= 0 ; -- i ) { b [ i ] = static_cast < long long > ( x ) * b [ i ] % m ; x = static_cast < long long > ( x ) * a [ i ] % m ; } return b ; } Practice Problems \u00b6 UVa 11904 - One Unit Machine Hackerrank - Longest Increasing Subsequence Arrays Codeforces 300C - Beautiful Numbers Codeforces 622F - The Sum of the k-th Powers Codeforces 717A - Festival Organization Codeforces 896D - Nephren Runs a Cinema","title":"Modular Inverse"},{"location":"algebra/module-inverse.html#modular-multiplicative-inverse","text":"","title":"Modular Multiplicative Inverse"},{"location":"algebra/module-inverse.html#definition","text":"A modular multiplicative inverse of an integer $a$ is an integer $x$ such that $a \\cdot x$ is congruent to $1$ modular some modulus $m$ . To write it in a formal way: we want to find an integer $x$ so that $$a \\cdot x \\equiv 1 \\mod m.$$ We will also denote $x$ simply with $a^{-1}$ . We should note that the modular inverse does not always exist. For example, let $m = 4$ , $a = 2$ . By checking all possible values modulo $m$ , it should become clear that we cannot find $a^{-1}$ satisfying the above equation. It can be proven that the modular inverse exists if and only if $a$ and $m$ are relatively prime (i.e. $\\gcd(a, m) = 1$ ). In this article, we present two methods for finding the modular inverse in case it exists, and one method for finding the modular inverse for all numbers in linear time.","title":"Definition"},{"location":"algebra/module-inverse.html#finding-the-modular-inverse-using-extended-euclidean-algorithm","text":"Consider the following equation (with unknown $x$ and $y$ ): $$a \\cdot x + m \\cdot y = 1$$ This is a Linear Diophantine equation in two variables . As shown in the linked article, when $\\gcd(a, m) = 1$ , the equation has a solution which can be found using the extended Euclidean algorithm . Note that $\\gcd(a, m) = 1$ is also the condition for the modular inverse to exist. Now, if we take modulo $m$ of both sides, we can get rid of $m \\cdot y$ , and the equation becomes: $$a \\cdot x \\equiv 1 \\mod m$$ Thus, the modular inverse of $a$ is $x$ . The implementation is as follows: int x , y ; int g = extended_euclidean ( a , m , x , y ); if ( g != 1 ) { cout << \"No solution!\" ; } else { x = ( x % m + m ) % m ; cout << x << endl ; } Notice that the way we modify x . The resulting x from the extended Euclidean algorithm may be negative, so x % m might also be negative, and we first have to add m to make it positive.","title":"Finding the Modular Inverse using Extended Euclidean algorithm"},{"location":"algebra/module-inverse.html#finding-the-modular-inverse-using-binary-exponentiation","text":"Another method for finding modular inverse is to use Euler's theorem, which states that the following congruence is true if $a$ and $m$ are relatively prime: $$a^{\\phi (m)} \\equiv 1 \\mod m$$ $\\phi$ is Euler's Totient function . Again, note that $a$ and $m$ being relative prime was also the condition for the modular inverse to exist. If $m$ is a prime number, this simplifies to Fermat's little theorem : $$a^{m - 1} \\equiv 1 \\mod m$$ Multiply both sides of the above equations by $a^{-1}$ , and we get: For an arbitrary (but coprime) modulus $m$ : $a ^ {\\phi (m) - 1} \\equiv a ^{-1} \\mod m$ For a prime modulus $m$ : $a ^ {m - 2} \\equiv a ^ {-1} \\mod m$ From these results, we can easily find the modular inverse using the binary exponentiation algorithm , which works in $O(\\log m)$ time. Even though this method is easier to understand than the method described in previous paragraph, in the case when $m$ is not a prime number, we need to calculate Euler phi function, which involves factorization of $m$ , which might be very hard. If the prime factorization of $m$ is known, then the complexity of this method is $O(\\log m)$ .","title":"Finding the Modular Inverse using Binary Exponentiation"},{"location":"algebra/module-inverse.html#finding-the-modular-inverse-for-prime-moduli-using-euclidean-division","text":"Given a prime modulus $m > a$ (or we can apply modulo to make it smaller in 1 step), according to Euclidean Division $$m = k \\cdot a + r$$ where $k = \\left\\lfloor \\frac{m}{a} \\right\\rfloor$ and $r = m \\bmod a$ , then $$ \\begin{align*} & \\implies & 0 & \\equiv k \\cdot a + r & \\mod m \\\\ & \\iff & r & \\equiv -k \\cdot a & \\mod m \\\\ & \\iff & r \\cdot a^{-1} & \\equiv -k & \\mod m \\\\ & \\iff & a^{-1} & \\equiv -k \\cdot r^{-1} & \\mod m \\end{align*} $$ Note that this reasoning does not hold if $m$ is not prime, since the existence of $a^{-1}$ does not imply the existence of $r^{-1}$ in the general case. To see this, lets try to calculate $5^{-1}$ modulo $12$ with the above formula. We would like to arrive at $5$ , since $5 \\cdot 5 \\equiv 1 \\bmod 12$ . However, $12 = 2 \\cdot 5 + 2$ , and we have $k=2$ and $r=2$ , with $2$ being not invertible modulo $12$ . If the modulus is prime however, all $a$ with $0 < a < m$ are invertible modulo $m$ , and we can have the following recursive function (in C++) for computing the modular inverse for number $a$ with respect to $m$ int inv ( int a ) { return a <= 1 ? a : m - ( long long )( m / a ) * inv ( m % a ) % m ; } The exact time complexity of the this recursion is not known. It's is somewhere between $O(\\frac{\\log m}{\\log\\log m})$ and $O(m^{\\frac{1}{3} - \\frac{2}{177} + \\epsilon})$ . See On the length of Pierce expansions . In practice this implementation is fast, e.g. for the modulus $10^9 + 7$ it will always finish in less than 50 iterations. Applying this formula, we can also precompute the modular inverse for every number in the range $[1, m-1]$ in $O(m)$ . inv [ 1 ] = 1 ; for ( int a = 2 ; a < m ; ++ a ) inv [ a ] = m - ( long long )( m / a ) * inv [ m % a ] % m ;","title":"Finding the modular inverse for prime moduli using Euclidean Division"},{"location":"algebra/module-inverse.html#finding-the-modular-inverse-for-array-of-numbers-modulo-m","text":"Suppose we are given an array and we want to find modular inverse for all numbers in it (all of them are invertible). Instead of computing the inverse for every number, we can expand the fraction by the prefix product (excluding itself) and suffix product (excluding itself), and end up only computing a single inverse instead. $$ \\begin{align} x_i^{-1} &= \\frac{1}{x_i} = \\frac{\\overbrace{x_1 \\cdot x_2 \\cdots x_{i-1}}^{\\text{prefix}_{i-1}} \\cdot ~1~ \\cdot \\overbrace{x_{i+1} \\cdot x_{i+2} \\cdots x_n}^{\\text{suffix}_{i+1}}}{x_1 \\cdot x_2 \\cdots x_{i-1} \\cdot x_i \\cdot x_{i+1} \\cdot x_{i+2} \\cdots x_n} \\\\ &= \\text{prefix}_{i-1} \\cdot \\text{suffix}_{i+1} \\cdot \\left(x_1 \\cdot x_2 \\cdots x_n\\right)^{-1} \\end{align} $$ In the code we can just make a prefix product array (exclude itself, start from the identity element), compute the modular inverse for the product of all numbers and than multiply it by the prefix product and suffix product (exclude itself). The suffix product is computed by iterating from the back to the front. std :: vector < int > invs ( const std :: vector < int > & a , int m ) { int n = a . size (); if ( n == 0 ) return {}; std :: vector < int > b ( n ); int v = 1 ; for ( int i = 0 ; i != n ; ++ i ) { b [ i ] = v ; v = static_cast < long long > ( v ) * a [ i ] % m ; } int x , y ; extended_euclidean ( v , m , x , y ); x = ( x % m + m ) % m ; for ( int i = n - 1 ; i >= 0 ; -- i ) { b [ i ] = static_cast < long long > ( x ) * b [ i ] % m ; x = static_cast < long long > ( x ) * a [ i ] % m ; } return b ; }","title":"Finding the modular inverse for array of numbers modulo $m$"},{"location":"algebra/module-inverse.html#practice-problems","text":"UVa 11904 - One Unit Machine Hackerrank - Longest Increasing Subsequence Arrays Codeforces 300C - Beautiful Numbers Codeforces 622F - The Sum of the k-th Powers Codeforces 717A - Festival Organization Codeforces 896D - Nephren Runs a Cinema","title":"Practice Problems"},{"location":"algebra/montgomery_multiplication.html","text":"Montgomery Multiplication \u00b6 Many algorithms in number theory, like prime testing or integer factorization , and in cryptography, like RSA, require lots of operations modulo a large number. A multiplications like $x y \\bmod{n}$ is quite slow to compute with the typical algorithms, since it requires a division to know how many times $n$ has to be subtracted from the product. And division is a really expensive operation, especially with big numbers. The Montgomery (modular) multiplication is a method that allows computing such multiplications faster. Instead of dividing the product and subtracting $n$ multiple times, it adds multiples of $n$ to cancel out the lower bits and then just discards the lower bits. Montgomery representation \u00b6 However the Montgomery multiplication doesn't come for free. The algorithm works only in the Montgomery space . And we need to transform our numbers into that space, before we can start multiplying. For the space we need a positive integer $r \\ge n$ coprime to $n$ , i.e. $\\gcd(n, r) = 1$ . In practice we always choose $r$ to be $2^m$ for a positive integer $m$ , since multiplications, divisions and modulo $r$ operations can then be efficiently implemented using shifts and other bit operations. $n$ will be an odd number in pretty much all applications, since it is not hard to factorize an even number. So every power of $2$ will be coprime to $n$ . The representative $\\bar{x}$ of a number $x$ in the Montgomery space is defined as: $$\\bar{x} := x \\cdot r \\bmod n$$ Notice, the transformation is actually such a multiplication that we want to optimize. So this is still an expensive operation. However you only need to transform a number once into the space. As soon as you are in the Montgomery space, you can perform as many operations as you want efficiently. And at the end you transform the final result back. So as long as you are doing lots of operations modulo $n$ , this will be no problem. Inside the Montgomery space you can still perform most operations as usual. You can add two elements ( $x \\cdot r + y \\cdot r \\equiv (x + y) \\cdot r \\bmod n$ ), subtract, check for equality, and even compute the greatest common divisor of a number with $n$ (since $\\gcd(n, r) = 1$ ). All with the usual algorithms. However this is not the case for multiplication. We expect the result to be: $$\\bar{x} * \\bar{y} = \\overline{x \\cdot y} = (x \\cdot y) \\cdot r \\bmod n.$$ But the normal multiplication will give us: $$\\bar{x} \\cdot \\bar{y} = (x \\cdot y) \\cdot r \\cdot r \\bmod n.$$ Therefore the multiplication in the Montgomery space is defined as: $$\\bar{x} * \\bar{y} := \\bar{x} \\cdot \\bar{y} \\cdot r^{-1} \\bmod n.$$ Montgomery reduction \u00b6 The multiplication of two numbers in the Montgomery space requires an efficient computation of $x \\cdot r^{-1} \\bmod n$ . This operation is called the Montgomery reduction , and is also known as the algorithm REDC . Because $\\gcd(n, r) = 1$ , we know that there are two numbers $r^{-1}$ and $n^{\\prime}$ with $0 < r^{-1}, n^{\\prime} < n$ with $$r \\cdot r^{-1} + n \\cdot n^{\\prime} = 1.$$ Both $r^{-1}$ and $n^{\\prime}$ can be computed using the Extended Euclidean algorithm . Using this identity we can write $x \\cdot r^{-1}$ as: $$\\begin{aligned} x \\cdot r^{-1} &= x \\cdot r \\cdot r^{-1} / r = x \\cdot (-n \\cdot n^{\\prime} + 1) / r \\\\ &= (-x \\cdot n \\cdot n^{\\prime} + x) / r \\equiv (-x \\cdot n \\cdot n^{\\prime} + l \\cdot r \\cdot n + x) / r \\bmod n\\\\ &\\equiv ((-x \\cdot n^{\\prime} + l \\cdot r) \\cdot n + x) / r \\bmod n \\end{aligned}$$ The equivalences hold for any arbitrary integer $l$ . This means, that we can add or subtract an arbitrary multiple of $r$ to $x \\cdot n^{\\prime}$ , or in other words, we can compute $q := x \\cdot n^{\\prime}$ modulo $r$ . This gives us the following algorithm to compute $x \\cdot r^{-1} \\bmod n$ : function reduce(x): q = (x mod r) * n' mod r a = (x - q * n) / r if a < 0: a += n return a Since $x < n \\cdot n < r \\cdot n$ (even if $x$ is the product of a multiplication) and $q \\cdot n < r \\cdot n$ we know that $-n < (x - q \\cdot n) / r < n$ . Therefore the final modulo operation is implemented using a single check and one addition. As we see, we can perform the Montgomery reduction without any heavy modulo operations. If we choose $r$ as a power of $2$ , the modulo operations and divisions in the algorithm can be computed using bitmasking and shifting. A second application of the Montgomery reduction is to transfer a number back from the Montgomery space into the normal space. Fast inverse trick \u00b6 For computing the inverse $n^{\\prime} := n^{-1} \\bmod r$ efficiently, we can use the following trick (which is inspired from the Newton's method): $$a \\cdot x \\equiv 1 \\bmod 2^k \\Longrightarrow a \\cdot x \\cdot (2 - a \\cdot x) \\equiv 1 \\bmod 2^{2k}$$ This can easily be proven. If we have $a \\cdot x = 1 + m \\cdot 2^k$ , then we have: $$\\begin{aligned} a \\cdot x \\cdot (2 - a \\cdot x) &= 2 \\cdot a \\cdot x - (a \\cdot x)^2 \\\\ &= 2 \\cdot (1 + m \\cdot 2^k) - (1 + m \\cdot 2^k)^2 \\\\ &= 2 + 2 \\cdot m \\cdot 2^k - 1 - 2 \\cdot m \\cdot 2^k - m^2 \\cdot 2^{2k} \\\\ &= 1 - m^2 \\cdot 2^{2k} \\\\ &\\equiv 1 \\bmod 2^{2k}. \\end{aligned}$$ This means we can start with $x = 1$ as the inverse of $a$ modulo $2^1$ , apply the trick a few times and in each iteration we double the number of correct bits of $x$ . Implementation \u00b6 Using the GCC compiler we can compute $x \\cdot y \\bmod n$ still efficiently, when all three numbers are 64 bit integer, since the compiler supports 128 bit integer with the types __int128 and __uint128 . long long result = ( __int128 ) x * y % n ; However there is no type for 256 bit integer. Therefore we will here show an implementation for a 128 bit multiplication. using u64 = uint64_t ; using u128 = __uint128_t ; using i128 = __int128_t ; struct u256 { u128 high , low ; static u256 mult ( u128 x , u128 y ) { u64 a = x >> 64 , b = x ; u64 c = y >> 64 , d = y ; // (a*2^64 + b) * (c*2^64 + d) = // (a*c) * 2^128 + (a*d + b*c)*2^64 + (b*d) u128 ac = ( u128 ) a * c ; u128 ad = ( u128 ) a * d ; u128 bc = ( u128 ) b * c ; u128 bd = ( u128 ) b * d ; u128 carry = ( u128 )( u64 ) ad + ( u128 )( u64 ) bc + ( bd >> 64u ); u128 high = ac + ( ad >> 64u ) + ( bc >> 64u ) + ( carry >> 64u ); u128 low = ( ad << 64u ) + ( bc << 64u ) + bd ; return { high , low }; } }; struct Montgomery { Montgomery ( u128 n ) : mod ( n ), inv ( 1 ) { for ( int i = 0 ; i < 7 ; i ++ ) inv *= 2 - n * inv ; } u128 init ( u128 x ) { x %= mod ; for ( int i = 0 ; i < 128 ; i ++ ) { x <<= 1 ; if ( x >= mod ) x -= mod ; } return x ; } u128 reduce ( u256 x ) { u128 q = x . low * inv ; i128 a = x . high - u256 :: mult ( q , mod ). high ; if ( a < 0 ) a += mod ; return a ; } u128 mult ( u128 a , u128 b ) { return reduce ( u256 :: mult ( a , b )); } u128 mod , inv ; }; Fast transformation \u00b6 The current method of transforming a number into Montgomery space is pretty slow. There are faster ways. You can notice the following relation: $$\\bar{x} := x \\cdot r \\bmod n = x \\cdot r^2 / r = x * r^2$$ Transforming a number into the space is just a multiplication inside the space of the number with $r^2$ . Therefore we can precompute $r^2 \\bmod n$ and just perform a multiplication instead of shifting the number 128 times. In the following code we initialize r2 with -n % n , which is equivalent to $r - n \\equiv r \\bmod n$ , shift it 4 times to get $r \\cdot 2^4 \\bmod n$ . This number can be interpreted as $2^4$ in Montgomery space. If we square it $5$ times, we get $(2^4)^{2^5} = (2^4)^{32} = 2^{128} = r$ in Montgomery space, which is exactly $r^2 \\bmod n$ . struct Montgomery { Montgomery(u128 n) : mod(n), inv(1), r2(-n % n) { for (int i = 0; i < 7; i++) inv *= 2 - n * inv; for (int i = 0; i < 4; i++) { r2 <<= 1; if (r2 >= mod) r2 -= mod; } for (int i = 0; i < 5; i++) r2 = mul(r2, r2); } u128 init(u128 x) { return mult(x, r2); } u128 mod, inv, r2; };","title":"Montgomery Multiplication"},{"location":"algebra/montgomery_multiplication.html#montgomery-multiplication","text":"Many algorithms in number theory, like prime testing or integer factorization , and in cryptography, like RSA, require lots of operations modulo a large number. A multiplications like $x y \\bmod{n}$ is quite slow to compute with the typical algorithms, since it requires a division to know how many times $n$ has to be subtracted from the product. And division is a really expensive operation, especially with big numbers. The Montgomery (modular) multiplication is a method that allows computing such multiplications faster. Instead of dividing the product and subtracting $n$ multiple times, it adds multiples of $n$ to cancel out the lower bits and then just discards the lower bits.","title":"Montgomery Multiplication"},{"location":"algebra/montgomery_multiplication.html#montgomery-representation","text":"However the Montgomery multiplication doesn't come for free. The algorithm works only in the Montgomery space . And we need to transform our numbers into that space, before we can start multiplying. For the space we need a positive integer $r \\ge n$ coprime to $n$ , i.e. $\\gcd(n, r) = 1$ . In practice we always choose $r$ to be $2^m$ for a positive integer $m$ , since multiplications, divisions and modulo $r$ operations can then be efficiently implemented using shifts and other bit operations. $n$ will be an odd number in pretty much all applications, since it is not hard to factorize an even number. So every power of $2$ will be coprime to $n$ . The representative $\\bar{x}$ of a number $x$ in the Montgomery space is defined as: $$\\bar{x} := x \\cdot r \\bmod n$$ Notice, the transformation is actually such a multiplication that we want to optimize. So this is still an expensive operation. However you only need to transform a number once into the space. As soon as you are in the Montgomery space, you can perform as many operations as you want efficiently. And at the end you transform the final result back. So as long as you are doing lots of operations modulo $n$ , this will be no problem. Inside the Montgomery space you can still perform most operations as usual. You can add two elements ( $x \\cdot r + y \\cdot r \\equiv (x + y) \\cdot r \\bmod n$ ), subtract, check for equality, and even compute the greatest common divisor of a number with $n$ (since $\\gcd(n, r) = 1$ ). All with the usual algorithms. However this is not the case for multiplication. We expect the result to be: $$\\bar{x} * \\bar{y} = \\overline{x \\cdot y} = (x \\cdot y) \\cdot r \\bmod n.$$ But the normal multiplication will give us: $$\\bar{x} \\cdot \\bar{y} = (x \\cdot y) \\cdot r \\cdot r \\bmod n.$$ Therefore the multiplication in the Montgomery space is defined as: $$\\bar{x} * \\bar{y} := \\bar{x} \\cdot \\bar{y} \\cdot r^{-1} \\bmod n.$$","title":"Montgomery representation"},{"location":"algebra/montgomery_multiplication.html#montgomery-reduction","text":"The multiplication of two numbers in the Montgomery space requires an efficient computation of $x \\cdot r^{-1} \\bmod n$ . This operation is called the Montgomery reduction , and is also known as the algorithm REDC . Because $\\gcd(n, r) = 1$ , we know that there are two numbers $r^{-1}$ and $n^{\\prime}$ with $0 < r^{-1}, n^{\\prime} < n$ with $$r \\cdot r^{-1} + n \\cdot n^{\\prime} = 1.$$ Both $r^{-1}$ and $n^{\\prime}$ can be computed using the Extended Euclidean algorithm . Using this identity we can write $x \\cdot r^{-1}$ as: $$\\begin{aligned} x \\cdot r^{-1} &= x \\cdot r \\cdot r^{-1} / r = x \\cdot (-n \\cdot n^{\\prime} + 1) / r \\\\ &= (-x \\cdot n \\cdot n^{\\prime} + x) / r \\equiv (-x \\cdot n \\cdot n^{\\prime} + l \\cdot r \\cdot n + x) / r \\bmod n\\\\ &\\equiv ((-x \\cdot n^{\\prime} + l \\cdot r) \\cdot n + x) / r \\bmod n \\end{aligned}$$ The equivalences hold for any arbitrary integer $l$ . This means, that we can add or subtract an arbitrary multiple of $r$ to $x \\cdot n^{\\prime}$ , or in other words, we can compute $q := x \\cdot n^{\\prime}$ modulo $r$ . This gives us the following algorithm to compute $x \\cdot r^{-1} \\bmod n$ : function reduce(x): q = (x mod r) * n' mod r a = (x - q * n) / r if a < 0: a += n return a Since $x < n \\cdot n < r \\cdot n$ (even if $x$ is the product of a multiplication) and $q \\cdot n < r \\cdot n$ we know that $-n < (x - q \\cdot n) / r < n$ . Therefore the final modulo operation is implemented using a single check and one addition. As we see, we can perform the Montgomery reduction without any heavy modulo operations. If we choose $r$ as a power of $2$ , the modulo operations and divisions in the algorithm can be computed using bitmasking and shifting. A second application of the Montgomery reduction is to transfer a number back from the Montgomery space into the normal space.","title":"Montgomery reduction"},{"location":"algebra/montgomery_multiplication.html#fast-inverse-trick","text":"For computing the inverse $n^{\\prime} := n^{-1} \\bmod r$ efficiently, we can use the following trick (which is inspired from the Newton's method): $$a \\cdot x \\equiv 1 \\bmod 2^k \\Longrightarrow a \\cdot x \\cdot (2 - a \\cdot x) \\equiv 1 \\bmod 2^{2k}$$ This can easily be proven. If we have $a \\cdot x = 1 + m \\cdot 2^k$ , then we have: $$\\begin{aligned} a \\cdot x \\cdot (2 - a \\cdot x) &= 2 \\cdot a \\cdot x - (a \\cdot x)^2 \\\\ &= 2 \\cdot (1 + m \\cdot 2^k) - (1 + m \\cdot 2^k)^2 \\\\ &= 2 + 2 \\cdot m \\cdot 2^k - 1 - 2 \\cdot m \\cdot 2^k - m^2 \\cdot 2^{2k} \\\\ &= 1 - m^2 \\cdot 2^{2k} \\\\ &\\equiv 1 \\bmod 2^{2k}. \\end{aligned}$$ This means we can start with $x = 1$ as the inverse of $a$ modulo $2^1$ , apply the trick a few times and in each iteration we double the number of correct bits of $x$ .","title":"Fast inverse trick"},{"location":"algebra/montgomery_multiplication.html#implementation","text":"Using the GCC compiler we can compute $x \\cdot y \\bmod n$ still efficiently, when all three numbers are 64 bit integer, since the compiler supports 128 bit integer with the types __int128 and __uint128 . long long result = ( __int128 ) x * y % n ; However there is no type for 256 bit integer. Therefore we will here show an implementation for a 128 bit multiplication. using u64 = uint64_t ; using u128 = __uint128_t ; using i128 = __int128_t ; struct u256 { u128 high , low ; static u256 mult ( u128 x , u128 y ) { u64 a = x >> 64 , b = x ; u64 c = y >> 64 , d = y ; // (a*2^64 + b) * (c*2^64 + d) = // (a*c) * 2^128 + (a*d + b*c)*2^64 + (b*d) u128 ac = ( u128 ) a * c ; u128 ad = ( u128 ) a * d ; u128 bc = ( u128 ) b * c ; u128 bd = ( u128 ) b * d ; u128 carry = ( u128 )( u64 ) ad + ( u128 )( u64 ) bc + ( bd >> 64u ); u128 high = ac + ( ad >> 64u ) + ( bc >> 64u ) + ( carry >> 64u ); u128 low = ( ad << 64u ) + ( bc << 64u ) + bd ; return { high , low }; } }; struct Montgomery { Montgomery ( u128 n ) : mod ( n ), inv ( 1 ) { for ( int i = 0 ; i < 7 ; i ++ ) inv *= 2 - n * inv ; } u128 init ( u128 x ) { x %= mod ; for ( int i = 0 ; i < 128 ; i ++ ) { x <<= 1 ; if ( x >= mod ) x -= mod ; } return x ; } u128 reduce ( u256 x ) { u128 q = x . low * inv ; i128 a = x . high - u256 :: mult ( q , mod ). high ; if ( a < 0 ) a += mod ; return a ; } u128 mult ( u128 a , u128 b ) { return reduce ( u256 :: mult ( a , b )); } u128 mod , inv ; };","title":"Implementation"},{"location":"algebra/montgomery_multiplication.html#fast-transformation","text":"The current method of transforming a number into Montgomery space is pretty slow. There are faster ways. You can notice the following relation: $$\\bar{x} := x \\cdot r \\bmod n = x \\cdot r^2 / r = x * r^2$$ Transforming a number into the space is just a multiplication inside the space of the number with $r^2$ . Therefore we can precompute $r^2 \\bmod n$ and just perform a multiplication instead of shifting the number 128 times. In the following code we initialize r2 with -n % n , which is equivalent to $r - n \\equiv r \\bmod n$ , shift it 4 times to get $r \\cdot 2^4 \\bmod n$ . This number can be interpreted as $2^4$ in Montgomery space. If we square it $5$ times, we get $(2^4)^{2^5} = (2^4)^{32} = 2^{128} = r$ in Montgomery space, which is exactly $r^2 \\bmod n$ . struct Montgomery { Montgomery(u128 n) : mod(n), inv(1), r2(-n % n) { for (int i = 0; i < 7; i++) inv *= 2 - n * inv; for (int i = 0; i < 4; i++) { r2 <<= 1; if (r2 >= mod) r2 -= mod; } for (int i = 0; i < 5; i++) r2 = mul(r2, r2); } u128 init(u128 x) { return mult(x, r2); } u128 mod, inv, r2; };","title":"Fast transformation"},{"location":"algebra/phi-function.html","text":"Euler's totient function \u00b6 Euler's totient function, also known as phi-function $\\phi (n)$ , counts the number of integers between 1 and $n$ inclusive, which are coprime to $n$ . Two numbers are coprime if their greatest common divisor equals $1$ ( $1$ is considered to be coprime to any number). Here are values of $\\phi(n)$ for the first few positive integers: $$\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\\\\\\ \\hline \\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\\\\\\\ \\hline \\end{array}$$ Properties \u00b6 The following properties of Euler totient function are sufficient to calculate it for any number: If $p$ is a prime number, then $\\gcd(p, q) = 1$ for all $1 \\le q < p$ . Therefore we have: $$\\phi (p) = p - 1.$$ If $p$ is a prime number and $k \\ge 1$ , then there are exactly $p^k / p$ numbers between $1$ and $p^k$ that are divisible by $p$ . Which gives us: $$\\phi(p^k) = p^k - p^{k-1}.$$ If $a$ and $b$ are relatively prime, then: $$\\phi(a b) = \\phi(a) \\cdot \\phi(b).$$ This relation is not trivial to see. It follows from the Chinese remainder theorem . The Chinese remainder theorem guarantees, that for each $0 \\le x < a$ and each $0 \\le y < b$ , there exists a unique $0 \\le z < a b$ with $z \\equiv x \\pmod{a}$ and $z \\equiv y \\pmod{b}$ . It's not hard to show that $z$ is coprime to $a b$ if and only if $x$ is coprime to $a$ and $y$ is coprime to $b$ . Therefore the amount of integers coprime to $a b$ is equal to product of the amounts of $a$ and $b$ . In general, for not coprime $a$ and $b$ , the equation $$\\phi(ab) = \\phi(a) \\cdot \\phi(b) \\cdot \\dfrac{d}{\\phi(d)}$$ with $d = \\gcd(a, b)$ holds. Thus, using the first three properties, we can compute $\\phi(n)$ through the factorization of $n$ (decomposition of $n$ into a product of its prime factors). If $n = {p_1}^{a_1} \\cdot {p_2}^{a_2} \\cdots {p_k}^{a_k}$ , where $p_i$ are prime factors of $n$ , $$\\begin{align} \\phi (n) &= \\phi ({p_1}^{a_1}) \\cdot \\phi ({p_2}^{a_2}) \\cdots \\phi ({p_k}^{a_k}) \\\\\\\\ &= \\left({p_1}^{a_1} - {p_1}^{a_1 - 1}\\right) \\cdot \\left({p_2}^{a_2} - {p_2}^{a_2 - 1}\\right) \\cdots \\left({p_k}^{a_k} - {p_k}^{a_k - 1}\\right) \\\\\\\\ &= p_1^{a_1} \\cdot \\left(1 - \\frac{1}{p_1}\\right) \\cdot p_2^{a_2} \\cdot \\left(1 - \\frac{1}{p_2}\\right) \\cdots p_k^{a_k} \\cdot \\left(1 - \\frac{1}{p_k}\\right) \\\\\\\\ &= n \\cdot \\left(1 - \\frac{1}{p_1}\\right) \\cdot \\left(1 - \\frac{1}{p_2}\\right) \\cdots \\left(1 - \\frac{1}{p_k}\\right) \\end{align}$$ Implementation \u00b6 Here is an implementation using factorization in $O(\\sqrt{n})$ : int phi ( int n ) { int result = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n /= i ; result -= result / i ; } } if ( n > 1 ) result -= result / n ; return result ; } Euler totient function from $1$ to $n$ in $O(n \\log\\log{n})$ \u00b6 If we need all all the totient of all numbers between $1$ and $n$ , then factorizing all $n$ numbers is not efficient. We can use the same idea as the Sieve of Eratosthenes . It is still based on the property shown above, but instead of updating the temporary result for each prime factor for each number, we find all prime numbers and for each one update the temporary results of all numbers that are divisible by that prime number. Since this approach is basically identical to the Sieve of Eratosthenes, the complexity will also be the same: $O(n \\log \\log n)$ void phi_1_to_n ( int n ) { vector < int > phi ( n + 1 ); for ( int i = 0 ; i <= n ; i ++ ) phi [ i ] = i ; for ( int i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { for ( int j = i ; j <= n ; j += i ) phi [ j ] -= phi [ j ] / i ; } } } Divisor sum property \u00b6 This interesting property was established by Gauss: $$ \\sum_{d|n} \\phi{(d)} = n$$ Here the sum is over all positive divisors $d$ of $n$ . For instance the divisors of 10 are 1, 2, 5 and 10. Hence $\\phi{(1)} + \\phi{(2)} + \\phi{(5)} + \\phi{(10)} = 1 + 1 + 4 + 4 = 10$ . Finding the totient from 1 to $n$ using the divisor sum property \u00b6 The divisor sum property also allows us to compute the totient of all numbers between 1 and $n$ . This implementation is a little simpler than the previous implementation based on the Sieve of Eratosthenes, however also has a slightly worse complexity: $O(n \\log n)$ void phi_1_to_n ( int n ) { vector < int > phi ( n + 1 ); phi [ 0 ] = 0 ; phi [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) phi [ i ] = i - 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 2 * i ; j <= n ; j += i ) phi [ j ] -= phi [ i ]; } Application in Euler's theorem \u00b6 The most famous and important property of Euler's totient function is expressed in Euler's theorem : $$a^{\\phi(m)} \\equiv 1 \\pmod m \\quad \\text{if } a \\text{ and } m \\text{ are relatively prime.}$$ In the particular case when $m$ is prime, Euler's theorem turns into Fermat's little theorem : $$a^{m - 1} \\equiv 1 \\pmod m$$ Euler's theorem and Euler's totient function occur quite often in practical applications, for example both are used to compute the modular multiplicative inverse . As immediate consequence we also get the equivalence: $$a^n \\equiv a^{n \\bmod \\phi(m)} \\pmod m$$ This allows computing $x^n \\bmod m$ for very big $n$ , especially if $n$ is the result of another computation, as it allows to compute $n$ under a modulo. Group Theory \u00b6 $\\phi(n)$ is the order of the multiplicative group mod n $(\\mathbb Z / n\\mathbb Z)^\\times$ , that is the group of units (elements with multiplicative inverses). The elements with multiplicative inverses are precisely those coprime to $n$ . The multiplicative order of an element $a$ mod $n$ , denoted $\\operatorname{ord}_n(a)$ , is the smallest $k>0$ such that $a^k \\equiv 1 \\pmod m$ . $\\operatorname{ord}_n(a)$ is the size of the subgroup generated by $a$ , so by Lagrange's Theorem, the multiplicative order of any $a$ must divide $\\phi(n)$ . If the multiplicative order of $a$ is $\\phi(n)$ , the largest possible, then $a$ is a primitive root and the group is cyclic by definition. Generalization \u00b6 There is a less known version of the last equivalence, that allows computing $x^n \\bmod m$ efficiently for not coprime $x$ and $m$ . For arbitrary $x, m$ and $n \\geq \\log_2 m$ : $$x^{n}\\equiv x^{\\phi(m)+[n \\bmod \\phi(m)]} \\mod m$$ Proof: Let $p_1, \\dots, p_t$ be common prime divisors of $x$ and $m$ , and $k_i$ their exponents in $m$ . With those we define $a = p_1^{k_1} \\dots p_t^{k_t}$ , which makes $\\frac{m}{a}$ coprime to $x$ . And let $k$ be the smallest number such that $a$ divides $x^k$ . Assuming $n \\ge k$ , we can write: $$\\begin{align}x^n \\bmod m &= \\frac{x^k}{a}ax^{n-k}\\bmod m \\\\ &= \\frac{x^k}{a}\\left(ax^{n-k}\\bmod m\\right) \\bmod m \\\\ &= \\frac{x^k}{a}\\left(ax^{n-k}\\bmod a \\frac{m}{a}\\right) \\bmod m \\\\ &=\\frac{x^k}{a} a \\left(x^{n-k} \\bmod \\frac{m}{a}\\right)\\bmod m \\\\ &= x^k\\left(x^{n-k} \\bmod \\frac{m}{a}\\right)\\bmod m \\end{align}$$ The equivalence between the third and forth line follows from the fact that $ab \\bmod ac = a(b \\bmod c)$ . Indeed if $b = cd + r$ with $r < c$ , then $ab = acd + ar$ with $ar < ac$ . Since $x$ and $\\frac{m}{a}$ are coprime, we can apply Euler's theorem and get the efficient (since $k$ is very small; in fact $k \\le \\log_2 m$ ) formula: $$x^n \\bmod m = x^k\\left(x^{n-k \\bmod \\phi(\\frac{m}{a})} \\bmod \\frac{m}{a}\\right)\\bmod m.$$ This formula is difficult to apply, but we can use it to analyze the behavior of $x^n \\bmod m$ . We can see that the sequence of powers $(x^1 \\bmod m, x^2 \\bmod m, x^3 \\bmod m, \\dots)$ enters a cycle of length $\\phi\\left(\\frac{m}{a}\\right)$ after the first $k$ (or less) elements. $\\phi\\left(\\frac{m}{a}\\right)$ divides $\\phi(m)$ (because $a$ and $\\frac{m}{a}$ are coprime we have $\\phi(a) \\cdot \\phi\\left(\\frac{m}{a}\\right) = \\phi(m)$ ), therefore we can also say that the period has length $\\phi(m)$ . And since $\\phi(m) \\ge \\log_2 m \\ge k$ , we can conclude the desired, much simpler, formula: $$ x^n \\equiv x^{\\phi(m)} x^{(n - \\phi(m)) \\bmod \\phi(m)} \\bmod m \\equiv x^{\\phi(m)+[n \\bmod \\phi(m)]} \\mod m.$$ Practice Problems \u00b6 SPOJ #4141 \"Euler Totient Function\" [Difficulty: CakeWalk] UVA #10179 \"Irreducible Basic Fractions\" [Difficulty: Easy] UVA #10299 \"Relatives\" [Difficulty: Easy] UVA #11327 \"Enumerating Rational Numbers\" [Difficulty: Medium] TIMUS #1673 \"Admission to Exam\" [Difficulty: High] UVA 10990 - Another New Function Codechef - Golu and Sweetness SPOJ - LCM Sum GYM - Simple Calculations (F) UVA 13132 - Laser Mirrors SPOJ - GCDEX UVA 12995 - Farey Sequence SPOJ - Totient in Permutation (easy) LOJ - Mathematically Hard SPOJ - Totient Extreme SPOJ - Playing with GCD SPOJ - G Force SPOJ - Smallest Inverse Euler Totient Function Codeforces - Power Tower Kattis - Exponial LeetCode - 372. Super Pow Codeforces - The Holmes Children Codeforces - Small GCD","title":"Euler's totient function"},{"location":"algebra/phi-function.html#eulers-totient-function","text":"Euler's totient function, also known as phi-function $\\phi (n)$ , counts the number of integers between 1 and $n$ inclusive, which are coprime to $n$ . Two numbers are coprime if their greatest common divisor equals $1$ ( $1$ is considered to be coprime to any number). Here are values of $\\phi(n)$ for the first few positive integers: $$\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\\\\\\ \\hline \\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\\\\\\\ \\hline \\end{array}$$","title":"Euler's totient function"},{"location":"algebra/phi-function.html#properties","text":"The following properties of Euler totient function are sufficient to calculate it for any number: If $p$ is a prime number, then $\\gcd(p, q) = 1$ for all $1 \\le q < p$ . Therefore we have: $$\\phi (p) = p - 1.$$ If $p$ is a prime number and $k \\ge 1$ , then there are exactly $p^k / p$ numbers between $1$ and $p^k$ that are divisible by $p$ . Which gives us: $$\\phi(p^k) = p^k - p^{k-1}.$$ If $a$ and $b$ are relatively prime, then: $$\\phi(a b) = \\phi(a) \\cdot \\phi(b).$$ This relation is not trivial to see. It follows from the Chinese remainder theorem . The Chinese remainder theorem guarantees, that for each $0 \\le x < a$ and each $0 \\le y < b$ , there exists a unique $0 \\le z < a b$ with $z \\equiv x \\pmod{a}$ and $z \\equiv y \\pmod{b}$ . It's not hard to show that $z$ is coprime to $a b$ if and only if $x$ is coprime to $a$ and $y$ is coprime to $b$ . Therefore the amount of integers coprime to $a b$ is equal to product of the amounts of $a$ and $b$ . In general, for not coprime $a$ and $b$ , the equation $$\\phi(ab) = \\phi(a) \\cdot \\phi(b) \\cdot \\dfrac{d}{\\phi(d)}$$ with $d = \\gcd(a, b)$ holds. Thus, using the first three properties, we can compute $\\phi(n)$ through the factorization of $n$ (decomposition of $n$ into a product of its prime factors). If $n = {p_1}^{a_1} \\cdot {p_2}^{a_2} \\cdots {p_k}^{a_k}$ , where $p_i$ are prime factors of $n$ , $$\\begin{align} \\phi (n) &= \\phi ({p_1}^{a_1}) \\cdot \\phi ({p_2}^{a_2}) \\cdots \\phi ({p_k}^{a_k}) \\\\\\\\ &= \\left({p_1}^{a_1} - {p_1}^{a_1 - 1}\\right) \\cdot \\left({p_2}^{a_2} - {p_2}^{a_2 - 1}\\right) \\cdots \\left({p_k}^{a_k} - {p_k}^{a_k - 1}\\right) \\\\\\\\ &= p_1^{a_1} \\cdot \\left(1 - \\frac{1}{p_1}\\right) \\cdot p_2^{a_2} \\cdot \\left(1 - \\frac{1}{p_2}\\right) \\cdots p_k^{a_k} \\cdot \\left(1 - \\frac{1}{p_k}\\right) \\\\\\\\ &= n \\cdot \\left(1 - \\frac{1}{p_1}\\right) \\cdot \\left(1 - \\frac{1}{p_2}\\right) \\cdots \\left(1 - \\frac{1}{p_k}\\right) \\end{align}$$","title":"Properties"},{"location":"algebra/phi-function.html#implementation","text":"Here is an implementation using factorization in $O(\\sqrt{n})$ : int phi ( int n ) { int result = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n /= i ; result -= result / i ; } } if ( n > 1 ) result -= result / n ; return result ; }","title":"Implementation"},{"location":"algebra/phi-function.html#etf_1_to_n","text":"If we need all all the totient of all numbers between $1$ and $n$ , then factorizing all $n$ numbers is not efficient. We can use the same idea as the Sieve of Eratosthenes . It is still based on the property shown above, but instead of updating the temporary result for each prime factor for each number, we find all prime numbers and for each one update the temporary results of all numbers that are divisible by that prime number. Since this approach is basically identical to the Sieve of Eratosthenes, the complexity will also be the same: $O(n \\log \\log n)$ void phi_1_to_n ( int n ) { vector < int > phi ( n + 1 ); for ( int i = 0 ; i <= n ; i ++ ) phi [ i ] = i ; for ( int i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { for ( int j = i ; j <= n ; j += i ) phi [ j ] -= phi [ j ] / i ; } } }","title":"Euler totient function from 1 to n in O(n log log n)"},{"location":"algebra/phi-function.html#divsum","text":"This interesting property was established by Gauss: $$ \\sum_{d|n} \\phi{(d)} = n$$ Here the sum is over all positive divisors $d$ of $n$ . For instance the divisors of 10 are 1, 2, 5 and 10. Hence $\\phi{(1)} + \\phi{(2)} + \\phi{(5)} + \\phi{(10)} = 1 + 1 + 4 + 4 = 10$ .","title":"Divisor sum property"},{"location":"algebra/phi-function.html#finding-the-totient-from-1-to-n-using-the-divisor-sum-property","text":"The divisor sum property also allows us to compute the totient of all numbers between 1 and $n$ . This implementation is a little simpler than the previous implementation based on the Sieve of Eratosthenes, however also has a slightly worse complexity: $O(n \\log n)$ void phi_1_to_n ( int n ) { vector < int > phi ( n + 1 ); phi [ 0 ] = 0 ; phi [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) phi [ i ] = i - 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 2 * i ; j <= n ; j += i ) phi [ j ] -= phi [ i ]; }","title":"Finding the totient from 1 to n using the divisor sum property"},{"location":"algebra/phi-function.html#application","text":"The most famous and important property of Euler's totient function is expressed in Euler's theorem : $$a^{\\phi(m)} \\equiv 1 \\pmod m \\quad \\text{if } a \\text{ and } m \\text{ are relatively prime.}$$ In the particular case when $m$ is prime, Euler's theorem turns into Fermat's little theorem : $$a^{m - 1} \\equiv 1 \\pmod m$$ Euler's theorem and Euler's totient function occur quite often in practical applications, for example both are used to compute the modular multiplicative inverse . As immediate consequence we also get the equivalence: $$a^n \\equiv a^{n \\bmod \\phi(m)} \\pmod m$$ This allows computing $x^n \\bmod m$ for very big $n$ , especially if $n$ is the result of another computation, as it allows to compute $n$ under a modulo.","title":"Application in Euler's theorem"},{"location":"algebra/phi-function.html#group-theory","text":"$\\phi(n)$ is the order of the multiplicative group mod n $(\\mathbb Z / n\\mathbb Z)^\\times$ , that is the group of units (elements with multiplicative inverses). The elements with multiplicative inverses are precisely those coprime to $n$ . The multiplicative order of an element $a$ mod $n$ , denoted $\\operatorname{ord}_n(a)$ , is the smallest $k>0$ such that $a^k \\equiv 1 \\pmod m$ . $\\operatorname{ord}_n(a)$ is the size of the subgroup generated by $a$ , so by Lagrange's Theorem, the multiplicative order of any $a$ must divide $\\phi(n)$ . If the multiplicative order of $a$ is $\\phi(n)$ , the largest possible, then $a$ is a primitive root and the group is cyclic by definition.","title":"Group Theory"},{"location":"algebra/phi-function.html#generalization","text":"There is a less known version of the last equivalence, that allows computing $x^n \\bmod m$ efficiently for not coprime $x$ and $m$ . For arbitrary $x, m$ and $n \\geq \\log_2 m$ : $$x^{n}\\equiv x^{\\phi(m)+[n \\bmod \\phi(m)]} \\mod m$$ Proof: Let $p_1, \\dots, p_t$ be common prime divisors of $x$ and $m$ , and $k_i$ their exponents in $m$ . With those we define $a = p_1^{k_1} \\dots p_t^{k_t}$ , which makes $\\frac{m}{a}$ coprime to $x$ . And let $k$ be the smallest number such that $a$ divides $x^k$ . Assuming $n \\ge k$ , we can write: $$\\begin{align}x^n \\bmod m &= \\frac{x^k}{a}ax^{n-k}\\bmod m \\\\ &= \\frac{x^k}{a}\\left(ax^{n-k}\\bmod m\\right) \\bmod m \\\\ &= \\frac{x^k}{a}\\left(ax^{n-k}\\bmod a \\frac{m}{a}\\right) \\bmod m \\\\ &=\\frac{x^k}{a} a \\left(x^{n-k} \\bmod \\frac{m}{a}\\right)\\bmod m \\\\ &= x^k\\left(x^{n-k} \\bmod \\frac{m}{a}\\right)\\bmod m \\end{align}$$ The equivalence between the third and forth line follows from the fact that $ab \\bmod ac = a(b \\bmod c)$ . Indeed if $b = cd + r$ with $r < c$ , then $ab = acd + ar$ with $ar < ac$ . Since $x$ and $\\frac{m}{a}$ are coprime, we can apply Euler's theorem and get the efficient (since $k$ is very small; in fact $k \\le \\log_2 m$ ) formula: $$x^n \\bmod m = x^k\\left(x^{n-k \\bmod \\phi(\\frac{m}{a})} \\bmod \\frac{m}{a}\\right)\\bmod m.$$ This formula is difficult to apply, but we can use it to analyze the behavior of $x^n \\bmod m$ . We can see that the sequence of powers $(x^1 \\bmod m, x^2 \\bmod m, x^3 \\bmod m, \\dots)$ enters a cycle of length $\\phi\\left(\\frac{m}{a}\\right)$ after the first $k$ (or less) elements. $\\phi\\left(\\frac{m}{a}\\right)$ divides $\\phi(m)$ (because $a$ and $\\frac{m}{a}$ are coprime we have $\\phi(a) \\cdot \\phi\\left(\\frac{m}{a}\\right) = \\phi(m)$ ), therefore we can also say that the period has length $\\phi(m)$ . And since $\\phi(m) \\ge \\log_2 m \\ge k$ , we can conclude the desired, much simpler, formula: $$ x^n \\equiv x^{\\phi(m)} x^{(n - \\phi(m)) \\bmod \\phi(m)} \\bmod m \\equiv x^{\\phi(m)+[n \\bmod \\phi(m)]} \\mod m.$$","title":"Generalization"},{"location":"algebra/phi-function.html#practice-problems","text":"SPOJ #4141 \"Euler Totient Function\" [Difficulty: CakeWalk] UVA #10179 \"Irreducible Basic Fractions\" [Difficulty: Easy] UVA #10299 \"Relatives\" [Difficulty: Easy] UVA #11327 \"Enumerating Rational Numbers\" [Difficulty: Medium] TIMUS #1673 \"Admission to Exam\" [Difficulty: High] UVA 10990 - Another New Function Codechef - Golu and Sweetness SPOJ - LCM Sum GYM - Simple Calculations (F) UVA 13132 - Laser Mirrors SPOJ - GCDEX UVA 12995 - Farey Sequence SPOJ - Totient in Permutation (easy) LOJ - Mathematically Hard SPOJ - Totient Extreme SPOJ - Playing with GCD SPOJ - G Force SPOJ - Smallest Inverse Euler Totient Function Codeforces - Power Tower Kattis - Exponial LeetCode - 372. Super Pow Codeforces - The Holmes Children Codeforces - Small GCD","title":"Practice Problems"},{"location":"algebra/polynomial.html","text":"Operations on polynomials and series \u00b6 Problems in competitive programming, especially the ones involving enumeration some kind, are often solved by reducing the problem to computing something on polynomials and formal power series. This includes concepts such as polynomial multiplication, interpolation, and more complicated ones, such as polynomial logarithms and exponents. In this article, a brief overview of such operations and common approaches to them is presented. Basic Notion and facts \u00b6 In this section, we focus more on the definitions and \"intuitive\" properties of various polynomial operations. The technical details of their implementation and complexities will be covered in later sections. Polynomial multiplication \u00b6 Definition Univariate polynomial is an expression of form $A(x) = a_0 + a_1 x + \\dots + a_n x^n$ . The values $a_0, \\dots, a_n$ are polynomial coefficients, typically taken from some set of numbers or number-like structures. In this article, we assume that the coefficients are taken from some field , meaning that operations of addition, subtraction, multiplication and division are well-defined for them (except for division by $0$ ) and they generally behave in a similar way to real numbers. Typical example of such field is the field of remainders modulo prime number $p$ . For simplicity we will drop the term univariate , as this is the only kind of polynomials we consider in this article. We will also write $A$ instead of $A(x)$ wherever possible, which will be understandable from the context. It is assumed that either $a_n \\neq 0$ or $A(x)=0$ . Definition The product of two polynomials is defined by expanding it as an arithmetic expression: $$ A(x) B(x) = \\left(\\sum\\limits_{i=0}^n a_i x^i \\right)\\left(\\sum\\limits_{j=0}^m b_j x^j\\right) = \\sum\\limits_{i,j} a_i b_j x^{i+j} = \\sum\\limits_{k=0}^{n+m} c_k x^k = C(x). $$ The sequence $c_0, c_1, \\dots, c_{n+m}$ of the coefficients of $C(x)$ is called the convolution of $a_0, \\dots, a_n$ and $b_0, \\dots, b_m$ . Definition The degree of a polynomial $A$ with $a_n \\neq 0$ is defined as $\\deg A = n$ . For consistency, degree of $A(x) = 0$ is defined as $\\deg A = -\\infty$ . In this notion, $\\deg AB = \\deg A + \\deg B$ for any polynomials $A$ and $B$ . Convolutions are the basis of solving many enumerative problems. Example You have $n$ objects of the first kind and $m$ objects of the second kind. Objects of first kind are valued $a_1, \\dots, a_n$ , and objects of the second kind are valued $b_1, \\dots, b_m$ . You pick a single object of the first kind and a single object of the second kind. How many ways are there to get the total value $k$ ? Solution Consider the product $(x^{a_1} + \\dots + x^{a_n})(x^{b_1} + \\dots + x^{b_m})$ . If you expand it, each monomial will correspond to the pair $(a_i, b_j)$ and contribute to the coefficient near $x^{a_i+b_j}$ . In other words, the answer is the coefficient near $x^k$ in the product. Example You throw a $6$ -sided die $n$ times and sum up the results from all throws. What is the probability of getting sum of $k$ ? Solution The answer is the number of outcomes having the sum $k$ , divided by the total number of outcomes, which is $6^n$ . What is the number of outcomes having the sum $k$ ? For $n=1$ , it may be represented by a polynomial $A(x) = x^1+x^2+\\dots+x^6$ . For $n=2$ , using the same approach as in the example above, we conclude that it is represented by the polynomial $(x^1+x^2+\\dots+x^6)^2$ . That being said, the answer to the problem is the $k$ -th coefficient of $(x^1+x^2+\\dots+x^6)^n$ , divided by $6^n$ . The coefficient near $x^k$ in the polynomial $A(x)$ is denoted shortly as $[x^k]A$ . Formal power series \u00b6 Definition A formal power series is an infinite sum $A(x) = a_0 + a_1 x + a_2 x^2 + \\dots$ , considered regardless of its convergence properties. In other words, when we consider e.g. a sum $1+\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\dots=2$ , we imply that it converges to $2$ when the number of summands approach infinity. However, formal series are only considered in terms of sequences that make them. Definition The product of formal power series $A(x)$ and $B(x)$ , is also defined by expanding it as an arithmetic expression: $$ A(x) B(x) = \\left(\\sum\\limits_{i=0}^\\infty a_i x^i \\right)\\left(\\sum\\limits_{j=0}^\\infty b_j x^j\\right) = \\sum\\limits_{i,j} a_i b_j x^{i+j} = \\sum\\limits_{k=0}^{\\infty} c_k x^k = C(x), $$ where the coefficients $c_0, c_1, \\dots$ are define as finite sums $$ c_k = \\sum\\limits_{i=0}^k a_i b_{k-i}. $$ The sequence $c_0, c_1, \\dots$ is also called a convolution of $a_0, a_1, \\dots$ and $b_0, b_1, \\dots$ , generalizing the concept to infinite sequences. Thus, polynomials may be considered formal power series, but with finite number of coefficients. Formal power series play a crucial role in enumerative combinatorics, where they're studied as generating functions for various sequences. Detailed explanation of generating functions and the intuition behind them will, unfortunately, be out of scope for this article, therefore the curious reader is referenced e.g. here for details about their combinatorial meaning. However, we will very briefly mention that if $A(x)$ and $B(x)$ are generating functions for sequences that enumerate some objects by number of \"atoms\" in them (e.g. trees by the number of vertices), then the product $A(x) B(x)$ enumerates objects that can be described as pairs of objects of kinds $A$ and $B$ , enumerates by the total number of \"atoms\" in the pair. Example Let $A(x) = \\sum\\limits_{i=0}^\\infty 2^i x^i$ enumerate packs of stones, each stone colored in one of $2$ colors (so, there are $2^i$ such packs of size $i$ ) and $B(x) = \\sum\\limits_{j=0}^{\\infty} 3^j x^j$ enumerate packs of stones, each stone colored in one of $3$ colors. Then $C(x) = A(x) B(x) = \\sum\\limits_{k=0}^\\infty c_k x^k$ would enumerate objects that may be described as \"two packs of stones, first pack only of stones of type $A$ , second pack only of stones of type $B$ , with total number of stones being $k$ \" for $c_k$ . In a similar way, there is an intuitive meaning to some other functions over formal power series. Long polynomial division \u00b6 Similar to integers, it is possible to define long division on polynomials. Definition For any polynomials $A$ and $B \\neq 0$ , one may represent $A$ as $$ A = D \\cdot B + R,~ \\deg R < \\deg B, $$ where $R$ is called the remainder of $A$ modulo $B$ and $D$ is called the quotient . Denoting $\\deg A = n$ and $\\deg B = m$ , naive way to do it is to use long division, during which you multiply $B$ by the monomial $\\frac{a_n}{b_m} x^{n - m}$ and subtract it from $A$ , until the degree of $A$ is smaller than that of $B$ . What remains of $A$ in the end will be the remainder (hence the name), and the polynomials with which you multiplied $B$ in the process, summed together, form the quotient. Definition If $A$ and $B$ have the same remainder modulo $C$ , they're said to be equivalent modulo $C$ , which is denoted as $$ A \\equiv B \\pmod{C}. $$ Polynomial long division is useful because of its many important properties: $A$ is a multiple of $B$ if and only if $A \\equiv 0 \\pmod B$ . It implies that $A \\equiv B \\pmod C$ if and only if $A-B$ is a multiple of $C$ . In particular, $A \\equiv B \\pmod{C \\cdot D}$ implies $A \\equiv B \\pmod{C}$ . For any linear polynomial $x-r$ it holds that $A(x) \\equiv A(r) \\pmod{x-r}$ . It implies that $A$ is a multiple of $x-r$ if and only if $A(r)=0$ . For modulo being $x^k$ , it holds that $A \\equiv a_0 + a_1 x + \\dots + a_{k-1} x^{k-1} \\pmod{x^k}$ . Note that long division can't be properly defined for formal power series. Instead, for any $A(x)$ such that $a_0 \\neq 0$ , it is possible to define an inverse formal power series $A^{-1}(x)$ , such that $A(x) A^{-1}(x) = 1$ . This fact, in turn, can be used to compute the result of long division for polynomials. Basic implementation \u00b6 Here you can find the basic implementation of polynomial algebra. It supports all trivial operations and some other useful methods. The main class is poly<T> for polynomials with coefficients of type T . All arithmetic operation + , - , * , % and / are supported, % and / standing for remainder and quotient in Euclidean division. There is also the class modular<m> for performing arithmetic operations on remainders modulo a prime number m . Other useful functions: deriv() : computes the derivative $P'(x)$ of $P(x)$ . integr() : computes the indefinite integral $Q(x) = \\int P(x)$ of $P(x)$ such that $Q(0)=0$ . inv(size_t n) : calculate the first $n$ coefficients of $P^{-1}(x)$ in $O(n \\log n)$ . log(size_t n) : calculate the first $n$ coefficients of $\\ln P(x)$ in $O(n \\log n)$ . exp(size_t n) : calculate the first $n$ coefficients of $\\exp P(x)$ in $O(n \\log n)$ . pow(size_t k, size_t n) : calculate the first $n$ coefficients for $P^{k}(x)$ in $O(n \\log nk)$ . deg() : returns the degree of $P(x)$ . lead() : returns the coefficient of $x^{\\deg P(x)}$ . resultant(poly<T> a, poly<T> b) : computes the resultant of $a$ and $b$ in $O(|a| \\cdot |b|)$ . bpow(T x, size_t n) : computes $x^n$ . bpow(T x, size_t n, T m) : computes $x^n \\pmod{m}$ . chirpz(T z, size_t n) : computes $P(1), P(z), P(z^2), \\dots, P(z^{n-1})$ in $O(n \\log n)$ . vector<T> eval(vector<T> x) : evaluates $P(x_1), \\dots, P(x_n)$ in $O(n \\log^2 n)$ . poly<T> inter(vector<T> x, vector<T> y) : interpolates a polynomial by a set of pairs $P(x_i) = y_i$ in $O(n \\log^2 n)$ . And some more, feel free to explore the code! Arithmetic \u00b6 Multiplication \u00b6 The very core operation is the multiplication of two polynomials. That is, given the polynomials $A$ and $B$ : $$A = a_0 + a_1 x + \\dots + a_n x^n$$ $$B = b_0 + b_1 x + \\dots + b_m x^m$$ You have to compute polynomial $C = A \\cdot B$ , which is defined as $$\\boxed{C = \\sum\\limits_{i=0}^n \\sum\\limits_{j=0}^m a_i b_j x^{i+j}} = c_0 + c_1 x + \\dots + c_{n+m} x^{n+m}.$$ It can be computed in $O(n \\log n)$ via the Fast Fourier transform and almost all methods here will use it as subroutine. Inverse series \u00b6 If $A(0) \\neq 0$ there always exists an infinite formal power series $A^{-1}(x) = q_0+q_1 x + q_2 x^2 + \\dots$ such that $A^{-1} A = 1$ . It often proves useful to compute first $k$ coefficients of $A^{-1}$ (that is, to compute it modulo $x^k$ ). There are two major ways to calculate it. Divide and conquer \u00b6 This algorithm was mentioned in Sch\u00f6nhage's article and is inspired by Graeffe's method . It is known that for $B(x)=A(x)A(-x)$ it holds that $B(x)=B(-x)$ , that is, $B(x)$ is an even polynomial. It means that it only has non-zero coefficients with even numbers and can be represented as $B(x)=T(x^2)$ . Thus, we can do the following transition: $$A^{-1}(x) \\equiv \\frac{1}{A(x)} \\equiv \\frac{A(-x)}{A(x)A(-x)} \\equiv \\frac{A(-x)}{T(x^2)} \\pmod{x^k}$$ Note that $T(x)$ can be computed with a single multiplication, after which we're only interested in the first half of coefficients of its inverse series. This effectively reduces the initial problem of computing $A^{-1} \\pmod{x^k}$ to computing $T^{-1} \\pmod{x^{\\lfloor k / 2 \\rfloor}}$ . The complexity of this method can be estimated as $$T(n) = T(n/2) + O(n \\log n) = O(n \\log n).$$ Sieveking\u2013Kung algorithm \u00b6 The generic process described here is known as Hensel lifting, as it follows from Hensel's lemma. We'll cover it in more detail further below, but for now let's focus on ad hoc solution. \"Lifting\" part here means that we start with the approximation $B_0=q_0=a_0^{-1}$ , which is $A^{-1} \\pmod x$ and then iteratively lift from $\\bmod x^a$ to $\\bmod x^{2a}$ . Let $B_k \\equiv A^{-1} \\pmod{x^a}$ . The next approximation needs to follow the equation $A B_{k+1} \\equiv 1 \\pmod{x^{2a}}$ and may be represented as $B_{k+1} = B_k + x^a C$ . From this follows the equation $$A(B_k + x^{a}C) \\equiv 1 \\pmod{x^{2a}}.$$ Let $A B_k \\equiv 1 + x^a D \\pmod{x^{2a}}$ , then the equation above implies $$x^a(D+AC) \\equiv 0 \\pmod{x^{2a}} \\implies D \\equiv -AC \\pmod{x^a} \\implies C \\equiv -B_k D \\pmod{x^a}.$$ From this, one can obtain the final formula, which is $$x^a C \\equiv -B_k x^a D \\equiv B_k(1-AB_k) \\pmod{x^{2a}} \\implies \\boxed{B_{k+1} \\equiv B_k(2-AB_k) \\pmod{x^{2a}}}$$ Thus starting with $B_0 \\equiv a_0^{-1} \\pmod x$ we will compute the sequence $B_k$ such that $AB_k \\equiv 1 \\pmod{x^{2^k}}$ with the complexity $$T(n) = T(n/2) + O(n \\log n) = O(n \\log n).$$ The algorithm here might seem a bit more complicated than the first one, but it has a very solid and practical reasoning behind it, as well as a great generalization potential if looked from a different perspective, which would be explained further below. Euclidean division \u00b6 Consider two polynomials $A(x)$ and $B(x)$ of degrees $n$ and $m$ . As it was said earlier you can rewrite $A(x)$ as $$A(x) = B(x) D(x) + R(x), \\deg R < \\deg B.$$ Let $n \\geq m$ , it would imply that $\\deg D = n - m$ and the leading $n-m+1$ coefficients of $A$ don't influence $R$ . It means that you can recover $D(x)$ from the largest $n-m+1$ coefficients of $A(x)$ and $B(x)$ if you consider it as a system of equations. The system of linear equations we're talking about can be written in the following form: $$\\begin{bmatrix} a_n \\\\ \\vdots \\\\ a_{m+1} \\\\ a_{m} \\end{bmatrix} = \\begin{bmatrix} b_m & \\dots & 0 & 0 \\\\ \\vdots & \\ddots & \\vdots & \\vdots \\\\ \\dots & \\dots & b_m & 0 \\\\ \\dots & \\dots & b_{m-1} & b_m \\end{bmatrix} \\begin{bmatrix}d_{n-m} \\\\ \\vdots \\\\ d_1 \\\\ d_0\\end{bmatrix}$$ From the looks of it, we can conclude that with the introduction of reversed polynomials $$A^R(x) = x^nA(x^{-1})= a_n + a_{n-1} x + \\dots + a_0 x^n$$ $$B^R(x) = x^m B(x^{-1}) = b_m + b_{m-1} x + \\dots + b_0 x^m$$ $$D^R(x) = x^{n-m}D(x^{-1}) = d_{n-m} + d_{n-m-1} x + \\dots + d_0 x^{n-m}$$ the system may be rewritten as $$A^R(x) \\equiv B^R(x) D^R(x) \\pmod{x^{n-m+1}}.$$ From this you can unambiguously recover all coefficients of $D(x)$ : $$\\boxed{D^R(x) \\equiv A^R(x) (B^R(x))^{-1} \\pmod{x^{n-m+1}}}$$ And from this, in turn, you can recover $R(x)$ as $R(x) = A(x) - B(x)D(x)$ . Note that the matrix above is a so-called triangular Toeplitz matrix and, as we see here, solving system of linear equations with arbitrary Toeplitz matrix is, in fact, equivalent to polynomial inversion. Moreover, inverse matrix of it would also be triangular Toeplitz matrix and its entries, in terms used above, are the coefficients of $(B^R(x))^{-1} \\pmod{x^{n-m+1}}$ . Calculating functions of polynomial \u00b6 Newton's method \u00b6 Let's generalize the Sieveking\u2013Kung algorithm. Consider equation $F(P) = 0$ where $P(x)$ should be a polynomial and $F(x)$ is some polynomial-valued function defined as $$F(x) = \\sum\\limits_{i=0}^\\infty \\alpha_i (x-\\beta)^i,$$ where $\\beta$ is some constant. It can be proven that if we introduce a new formal variable $y$ , we can express $F(x)$ as $$F(x) = F(y) + (x-y)F'(y) + (x-y)^2 G(x,y),$$ where $F'(x)$ is the derivative formal power series defined as $$F'(x) = \\sum\\limits_{i=0}^\\infty (i+1)\\alpha_{i+1}(x-\\beta)^i,$$ and $G(x, y)$ is some formal power series of $x$ and $y$ . With this result we can find the solution iteratively. Let $F(Q_k) \\equiv 0 \\pmod{x^{a}}$ . We need to find $Q_{k+1} \\equiv Q_k + x^a C \\pmod{x^{2a}}$ such that $F(Q_{k+1}) \\equiv 0 \\pmod{x^{2a}}$ . Substituting $x = Q_{k+1}$ and $y=Q_k$ in the formula above, we get $$F(Q_{k+1}) \\equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) + (Q_{k+1} - Q_k)^2 G(x, y) \\pmod x^{2a}.$$ Since $Q_{k+1} - Q_k \\equiv 0 \\pmod{x^a}$ , it also holds that $(Q_{k+1} - Q_k)^2 \\equiv 0 \\pmod{x^{2a}}$ , thus $$0 \\equiv F(Q_{k+1}) \\equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) \\pmod{x^{2a}}.$$ The last formula gives us the value of $Q_{k+1}$ : $$\\boxed{Q_{k+1} = Q_k - \\dfrac{F(Q_k)}{F'(Q_k)} \\pmod{x^{2a}}}$$ Thus, knowing how to invert polynomials and how to compute $F(Q_k)$ , we can find $n$ coefficients of $P$ with the complexity $$T(n) = T(n/2) + f(n),$$ where $f(n)$ is the time needed to compute $F(Q_k)$ and $F'(Q_k)^{-1}$ which is usually $O(n \\log n)$ . The iterative rule above is known in numerical analysis as Newton's method . Hensel's lemma \u00b6 As was mentioned earlier, formally and generically this result is known as Hensel's lemma and it may in fact used in even broader sense when we work with a series of nested rings. In this particular case we worked with a sequence of polynomial remainders modulo $x$ , $x^2$ , $x^3$ and so on. Another example where Hensel's lifting might be helpful are so-called p-adic numbers where we, in fact, work with the sequence of integer remainders modulo $p$ , $p^2$ , $p^3$ and so on. For example, Newton's method can be used to find all possible automorphic numbers (numbers that end on itself when squared) with a given number base. The problem is left as an exercise to the reader. You might consider this problem to check if your solution works for $10$ -based numbers. Logarithm \u00b6 For the function $\\ln P(x)$ it's known that: $$ \\boxed{(\\ln P(x))' = \\dfrac{P'(x)}{P(x)}} $$ Thus we can calculate $n$ coefficients of $\\ln P(x)$ in $O(n \\log n)$ . Inverse series \u00b6 Turns out, we can get the formula for $A^{-1}$ using Newton's method. For this we take the equation $A=Q^{-1}$ , thus: $$F(Q) = Q^{-1} - A$$ $$F'(Q) = -Q^{-2}$$ $$\\boxed{Q_{k+1} \\equiv Q_k(2-AQ_k) \\pmod{x^{2^{k+1}}}}$$ Exponent \u00b6 Let's learn to calculate $e^{P(x)}=Q(x)$ . It should hold that $\\ln Q = P$ , thus: $$F(Q) = \\ln Q - P$$ $$F'(Q) = Q^{-1}$$ $$\\boxed{Q_{k+1} \\equiv Q_k(1 + P - \\ln Q_k) \\pmod{x^{2^{k+1}}}}$$ $k$ -th power \u00b6 Now we need to calculate $P^k(x)=Q$ . This may be done via the following formula: $$Q = \\exp\\left[k \\ln P(x)\\right]$$ Note though, that you can calculate the logarithms and the exponents correctly only if you can find some initial $Q_0$ . To find it, you should calculate the logarithm or the exponent of the constant coefficient of the polynomial. But the only reasonable way to do it is if $P(0)=1$ for $Q = \\ln P$ so $Q(0)=0$ and if $P(0)=0$ for $Q = e^P$ so $Q(0)=1$ . Thus you can use formula above only if $P(0) = 1$ . Otherwise if $P(x) = \\alpha x^t T(x)$ where $T(0)=1$ you can write that: $$\\boxed{P^k(x) = \\alpha^kx^{kt} \\exp[k \\ln T(x)]}$$ Note that you also can calculate some $k$ -th root of a polynomial if you can calculate $\\sqrt[k]{\\alpha}$ , for example for $\\alpha=1$ . Evaluation and Interpolation \u00b6 Chirp-z Transform \u00b6 For the particular case when you need to evaluate a polynomial in the points $x_r = z^{2r}$ you can do the following: $$A(z^{2r}) = \\sum\\limits_{k=0}^n a_k z^{2kr}$$ Let's substitute $2kr = r^2+k^2-(r-k)^2$ . Then this sum rewrites as: $$\\boxed{A(z^{2r}) = z^{r^2}\\sum\\limits_{k=0}^n (a_k z^{k^2}) z^{-(r-k)^2}}$$ Which is up to the factor $z^{r^2}$ equal to the convolution of the sequences $u_k = a_k z^{k^2}$ and $v_k = z^{-k^2}$ . Note that $u_k$ has indexes from $0$ to $n$ here and $v_k$ has indexes from $-n$ to $m$ where $m$ is the maximum power of $z$ which you need. Now if you need to evaluate a polynomial in the points $x_r = z^{2r+1}$ you can reduce it to the previous task by the transformation $a_k \\to a_k z^k$ . It gives us an $O(n \\log n)$ algorithm when you need to compute values in powers of $z$ , thus you may compute the DFT for non-powers of two. Another observation is that $kr = \\binom{k+r}{2} - \\binom{k}{2} - \\binom{r}{2}$ . Then we have $$\\boxed{A(z^r) = z^{-\\binom{r}{2}}\\sum\\limits_{k=0}^n \\left(a_k z^{-\\binom{k}{2}}\\right)z^{\\binom{k+r}{2}}}$$ The coefficient of $x^{n+r}$ of the product of the polynomials $A_0(x) = \\sum\\limits_{k=0}^n a_{n-k}z^{-\\binom{n-k}{2}}x^k$ and $A_1(x) = \\sum\\limits_{k\\geq 0}z^{\\binom{k}{2}}x^k$ equals $z^{\\binom{r}{2}}A(z^r)$ . You can use the formula $z^{\\binom{k+1}{2}}=z^{\\binom{k}{2}+k}$ to calculate the coefficients of $A_0(x)$ and $A_1(x)$ . Multi-point Evaluation \u00b6 Assume you need to calculate $A(x_1), \\dots, A(x_n)$ . As mentioned earlier, $A(x) \\equiv A(x_i) \\pmod{x-x_i}$ . Thus you may do the following: Compute a segment tree such that in the segment $[l,r)$ stands the product $P_{l, r}(x) = (x-x_l)(x-x_{l+1})\\dots(x-x_{r-1})$ . Starting with $l=1$ and $r=n+1$ at the root node. Let $m=\\lfloor(l+r)/2\\rfloor$ . Let's move down to $[l,m)$ with the polynomial $A(x) \\pmod{P_{l,m}(x)}$ . This will recursively compute $A(x_l), \\dots, A(x_{m-1})$ , now do the same for $[m,r)$ with $A(x) \\pmod{P_{m,r}(x)}$ . Concatenate the results from the first and second recursive call and return them. The whole procedure will run in $O(n \\log^2 n)$ . Interpolation \u00b6 There's a direct formula by Lagrange to interpolate a polynomial, given set of pairs $(x_i, y_i)$ : $$\\boxed{A(x) = \\sum\\limits_{i=1}^n y_i \\prod\\limits_{j \\neq i}\\dfrac{x-x_j}{x_i - x_j}}$$ Computing it directly is a hard thing but turns out, we may compute it in $O(n \\log^2 n)$ with a divide and conquer approach: Consider $P(x) = (x-x_1)\\dots(x-x_n)$ . To know the coefficients of the denominators in $A(x)$ we should compute products like: $$ P_i = \\prod\\limits_{j \\neq i} (x_i-x_j) $$ But if you consider the derivative $P'(x)$ you'll find out that $P'(x_i) = P_i$ . Thus you can compute $P_i$ 's via evaluation in $O(n \\log^2 n)$ . Now consider the recursive algorithm done on same segment tree as in the multi-point evaluation. It starts in the leaves with the value $\\dfrac{y_i}{P_i}$ in each leaf. When we return from the recursion we should merge the results from the left and the right vertices as $A_{l,r} = A_{l,m}P_{m,r} + P_{l,m} A_{m,r}$ . In this way when you return back to the root you'll have exactly $A(x)$ in it. The total procedure also works in $O(n \\log^2 n)$ . GCD and Resultants \u00b6 Assume you're given polynomials $A(x) = a_0 + a_1 x + \\dots + a_n x^n$ and $B(x) = b_0 + b_1 x + \\dots + b_m x^m$ . Let $\\lambda_0, \\dots, \\lambda_n$ be the roots of $A(x)$ and let $\\mu_0, \\dots, \\mu_m$ be the roots of $B(x)$ counted with their multiplicities. You want to know if $A(x)$ and $B(x)$ have any roots in common. There are two interconnected ways to do that. Euclidean algorithm \u00b6 Well, we already have an article about it. For an arbitrary domain you can write the Euclidean algorithm as easy as: template < typename T > T gcd ( const T & a , const T & b ) { return b == T ( 0 ) ? a : gcd ( b , a % b ); } It can be proven that for polynomials $A(x)$ and $B(x)$ it will work in $O(nm)$ . Resultant \u00b6 Let's calculate the product $A(\\mu_0)\\cdots A(\\mu_m)$ . It will be equal to zero if and only if some $\\mu_i$ is the root of $A(x)$ . For symmetry we can also multiply it with $b_m^n$ and rewrite the whole product in the following form: $$\\boxed{\\mathcal{R}(A, B) = b_m^n\\prod\\limits_{j=0}^m A(\\mu_j) = b_m^n a_m^n \\prod\\limits_{i=0}^n \\prod\\limits_{j=0}^m (\\mu_j - \\lambda_i)= (-1)^{mn}a_n^m \\prod\\limits_{i=0}^n B(\\lambda_i)}$$ The value defined above is called the resultant of the polynomials $A(x)$ and $B(x)$ . From the definition you may find the following properties: $\\mathcal R(A, B) = (-1)^{nm} \\mathcal R(B, A)$ . $\\mathcal R(A, B)= a_n^m b_m^n$ when $n=0$ or $m=0$ . If $b_m=1$ then $\\mathcal R(A - CB, B) = \\mathcal R(A, B)$ for an arbitrary polynomial $C(x)$ and $n,m \\geq 1$ . From this follows $\\mathcal R(A, B) = b_m^{\\deg(A) - \\deg(A-CB)}\\mathcal R(A - CB, B)$ for arbitrary $A(x)$ , $B(x)$ , $C(x)$ . Miraculously it means that resultant of two polynomials is actually always from the same ring as their coefficients! Also these properties allow us to calculate the resultant alongside the Euclidean algorithm, which works in $O(nm)$ . template < typename T > T resultant ( poly < T > a , poly < T > b ) { if ( b . is_zero ()) { return 0 ; } else if ( b . deg () == 0 ) { return bpow ( b . lead (), a . deg ()); } else { int pw = a . deg (); a %= b ; pw -= a . deg (); base mul = bpow ( b . lead (), pw ) * base (( b . deg () & a . deg () & 1 ) ? -1 : 1 ); base ans = resultant ( b , a ); return ans * mul ; } } Half-GCD algorithm \u00b6 There is a way to calculate the GCD and resultants in $O(n \\log^2 n)$ . The procedure to do so implements a $2 \\times 2$ linear transform which maps a pair of polynomials $a(x)$ , $b(x)$ into another pair $c(x), d(x)$ such that $\\deg d(x) \\leq \\frac{\\deg a(x)}{2}$ . If you're careful enough, you can compute the half-GCD of any pair of polynomials with at most $2$ recursive calls to the polynomials which are at least $2$ times smaller. The specific details of the algorithm are somewhat tedious to explain, however you can find its implementation in the library, as half_gcd function. After half-GCD is implemented, you can repeatedly apply it to polynomials until you're reduced to the pair of $\\gcd(a, b)$ and $0$ . Problems \u00b6 CodeChef - RNG CodeForces - Basis Change CodeForces - Permutant CodeForces - Medium Hadron Collider","title":"Operations on polynomials and series"},{"location":"algebra/polynomial.html#operations-on-polynomials-and-series","text":"Problems in competitive programming, especially the ones involving enumeration some kind, are often solved by reducing the problem to computing something on polynomials and formal power series. This includes concepts such as polynomial multiplication, interpolation, and more complicated ones, such as polynomial logarithms and exponents. In this article, a brief overview of such operations and common approaches to them is presented.","title":"Operations on polynomials and series"},{"location":"algebra/polynomial.html#basic-notion-and-facts","text":"In this section, we focus more on the definitions and \"intuitive\" properties of various polynomial operations. The technical details of their implementation and complexities will be covered in later sections.","title":"Basic Notion and facts"},{"location":"algebra/polynomial.html#polynomial-multiplication","text":"Definition Univariate polynomial is an expression of form $A(x) = a_0 + a_1 x + \\dots + a_n x^n$ . The values $a_0, \\dots, a_n$ are polynomial coefficients, typically taken from some set of numbers or number-like structures. In this article, we assume that the coefficients are taken from some field , meaning that operations of addition, subtraction, multiplication and division are well-defined for them (except for division by $0$ ) and they generally behave in a similar way to real numbers. Typical example of such field is the field of remainders modulo prime number $p$ . For simplicity we will drop the term univariate , as this is the only kind of polynomials we consider in this article. We will also write $A$ instead of $A(x)$ wherever possible, which will be understandable from the context. It is assumed that either $a_n \\neq 0$ or $A(x)=0$ . Definition The product of two polynomials is defined by expanding it as an arithmetic expression: $$ A(x) B(x) = \\left(\\sum\\limits_{i=0}^n a_i x^i \\right)\\left(\\sum\\limits_{j=0}^m b_j x^j\\right) = \\sum\\limits_{i,j} a_i b_j x^{i+j} = \\sum\\limits_{k=0}^{n+m} c_k x^k = C(x). $$ The sequence $c_0, c_1, \\dots, c_{n+m}$ of the coefficients of $C(x)$ is called the convolution of $a_0, \\dots, a_n$ and $b_0, \\dots, b_m$ . Definition The degree of a polynomial $A$ with $a_n \\neq 0$ is defined as $\\deg A = n$ . For consistency, degree of $A(x) = 0$ is defined as $\\deg A = -\\infty$ . In this notion, $\\deg AB = \\deg A + \\deg B$ for any polynomials $A$ and $B$ . Convolutions are the basis of solving many enumerative problems. Example You have $n$ objects of the first kind and $m$ objects of the second kind. Objects of first kind are valued $a_1, \\dots, a_n$ , and objects of the second kind are valued $b_1, \\dots, b_m$ . You pick a single object of the first kind and a single object of the second kind. How many ways are there to get the total value $k$ ? Solution Consider the product $(x^{a_1} + \\dots + x^{a_n})(x^{b_1} + \\dots + x^{b_m})$ . If you expand it, each monomial will correspond to the pair $(a_i, b_j)$ and contribute to the coefficient near $x^{a_i+b_j}$ . In other words, the answer is the coefficient near $x^k$ in the product. Example You throw a $6$ -sided die $n$ times and sum up the results from all throws. What is the probability of getting sum of $k$ ? Solution The answer is the number of outcomes having the sum $k$ , divided by the total number of outcomes, which is $6^n$ . What is the number of outcomes having the sum $k$ ? For $n=1$ , it may be represented by a polynomial $A(x) = x^1+x^2+\\dots+x^6$ . For $n=2$ , using the same approach as in the example above, we conclude that it is represented by the polynomial $(x^1+x^2+\\dots+x^6)^2$ . That being said, the answer to the problem is the $k$ -th coefficient of $(x^1+x^2+\\dots+x^6)^n$ , divided by $6^n$ . The coefficient near $x^k$ in the polynomial $A(x)$ is denoted shortly as $[x^k]A$ .","title":"Polynomial multiplication"},{"location":"algebra/polynomial.html#formal-power-series","text":"Definition A formal power series is an infinite sum $A(x) = a_0 + a_1 x + a_2 x^2 + \\dots$ , considered regardless of its convergence properties. In other words, when we consider e.g. a sum $1+\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\dots=2$ , we imply that it converges to $2$ when the number of summands approach infinity. However, formal series are only considered in terms of sequences that make them. Definition The product of formal power series $A(x)$ and $B(x)$ , is also defined by expanding it as an arithmetic expression: $$ A(x) B(x) = \\left(\\sum\\limits_{i=0}^\\infty a_i x^i \\right)\\left(\\sum\\limits_{j=0}^\\infty b_j x^j\\right) = \\sum\\limits_{i,j} a_i b_j x^{i+j} = \\sum\\limits_{k=0}^{\\infty} c_k x^k = C(x), $$ where the coefficients $c_0, c_1, \\dots$ are define as finite sums $$ c_k = \\sum\\limits_{i=0}^k a_i b_{k-i}. $$ The sequence $c_0, c_1, \\dots$ is also called a convolution of $a_0, a_1, \\dots$ and $b_0, b_1, \\dots$ , generalizing the concept to infinite sequences. Thus, polynomials may be considered formal power series, but with finite number of coefficients. Formal power series play a crucial role in enumerative combinatorics, where they're studied as generating functions for various sequences. Detailed explanation of generating functions and the intuition behind them will, unfortunately, be out of scope for this article, therefore the curious reader is referenced e.g. here for details about their combinatorial meaning. However, we will very briefly mention that if $A(x)$ and $B(x)$ are generating functions for sequences that enumerate some objects by number of \"atoms\" in them (e.g. trees by the number of vertices), then the product $A(x) B(x)$ enumerates objects that can be described as pairs of objects of kinds $A$ and $B$ , enumerates by the total number of \"atoms\" in the pair. Example Let $A(x) = \\sum\\limits_{i=0}^\\infty 2^i x^i$ enumerate packs of stones, each stone colored in one of $2$ colors (so, there are $2^i$ such packs of size $i$ ) and $B(x) = \\sum\\limits_{j=0}^{\\infty} 3^j x^j$ enumerate packs of stones, each stone colored in one of $3$ colors. Then $C(x) = A(x) B(x) = \\sum\\limits_{k=0}^\\infty c_k x^k$ would enumerate objects that may be described as \"two packs of stones, first pack only of stones of type $A$ , second pack only of stones of type $B$ , with total number of stones being $k$ \" for $c_k$ . In a similar way, there is an intuitive meaning to some other functions over formal power series.","title":"Formal power series"},{"location":"algebra/polynomial.html#long-polynomial-division","text":"Similar to integers, it is possible to define long division on polynomials. Definition For any polynomials $A$ and $B \\neq 0$ , one may represent $A$ as $$ A = D \\cdot B + R,~ \\deg R < \\deg B, $$ where $R$ is called the remainder of $A$ modulo $B$ and $D$ is called the quotient . Denoting $\\deg A = n$ and $\\deg B = m$ , naive way to do it is to use long division, during which you multiply $B$ by the monomial $\\frac{a_n}{b_m} x^{n - m}$ and subtract it from $A$ , until the degree of $A$ is smaller than that of $B$ . What remains of $A$ in the end will be the remainder (hence the name), and the polynomials with which you multiplied $B$ in the process, summed together, form the quotient. Definition If $A$ and $B$ have the same remainder modulo $C$ , they're said to be equivalent modulo $C$ , which is denoted as $$ A \\equiv B \\pmod{C}. $$ Polynomial long division is useful because of its many important properties: $A$ is a multiple of $B$ if and only if $A \\equiv 0 \\pmod B$ . It implies that $A \\equiv B \\pmod C$ if and only if $A-B$ is a multiple of $C$ . In particular, $A \\equiv B \\pmod{C \\cdot D}$ implies $A \\equiv B \\pmod{C}$ . For any linear polynomial $x-r$ it holds that $A(x) \\equiv A(r) \\pmod{x-r}$ . It implies that $A$ is a multiple of $x-r$ if and only if $A(r)=0$ . For modulo being $x^k$ , it holds that $A \\equiv a_0 + a_1 x + \\dots + a_{k-1} x^{k-1} \\pmod{x^k}$ . Note that long division can't be properly defined for formal power series. Instead, for any $A(x)$ such that $a_0 \\neq 0$ , it is possible to define an inverse formal power series $A^{-1}(x)$ , such that $A(x) A^{-1}(x) = 1$ . This fact, in turn, can be used to compute the result of long division for polynomials.","title":"Long polynomial division"},{"location":"algebra/polynomial.html#basic-implementation","text":"Here you can find the basic implementation of polynomial algebra. It supports all trivial operations and some other useful methods. The main class is poly<T> for polynomials with coefficients of type T . All arithmetic operation + , - , * , % and / are supported, % and / standing for remainder and quotient in Euclidean division. There is also the class modular<m> for performing arithmetic operations on remainders modulo a prime number m . Other useful functions: deriv() : computes the derivative $P'(x)$ of $P(x)$ . integr() : computes the indefinite integral $Q(x) = \\int P(x)$ of $P(x)$ such that $Q(0)=0$ . inv(size_t n) : calculate the first $n$ coefficients of $P^{-1}(x)$ in $O(n \\log n)$ . log(size_t n) : calculate the first $n$ coefficients of $\\ln P(x)$ in $O(n \\log n)$ . exp(size_t n) : calculate the first $n$ coefficients of $\\exp P(x)$ in $O(n \\log n)$ . pow(size_t k, size_t n) : calculate the first $n$ coefficients for $P^{k}(x)$ in $O(n \\log nk)$ . deg() : returns the degree of $P(x)$ . lead() : returns the coefficient of $x^{\\deg P(x)}$ . resultant(poly<T> a, poly<T> b) : computes the resultant of $a$ and $b$ in $O(|a| \\cdot |b|)$ . bpow(T x, size_t n) : computes $x^n$ . bpow(T x, size_t n, T m) : computes $x^n \\pmod{m}$ . chirpz(T z, size_t n) : computes $P(1), P(z), P(z^2), \\dots, P(z^{n-1})$ in $O(n \\log n)$ . vector<T> eval(vector<T> x) : evaluates $P(x_1), \\dots, P(x_n)$ in $O(n \\log^2 n)$ . poly<T> inter(vector<T> x, vector<T> y) : interpolates a polynomial by a set of pairs $P(x_i) = y_i$ in $O(n \\log^2 n)$ . And some more, feel free to explore the code!","title":"Basic implementation"},{"location":"algebra/polynomial.html#arithmetic","text":"","title":"Arithmetic"},{"location":"algebra/polynomial.html#multiplication","text":"The very core operation is the multiplication of two polynomials. That is, given the polynomials $A$ and $B$ : $$A = a_0 + a_1 x + \\dots + a_n x^n$$ $$B = b_0 + b_1 x + \\dots + b_m x^m$$ You have to compute polynomial $C = A \\cdot B$ , which is defined as $$\\boxed{C = \\sum\\limits_{i=0}^n \\sum\\limits_{j=0}^m a_i b_j x^{i+j}} = c_0 + c_1 x + \\dots + c_{n+m} x^{n+m}.$$ It can be computed in $O(n \\log n)$ via the Fast Fourier transform and almost all methods here will use it as subroutine.","title":"Multiplication"},{"location":"algebra/polynomial.html#inverse-series","text":"If $A(0) \\neq 0$ there always exists an infinite formal power series $A^{-1}(x) = q_0+q_1 x + q_2 x^2 + \\dots$ such that $A^{-1} A = 1$ . It often proves useful to compute first $k$ coefficients of $A^{-1}$ (that is, to compute it modulo $x^k$ ). There are two major ways to calculate it.","title":"Inverse series"},{"location":"algebra/polynomial.html#divide-and-conquer","text":"This algorithm was mentioned in Sch\u00f6nhage's article and is inspired by Graeffe's method . It is known that for $B(x)=A(x)A(-x)$ it holds that $B(x)=B(-x)$ , that is, $B(x)$ is an even polynomial. It means that it only has non-zero coefficients with even numbers and can be represented as $B(x)=T(x^2)$ . Thus, we can do the following transition: $$A^{-1}(x) \\equiv \\frac{1}{A(x)} \\equiv \\frac{A(-x)}{A(x)A(-x)} \\equiv \\frac{A(-x)}{T(x^2)} \\pmod{x^k}$$ Note that $T(x)$ can be computed with a single multiplication, after which we're only interested in the first half of coefficients of its inverse series. This effectively reduces the initial problem of computing $A^{-1} \\pmod{x^k}$ to computing $T^{-1} \\pmod{x^{\\lfloor k / 2 \\rfloor}}$ . The complexity of this method can be estimated as $$T(n) = T(n/2) + O(n \\log n) = O(n \\log n).$$","title":"Divide and conquer"},{"location":"algebra/polynomial.html#sievekingkung-algorithm","text":"The generic process described here is known as Hensel lifting, as it follows from Hensel's lemma. We'll cover it in more detail further below, but for now let's focus on ad hoc solution. \"Lifting\" part here means that we start with the approximation $B_0=q_0=a_0^{-1}$ , which is $A^{-1} \\pmod x$ and then iteratively lift from $\\bmod x^a$ to $\\bmod x^{2a}$ . Let $B_k \\equiv A^{-1} \\pmod{x^a}$ . The next approximation needs to follow the equation $A B_{k+1} \\equiv 1 \\pmod{x^{2a}}$ and may be represented as $B_{k+1} = B_k + x^a C$ . From this follows the equation $$A(B_k + x^{a}C) \\equiv 1 \\pmod{x^{2a}}.$$ Let $A B_k \\equiv 1 + x^a D \\pmod{x^{2a}}$ , then the equation above implies $$x^a(D+AC) \\equiv 0 \\pmod{x^{2a}} \\implies D \\equiv -AC \\pmod{x^a} \\implies C \\equiv -B_k D \\pmod{x^a}.$$ From this, one can obtain the final formula, which is $$x^a C \\equiv -B_k x^a D \\equiv B_k(1-AB_k) \\pmod{x^{2a}} \\implies \\boxed{B_{k+1} \\equiv B_k(2-AB_k) \\pmod{x^{2a}}}$$ Thus starting with $B_0 \\equiv a_0^{-1} \\pmod x$ we will compute the sequence $B_k$ such that $AB_k \\equiv 1 \\pmod{x^{2^k}}$ with the complexity $$T(n) = T(n/2) + O(n \\log n) = O(n \\log n).$$ The algorithm here might seem a bit more complicated than the first one, but it has a very solid and practical reasoning behind it, as well as a great generalization potential if looked from a different perspective, which would be explained further below.","title":"Sieveking\u2013Kung algorithm"},{"location":"algebra/polynomial.html#euclidean-division","text":"Consider two polynomials $A(x)$ and $B(x)$ of degrees $n$ and $m$ . As it was said earlier you can rewrite $A(x)$ as $$A(x) = B(x) D(x) + R(x), \\deg R < \\deg B.$$ Let $n \\geq m$ , it would imply that $\\deg D = n - m$ and the leading $n-m+1$ coefficients of $A$ don't influence $R$ . It means that you can recover $D(x)$ from the largest $n-m+1$ coefficients of $A(x)$ and $B(x)$ if you consider it as a system of equations. The system of linear equations we're talking about can be written in the following form: $$\\begin{bmatrix} a_n \\\\ \\vdots \\\\ a_{m+1} \\\\ a_{m} \\end{bmatrix} = \\begin{bmatrix} b_m & \\dots & 0 & 0 \\\\ \\vdots & \\ddots & \\vdots & \\vdots \\\\ \\dots & \\dots & b_m & 0 \\\\ \\dots & \\dots & b_{m-1} & b_m \\end{bmatrix} \\begin{bmatrix}d_{n-m} \\\\ \\vdots \\\\ d_1 \\\\ d_0\\end{bmatrix}$$ From the looks of it, we can conclude that with the introduction of reversed polynomials $$A^R(x) = x^nA(x^{-1})= a_n + a_{n-1} x + \\dots + a_0 x^n$$ $$B^R(x) = x^m B(x^{-1}) = b_m + b_{m-1} x + \\dots + b_0 x^m$$ $$D^R(x) = x^{n-m}D(x^{-1}) = d_{n-m} + d_{n-m-1} x + \\dots + d_0 x^{n-m}$$ the system may be rewritten as $$A^R(x) \\equiv B^R(x) D^R(x) \\pmod{x^{n-m+1}}.$$ From this you can unambiguously recover all coefficients of $D(x)$ : $$\\boxed{D^R(x) \\equiv A^R(x) (B^R(x))^{-1} \\pmod{x^{n-m+1}}}$$ And from this, in turn, you can recover $R(x)$ as $R(x) = A(x) - B(x)D(x)$ . Note that the matrix above is a so-called triangular Toeplitz matrix and, as we see here, solving system of linear equations with arbitrary Toeplitz matrix is, in fact, equivalent to polynomial inversion. Moreover, inverse matrix of it would also be triangular Toeplitz matrix and its entries, in terms used above, are the coefficients of $(B^R(x))^{-1} \\pmod{x^{n-m+1}}$ .","title":"Euclidean division"},{"location":"algebra/polynomial.html#calculating-functions-of-polynomial","text":"","title":"Calculating functions of polynomial"},{"location":"algebra/polynomial.html#newtons-method","text":"Let's generalize the Sieveking\u2013Kung algorithm. Consider equation $F(P) = 0$ where $P(x)$ should be a polynomial and $F(x)$ is some polynomial-valued function defined as $$F(x) = \\sum\\limits_{i=0}^\\infty \\alpha_i (x-\\beta)^i,$$ where $\\beta$ is some constant. It can be proven that if we introduce a new formal variable $y$ , we can express $F(x)$ as $$F(x) = F(y) + (x-y)F'(y) + (x-y)^2 G(x,y),$$ where $F'(x)$ is the derivative formal power series defined as $$F'(x) = \\sum\\limits_{i=0}^\\infty (i+1)\\alpha_{i+1}(x-\\beta)^i,$$ and $G(x, y)$ is some formal power series of $x$ and $y$ . With this result we can find the solution iteratively. Let $F(Q_k) \\equiv 0 \\pmod{x^{a}}$ . We need to find $Q_{k+1} \\equiv Q_k + x^a C \\pmod{x^{2a}}$ such that $F(Q_{k+1}) \\equiv 0 \\pmod{x^{2a}}$ . Substituting $x = Q_{k+1}$ and $y=Q_k$ in the formula above, we get $$F(Q_{k+1}) \\equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) + (Q_{k+1} - Q_k)^2 G(x, y) \\pmod x^{2a}.$$ Since $Q_{k+1} - Q_k \\equiv 0 \\pmod{x^a}$ , it also holds that $(Q_{k+1} - Q_k)^2 \\equiv 0 \\pmod{x^{2a}}$ , thus $$0 \\equiv F(Q_{k+1}) \\equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) \\pmod{x^{2a}}.$$ The last formula gives us the value of $Q_{k+1}$ : $$\\boxed{Q_{k+1} = Q_k - \\dfrac{F(Q_k)}{F'(Q_k)} \\pmod{x^{2a}}}$$ Thus, knowing how to invert polynomials and how to compute $F(Q_k)$ , we can find $n$ coefficients of $P$ with the complexity $$T(n) = T(n/2) + f(n),$$ where $f(n)$ is the time needed to compute $F(Q_k)$ and $F'(Q_k)^{-1}$ which is usually $O(n \\log n)$ . The iterative rule above is known in numerical analysis as Newton's method .","title":"Newton's method"},{"location":"algebra/polynomial.html#hensels-lemma","text":"As was mentioned earlier, formally and generically this result is known as Hensel's lemma and it may in fact used in even broader sense when we work with a series of nested rings. In this particular case we worked with a sequence of polynomial remainders modulo $x$ , $x^2$ , $x^3$ and so on. Another example where Hensel's lifting might be helpful are so-called p-adic numbers where we, in fact, work with the sequence of integer remainders modulo $p$ , $p^2$ , $p^3$ and so on. For example, Newton's method can be used to find all possible automorphic numbers (numbers that end on itself when squared) with a given number base. The problem is left as an exercise to the reader. You might consider this problem to check if your solution works for $10$ -based numbers.","title":"Hensel's lemma"},{"location":"algebra/polynomial.html#logarithm","text":"For the function $\\ln P(x)$ it's known that: $$ \\boxed{(\\ln P(x))' = \\dfrac{P'(x)}{P(x)}} $$ Thus we can calculate $n$ coefficients of $\\ln P(x)$ in $O(n \\log n)$ .","title":"Logarithm"},{"location":"algebra/polynomial.html#inverse-series_1","text":"Turns out, we can get the formula for $A^{-1}$ using Newton's method. For this we take the equation $A=Q^{-1}$ , thus: $$F(Q) = Q^{-1} - A$$ $$F'(Q) = -Q^{-2}$$ $$\\boxed{Q_{k+1} \\equiv Q_k(2-AQ_k) \\pmod{x^{2^{k+1}}}}$$","title":"Inverse series"},{"location":"algebra/polynomial.html#exponent","text":"Let's learn to calculate $e^{P(x)}=Q(x)$ . It should hold that $\\ln Q = P$ , thus: $$F(Q) = \\ln Q - P$$ $$F'(Q) = Q^{-1}$$ $$\\boxed{Q_{k+1} \\equiv Q_k(1 + P - \\ln Q_k) \\pmod{x^{2^{k+1}}}}$$","title":"Exponent"},{"location":"algebra/polynomial.html#k-th-power","text":"Now we need to calculate $P^k(x)=Q$ . This may be done via the following formula: $$Q = \\exp\\left[k \\ln P(x)\\right]$$ Note though, that you can calculate the logarithms and the exponents correctly only if you can find some initial $Q_0$ . To find it, you should calculate the logarithm or the exponent of the constant coefficient of the polynomial. But the only reasonable way to do it is if $P(0)=1$ for $Q = \\ln P$ so $Q(0)=0$ and if $P(0)=0$ for $Q = e^P$ so $Q(0)=1$ . Thus you can use formula above only if $P(0) = 1$ . Otherwise if $P(x) = \\alpha x^t T(x)$ where $T(0)=1$ you can write that: $$\\boxed{P^k(x) = \\alpha^kx^{kt} \\exp[k \\ln T(x)]}$$ Note that you also can calculate some $k$ -th root of a polynomial if you can calculate $\\sqrt[k]{\\alpha}$ , for example for $\\alpha=1$ .","title":"k-th power"},{"location":"algebra/polynomial.html#evaluation-and-interpolation","text":"","title":"Evaluation and Interpolation"},{"location":"algebra/polynomial.html#chirp-z-transform","text":"For the particular case when you need to evaluate a polynomial in the points $x_r = z^{2r}$ you can do the following: $$A(z^{2r}) = \\sum\\limits_{k=0}^n a_k z^{2kr}$$ Let's substitute $2kr = r^2+k^2-(r-k)^2$ . Then this sum rewrites as: $$\\boxed{A(z^{2r}) = z^{r^2}\\sum\\limits_{k=0}^n (a_k z^{k^2}) z^{-(r-k)^2}}$$ Which is up to the factor $z^{r^2}$ equal to the convolution of the sequences $u_k = a_k z^{k^2}$ and $v_k = z^{-k^2}$ . Note that $u_k$ has indexes from $0$ to $n$ here and $v_k$ has indexes from $-n$ to $m$ where $m$ is the maximum power of $z$ which you need. Now if you need to evaluate a polynomial in the points $x_r = z^{2r+1}$ you can reduce it to the previous task by the transformation $a_k \\to a_k z^k$ . It gives us an $O(n \\log n)$ algorithm when you need to compute values in powers of $z$ , thus you may compute the DFT for non-powers of two. Another observation is that $kr = \\binom{k+r}{2} - \\binom{k}{2} - \\binom{r}{2}$ . Then we have $$\\boxed{A(z^r) = z^{-\\binom{r}{2}}\\sum\\limits_{k=0}^n \\left(a_k z^{-\\binom{k}{2}}\\right)z^{\\binom{k+r}{2}}}$$ The coefficient of $x^{n+r}$ of the product of the polynomials $A_0(x) = \\sum\\limits_{k=0}^n a_{n-k}z^{-\\binom{n-k}{2}}x^k$ and $A_1(x) = \\sum\\limits_{k\\geq 0}z^{\\binom{k}{2}}x^k$ equals $z^{\\binom{r}{2}}A(z^r)$ . You can use the formula $z^{\\binom{k+1}{2}}=z^{\\binom{k}{2}+k}$ to calculate the coefficients of $A_0(x)$ and $A_1(x)$ .","title":"Chirp-z Transform"},{"location":"algebra/polynomial.html#multi-point-evaluation","text":"Assume you need to calculate $A(x_1), \\dots, A(x_n)$ . As mentioned earlier, $A(x) \\equiv A(x_i) \\pmod{x-x_i}$ . Thus you may do the following: Compute a segment tree such that in the segment $[l,r)$ stands the product $P_{l, r}(x) = (x-x_l)(x-x_{l+1})\\dots(x-x_{r-1})$ . Starting with $l=1$ and $r=n+1$ at the root node. Let $m=\\lfloor(l+r)/2\\rfloor$ . Let's move down to $[l,m)$ with the polynomial $A(x) \\pmod{P_{l,m}(x)}$ . This will recursively compute $A(x_l), \\dots, A(x_{m-1})$ , now do the same for $[m,r)$ with $A(x) \\pmod{P_{m,r}(x)}$ . Concatenate the results from the first and second recursive call and return them. The whole procedure will run in $O(n \\log^2 n)$ .","title":"Multi-point Evaluation"},{"location":"algebra/polynomial.html#interpolation","text":"There's a direct formula by Lagrange to interpolate a polynomial, given set of pairs $(x_i, y_i)$ : $$\\boxed{A(x) = \\sum\\limits_{i=1}^n y_i \\prod\\limits_{j \\neq i}\\dfrac{x-x_j}{x_i - x_j}}$$ Computing it directly is a hard thing but turns out, we may compute it in $O(n \\log^2 n)$ with a divide and conquer approach: Consider $P(x) = (x-x_1)\\dots(x-x_n)$ . To know the coefficients of the denominators in $A(x)$ we should compute products like: $$ P_i = \\prod\\limits_{j \\neq i} (x_i-x_j) $$ But if you consider the derivative $P'(x)$ you'll find out that $P'(x_i) = P_i$ . Thus you can compute $P_i$ 's via evaluation in $O(n \\log^2 n)$ . Now consider the recursive algorithm done on same segment tree as in the multi-point evaluation. It starts in the leaves with the value $\\dfrac{y_i}{P_i}$ in each leaf. When we return from the recursion we should merge the results from the left and the right vertices as $A_{l,r} = A_{l,m}P_{m,r} + P_{l,m} A_{m,r}$ . In this way when you return back to the root you'll have exactly $A(x)$ in it. The total procedure also works in $O(n \\log^2 n)$ .","title":"Interpolation"},{"location":"algebra/polynomial.html#gcd-and-resultants","text":"Assume you're given polynomials $A(x) = a_0 + a_1 x + \\dots + a_n x^n$ and $B(x) = b_0 + b_1 x + \\dots + b_m x^m$ . Let $\\lambda_0, \\dots, \\lambda_n$ be the roots of $A(x)$ and let $\\mu_0, \\dots, \\mu_m$ be the roots of $B(x)$ counted with their multiplicities. You want to know if $A(x)$ and $B(x)$ have any roots in common. There are two interconnected ways to do that.","title":"GCD and Resultants"},{"location":"algebra/polynomial.html#euclidean-algorithm","text":"Well, we already have an article about it. For an arbitrary domain you can write the Euclidean algorithm as easy as: template < typename T > T gcd ( const T & a , const T & b ) { return b == T ( 0 ) ? a : gcd ( b , a % b ); } It can be proven that for polynomials $A(x)$ and $B(x)$ it will work in $O(nm)$ .","title":"Euclidean algorithm"},{"location":"algebra/polynomial.html#resultant","text":"Let's calculate the product $A(\\mu_0)\\cdots A(\\mu_m)$ . It will be equal to zero if and only if some $\\mu_i$ is the root of $A(x)$ . For symmetry we can also multiply it with $b_m^n$ and rewrite the whole product in the following form: $$\\boxed{\\mathcal{R}(A, B) = b_m^n\\prod\\limits_{j=0}^m A(\\mu_j) = b_m^n a_m^n \\prod\\limits_{i=0}^n \\prod\\limits_{j=0}^m (\\mu_j - \\lambda_i)= (-1)^{mn}a_n^m \\prod\\limits_{i=0}^n B(\\lambda_i)}$$ The value defined above is called the resultant of the polynomials $A(x)$ and $B(x)$ . From the definition you may find the following properties: $\\mathcal R(A, B) = (-1)^{nm} \\mathcal R(B, A)$ . $\\mathcal R(A, B)= a_n^m b_m^n$ when $n=0$ or $m=0$ . If $b_m=1$ then $\\mathcal R(A - CB, B) = \\mathcal R(A, B)$ for an arbitrary polynomial $C(x)$ and $n,m \\geq 1$ . From this follows $\\mathcal R(A, B) = b_m^{\\deg(A) - \\deg(A-CB)}\\mathcal R(A - CB, B)$ for arbitrary $A(x)$ , $B(x)$ , $C(x)$ . Miraculously it means that resultant of two polynomials is actually always from the same ring as their coefficients! Also these properties allow us to calculate the resultant alongside the Euclidean algorithm, which works in $O(nm)$ . template < typename T > T resultant ( poly < T > a , poly < T > b ) { if ( b . is_zero ()) { return 0 ; } else if ( b . deg () == 0 ) { return bpow ( b . lead (), a . deg ()); } else { int pw = a . deg (); a %= b ; pw -= a . deg (); base mul = bpow ( b . lead (), pw ) * base (( b . deg () & a . deg () & 1 ) ? -1 : 1 ); base ans = resultant ( b , a ); return ans * mul ; } }","title":"Resultant"},{"location":"algebra/polynomial.html#half-gcd-algorithm","text":"There is a way to calculate the GCD and resultants in $O(n \\log^2 n)$ . The procedure to do so implements a $2 \\times 2$ linear transform which maps a pair of polynomials $a(x)$ , $b(x)$ into another pair $c(x), d(x)$ such that $\\deg d(x) \\leq \\frac{\\deg a(x)}{2}$ . If you're careful enough, you can compute the half-GCD of any pair of polynomials with at most $2$ recursive calls to the polynomials which are at least $2$ times smaller. The specific details of the algorithm are somewhat tedious to explain, however you can find its implementation in the library, as half_gcd function. After half-GCD is implemented, you can repeatedly apply it to polynomials until you're reduced to the pair of $\\gcd(a, b)$ and $0$ .","title":"Half-GCD algorithm"},{"location":"algebra/polynomial.html#problems","text":"CodeChef - RNG CodeForces - Basis Change CodeForces - Permutant CodeForces - Medium Hadron Collider","title":"Problems"},{"location":"algebra/primality_tests.html","text":"Primality tests \u00b6 This article describes multiple algorithms to determine if a number is prime or not. Trial division \u00b6 By definition a prime number doesn't have any divisors other than $1$ and itself. A composite number has at least one additional divisor, let's call it $d$ . Naturally $\\frac{n}{d}$ is also a divisor of $n$ . It's easy to see, that either $d \\le \\sqrt{n}$ or $\\frac{n}{d} \\le \\sqrt{n}$ , therefore one of the divisors $d$ and $\\frac{n}{d}$ is $\\le \\sqrt{n}$ . We can use this information to check for primality. We try to find a non-trivial divisor, by checking if any of the numbers between $2$ and $\\sqrt{n}$ is a divisor of $n$ . If it is a divisor, then $n$ is definitely not prime, otherwise it is. bool isPrime ( int x ) { for ( int d = 2 ; d * d <= x ; d ++ ) { if ( x % d == 0 ) return false ; } return x >= 2 ; } This is the simplest form of a prime check. You can optimize this function quite a bit, for instance by only checking all odd numbers in the loop, since the only even prime number is 2. Multiple such optimizations are described in the article about integer factorization . Fermat primality test \u00b6 This is a probabilistic test. Fermat's little theorem (see also Euler's totient function ) states, that for a prime number $p$ and a coprime integer $a$ the following equation holds: $$a^{p-1} \\equiv 1 \\bmod p$$ In general this theorem doesn't hold for composite numbers. This can be used to create a primality test. We pick an integer $2 \\le a \\le p - 2$ , and check if the equation holds or not. If it doesn't hold, e.g. $a^{p-1} \\not\\equiv 1 \\bmod p$ , we know that $p$ cannot be a prime number. In this case we call the base $a$ a Fermat witness for the compositeness of $p$ . However it is also possible, that the equation holds for a composite number. So if the equation holds, we don't have a proof for primality. We only can say that $p$ is probably prime . If it turns out that the number is actually composite, we call the base $a$ a Fermat liar . By running the test for all possible bases $a$ , we can actually prove that a number is prime. However this is not done in practice, since this is a lot more effort that just doing trial division . Instead the test will be repeated multiple times with random choices for $a$ . If we find no witness for the compositeness, it is very likely that the number is in fact prime. bool probablyPrimeFermat ( int n , int iter = 5 ) { if ( n < 4 ) return n == 2 || n == 3 ; for ( int i = 0 ; i < iter ; i ++ ) { int a = 2 + rand () % ( n - 3 ); if ( binpower ( a , n - 1 , n ) != 1 ) return false ; } return true ; } We use Binary Exponentiation to efficiently compute the power $a^{p-1}$ . There is one bad news though: there exist some composite numbers where $a^{n-1} \\equiv 1 \\bmod n$ holds for all $a$ coprime to $n$ , for instance for the number $561 = 3 \\cdot 11 \\cdot 17$ . Such numbers are called Carmichael numbers . The Fermat primality test can identify these numbers only, if we have immense luck and choose a base $a$ with $\\gcd(a, n) \\ne 1$ . The Fermat test is still being used in practice, as it is very fast and Carmichael numbers are very rare. E.g. there only exist 646 such numbers below $10^9$ . Miller-Rabin primality test \u00b6 The Miller-Rabin test extends the ideas from the Fermat test. For an odd number $n$ , $n-1$ is even and we can factor out all powers of 2. We can write: $$n - 1 = 2^s \\cdot d,~\\text{with}~d~\\text{odd}.$$ This allows us to factorize the equation of Fermat's little theorem: $$\\begin{array}{rl} a^{n-1} \\equiv 1 \\bmod n &\\Longleftrightarrow a^{2^s d} - 1 \\equiv 0 \\bmod n \\\\\\\\ &\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-1} d} - 1) \\equiv 0 \\bmod n \\\\\\\\ &\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) (a^{2^{s-2} d} - 1) \\equiv 0 \\bmod n \\\\\\\\ &\\quad\\vdots \\\\\\\\ &\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) \\cdots (a^{d} + 1) (a^{d} - 1) \\equiv 0 \\bmod n \\\\\\\\ \\end{array}$$ If $n$ is prime, then $n$ has to divide one of these factors. And in the Miller-Rabin primality test we check exactly that statement, which is a more stricter version of the statement of the Fermat test. For a base $2 \\le a \\le n-2$ we check if either $$a^d \\equiv 1 \\bmod n$$ holds or $$a^{2^r d} \\equiv -1 \\bmod n$$ holds for some $0 \\le r \\le s - 1$ . If we found a base $a$ which doesn't satisfy any of the above equalities, then we found a witness for the compositeness of $n$ . In this case we have proven that $n$ is not a prime number. Similar to the Fermat test, it is also possible that the set of equations is satisfied for a composite number. In that case the base $a$ is called a strong liar . If a base $a$ satisfies the equations (one of them), $n$ is only strong probable prime . However, there are no numbers like the Carmichael numbers, where all non-trivial bases lie. In fact it is possible to show, that at most $\\frac{1}{4}$ of the bases can be strong liars. If $n$ is composite, we have a probability of $\\ge 75\\%$ that a random base will tell us that it is composite. By doing multiple iterations, choosing different random bases, we can tell with very high probability if the number is truly prime or if it is composite. Here is an implementation for 64 bit integer. using u64 = uint64_t ; using u128 = __uint128_t ; u64 binpower ( u64 base , u64 e , u64 mod ) { u64 result = 1 ; base %= mod ; while ( e ) { if ( e & 1 ) result = ( u128 ) result * base % mod ; base = ( u128 ) base * base % mod ; e >>= 1 ; } return result ; } bool check_composite ( u64 n , u64 a , u64 d , int s ) { u64 x = binpower ( a , d , n ); if ( x == 1 || x == n - 1 ) return false ; for ( int r = 1 ; r < s ; r ++ ) { x = ( u128 ) x * x % n ; if ( x == n - 1 ) return false ; } return true ; }; bool MillerRabin ( u64 n , int iter = 5 ) { // returns true if n is probably prime, else returns false. if ( n < 4 ) return n == 2 || n == 3 ; int s = 0 ; u64 d = n - 1 ; while (( d & 1 ) == 0 ) { d >>= 1 ; s ++ ; } for ( int i = 0 ; i < iter ; i ++ ) { int a = 2 + rand () % ( n - 3 ); if ( check_composite ( n , a , d , s )) return false ; } return true ; } Before the Miller-Rabin test you can test additionally if one of the first few prime numbers is a divisor. This can speed up the test by a lot, since most composite numbers have very small prime divisors. E.g. $88\\%$ of all numbers have a prime factor smaller than $100$ . Deterministic version \u00b6 Miller showed that it is possible to make the algorithm deterministic by only checking all bases $\\le O((\\ln n)^2)$ . Bach later gave a concrete bound, it is only necessary to test all bases $a \\le 2 \\ln(n)^2$ . This is still a pretty large number of bases. So people have invested quite a lot of computation power into finding lower bounds. It turns out, for testing a 32 bit integer it is only necessary to check the first 4 prime bases: 2, 3, 5 and 7. The smallest composite number that fails this test is $3,215,031,751 = 151 \\cdot 751 \\cdot 28351$ . And for testing 64 bit integer it is enough to check the first 12 prime bases: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. This results in the following deterministic implementation: bool MillerRabin ( u64 n ) { // returns true if n is prime, else returns false. if ( n < 2 ) return false ; int r = 0 ; u64 d = n - 1 ; while (( d & 1 ) == 0 ) { d >>= 1 ; r ++ ; } for ( int a : { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 }) { if ( n == a ) return true ; if ( check_composite ( n , a , d , r )) return false ; } return true ; } It's also possible to do the check with only 7 bases: 2, 325, 9375, 28178, 450775, 9780504 and 1795265022. However, since these numbers (except 2) are not prime, you need to check additionally if the number you are checking is equal to any prime divisor of those bases: 2, 3, 5, 13, 19, 73, 193, 407521, 299210837. Practice Problems \u00b6 SPOJ - Prime or Not Project euler - Investigating a Prime Pattern","title":"Primality tests"},{"location":"algebra/primality_tests.html#primality-tests","text":"This article describes multiple algorithms to determine if a number is prime or not.","title":"Primality tests"},{"location":"algebra/primality_tests.html#trial-division","text":"By definition a prime number doesn't have any divisors other than $1$ and itself. A composite number has at least one additional divisor, let's call it $d$ . Naturally $\\frac{n}{d}$ is also a divisor of $n$ . It's easy to see, that either $d \\le \\sqrt{n}$ or $\\frac{n}{d} \\le \\sqrt{n}$ , therefore one of the divisors $d$ and $\\frac{n}{d}$ is $\\le \\sqrt{n}$ . We can use this information to check for primality. We try to find a non-trivial divisor, by checking if any of the numbers between $2$ and $\\sqrt{n}$ is a divisor of $n$ . If it is a divisor, then $n$ is definitely not prime, otherwise it is. bool isPrime ( int x ) { for ( int d = 2 ; d * d <= x ; d ++ ) { if ( x % d == 0 ) return false ; } return x >= 2 ; } This is the simplest form of a prime check. You can optimize this function quite a bit, for instance by only checking all odd numbers in the loop, since the only even prime number is 2. Multiple such optimizations are described in the article about integer factorization .","title":"Trial division"},{"location":"algebra/primality_tests.html#fermat-primality-test","text":"This is a probabilistic test. Fermat's little theorem (see also Euler's totient function ) states, that for a prime number $p$ and a coprime integer $a$ the following equation holds: $$a^{p-1} \\equiv 1 \\bmod p$$ In general this theorem doesn't hold for composite numbers. This can be used to create a primality test. We pick an integer $2 \\le a \\le p - 2$ , and check if the equation holds or not. If it doesn't hold, e.g. $a^{p-1} \\not\\equiv 1 \\bmod p$ , we know that $p$ cannot be a prime number. In this case we call the base $a$ a Fermat witness for the compositeness of $p$ . However it is also possible, that the equation holds for a composite number. So if the equation holds, we don't have a proof for primality. We only can say that $p$ is probably prime . If it turns out that the number is actually composite, we call the base $a$ a Fermat liar . By running the test for all possible bases $a$ , we can actually prove that a number is prime. However this is not done in practice, since this is a lot more effort that just doing trial division . Instead the test will be repeated multiple times with random choices for $a$ . If we find no witness for the compositeness, it is very likely that the number is in fact prime. bool probablyPrimeFermat ( int n , int iter = 5 ) { if ( n < 4 ) return n == 2 || n == 3 ; for ( int i = 0 ; i < iter ; i ++ ) { int a = 2 + rand () % ( n - 3 ); if ( binpower ( a , n - 1 , n ) != 1 ) return false ; } return true ; } We use Binary Exponentiation to efficiently compute the power $a^{p-1}$ . There is one bad news though: there exist some composite numbers where $a^{n-1} \\equiv 1 \\bmod n$ holds for all $a$ coprime to $n$ , for instance for the number $561 = 3 \\cdot 11 \\cdot 17$ . Such numbers are called Carmichael numbers . The Fermat primality test can identify these numbers only, if we have immense luck and choose a base $a$ with $\\gcd(a, n) \\ne 1$ . The Fermat test is still being used in practice, as it is very fast and Carmichael numbers are very rare. E.g. there only exist 646 such numbers below $10^9$ .","title":"Fermat primality test"},{"location":"algebra/primality_tests.html#miller-rabin-primality-test","text":"The Miller-Rabin test extends the ideas from the Fermat test. For an odd number $n$ , $n-1$ is even and we can factor out all powers of 2. We can write: $$n - 1 = 2^s \\cdot d,~\\text{with}~d~\\text{odd}.$$ This allows us to factorize the equation of Fermat's little theorem: $$\\begin{array}{rl} a^{n-1} \\equiv 1 \\bmod n &\\Longleftrightarrow a^{2^s d} - 1 \\equiv 0 \\bmod n \\\\\\\\ &\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-1} d} - 1) \\equiv 0 \\bmod n \\\\\\\\ &\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) (a^{2^{s-2} d} - 1) \\equiv 0 \\bmod n \\\\\\\\ &\\quad\\vdots \\\\\\\\ &\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) \\cdots (a^{d} + 1) (a^{d} - 1) \\equiv 0 \\bmod n \\\\\\\\ \\end{array}$$ If $n$ is prime, then $n$ has to divide one of these factors. And in the Miller-Rabin primality test we check exactly that statement, which is a more stricter version of the statement of the Fermat test. For a base $2 \\le a \\le n-2$ we check if either $$a^d \\equiv 1 \\bmod n$$ holds or $$a^{2^r d} \\equiv -1 \\bmod n$$ holds for some $0 \\le r \\le s - 1$ . If we found a base $a$ which doesn't satisfy any of the above equalities, then we found a witness for the compositeness of $n$ . In this case we have proven that $n$ is not a prime number. Similar to the Fermat test, it is also possible that the set of equations is satisfied for a composite number. In that case the base $a$ is called a strong liar . If a base $a$ satisfies the equations (one of them), $n$ is only strong probable prime . However, there are no numbers like the Carmichael numbers, where all non-trivial bases lie. In fact it is possible to show, that at most $\\frac{1}{4}$ of the bases can be strong liars. If $n$ is composite, we have a probability of $\\ge 75\\%$ that a random base will tell us that it is composite. By doing multiple iterations, choosing different random bases, we can tell with very high probability if the number is truly prime or if it is composite. Here is an implementation for 64 bit integer. using u64 = uint64_t ; using u128 = __uint128_t ; u64 binpower ( u64 base , u64 e , u64 mod ) { u64 result = 1 ; base %= mod ; while ( e ) { if ( e & 1 ) result = ( u128 ) result * base % mod ; base = ( u128 ) base * base % mod ; e >>= 1 ; } return result ; } bool check_composite ( u64 n , u64 a , u64 d , int s ) { u64 x = binpower ( a , d , n ); if ( x == 1 || x == n - 1 ) return false ; for ( int r = 1 ; r < s ; r ++ ) { x = ( u128 ) x * x % n ; if ( x == n - 1 ) return false ; } return true ; }; bool MillerRabin ( u64 n , int iter = 5 ) { // returns true if n is probably prime, else returns false. if ( n < 4 ) return n == 2 || n == 3 ; int s = 0 ; u64 d = n - 1 ; while (( d & 1 ) == 0 ) { d >>= 1 ; s ++ ; } for ( int i = 0 ; i < iter ; i ++ ) { int a = 2 + rand () % ( n - 3 ); if ( check_composite ( n , a , d , s )) return false ; } return true ; } Before the Miller-Rabin test you can test additionally if one of the first few prime numbers is a divisor. This can speed up the test by a lot, since most composite numbers have very small prime divisors. E.g. $88\\%$ of all numbers have a prime factor smaller than $100$ .","title":"Miller-Rabin primality test"},{"location":"algebra/primality_tests.html#deterministic-version","text":"Miller showed that it is possible to make the algorithm deterministic by only checking all bases $\\le O((\\ln n)^2)$ . Bach later gave a concrete bound, it is only necessary to test all bases $a \\le 2 \\ln(n)^2$ . This is still a pretty large number of bases. So people have invested quite a lot of computation power into finding lower bounds. It turns out, for testing a 32 bit integer it is only necessary to check the first 4 prime bases: 2, 3, 5 and 7. The smallest composite number that fails this test is $3,215,031,751 = 151 \\cdot 751 \\cdot 28351$ . And for testing 64 bit integer it is enough to check the first 12 prime bases: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. This results in the following deterministic implementation: bool MillerRabin ( u64 n ) { // returns true if n is prime, else returns false. if ( n < 2 ) return false ; int r = 0 ; u64 d = n - 1 ; while (( d & 1 ) == 0 ) { d >>= 1 ; r ++ ; } for ( int a : { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 }) { if ( n == a ) return true ; if ( check_composite ( n , a , d , r )) return false ; } return true ; } It's also possible to do the check with only 7 bases: 2, 325, 9375, 28178, 450775, 9780504 and 1795265022. However, since these numbers (except 2) are not prime, you need to check additionally if the number you are checking is equal to any prime divisor of those bases: 2, 3, 5, 13, 19, 73, 193, 407521, 299210837.","title":"Deterministic version"},{"location":"algebra/primality_tests.html#practice-problems","text":"SPOJ - Prime or Not Project euler - Investigating a Prime Pattern","title":"Practice Problems"},{"location":"algebra/prime-sieve-linear.html","text":"Linear Sieve \u00b6 Given a number $n$ , find all prime numbers in a segment $[2;n]$ . The standard way of solving a task is to use the sieve of Eratosthenes . This algorithm is very simple, but it has runtime $O(n \\log \\log n)$ . Although there are a lot of known algorithms with sublinear runtime (i.e. $o(n)$ ), the algorithm described below is interesting by its simplicity: it isn't any more complex than the classic sieve of Eratosthenes. Besides, the algorithm given here calculates factorizations of all numbers in the segment $[2; n]$ as a side effect, and that can be helpful in many practical applications. The weakness of the given algorithm is in using more memory than the classic sieve of Eratosthenes': it requires an array of $n$ numbers, while for the classic sieve of Eratosthenes it is enough to have $n$ bits of memory (which is 32 times less). Thus, it makes sense to use the described algorithm only until for numbers of order $10^7$ and not greater. The algorithm is due to Paul Pritchard. It is a variant of Algorithm 3.3 in (Pritchard, 1987: see references in the end of the article). Algorithm \u00b6 Our goal is to calculate minimum prime factor $lp [i]$ for every number $i$ in the segment $[2; n]$ . Besides, we need to store the list of all the found prime numbers - let's call it $pr []$ . We'll initialize the values $lp [i]$ with zeros, which means that we assume all numbers are prime. During the algorithm execution this array will be filled gradually. Now we'll go through the numbers from 2 to $n$ . We have two cases for the current number $i$ : $lp[i] = 0$ - that means that $i$ is prime, i.e. we haven't found any smaller factors for it. Hence, we assign $lp [i] = i$ and add $i$ to the end of the list $pr[]$ . $lp[i] \\neq 0$ - that means that $i$ is composite, and its minimum prime factor is $lp [i]$ . In both cases we update values of $lp []$ for the numbers that are divisible by $i$ . However, our goal is to learn to do so as to set a value $lp []$ at most once for every number. We can do it as follows: Let's consider numbers $x_j = i \\cdot p_j$ , where $p_j$ are all prime numbers less than or equal to $lp [i]$ (this is why we need to store the list of all prime numbers). We'll set a new value $lp [x_j] = p_j$ for all numbers of this form. The proof of correctness of this algorithm and its runtime can be found after the implementation. Implementation \u00b6 const int N = 10000000 ; vector < int > lp ( N + 1 ); vector < int > pr ; for ( int i = 2 ; i <= N ; ++ i ) { if ( lp [ i ] == 0 ) { lp [ i ] = i ; pr . push_back ( i ); } for ( int j = 0 ; i * pr [ j ] <= N ; ++ j ) { lp [ i * pr [ j ]] = pr [ j ]; if ( pr [ j ] == lp [ i ]) { break ; } } } Correctness Proof \u00b6 We need to prove that the algorithm sets all values $lp []$ correctly, and that every value will be set exactly once. Hence, the algorithm will have linear runtime, since all the remaining actions of the algorithm, obviously, work for $O (n)$ . Notice that every number $i$ has exactly one representation in form: $$i = lp [i] \\cdot x,$$ where $lp [i]$ is the minimal prime factor of $i$ , and the number $x$ doesn't have any prime factors less than $lp [i]$ , i.e. $$lp [i] \\le lp [x].$$ Now, let's compare this with the actions of our algorithm: in fact, for every $x$ it goes through all prime numbers it could be multiplied by, i.e. all prime numbers up to $lp [x]$ inclusive, in order to get the numbers in the form given above. Hence, the algorithm will go through every composite number exactly once, setting the correct values $lp []$ there. Q.E.D. Runtime and Memory \u00b6 Although the running time of $O(n)$ is better than $O(n \\log \\log n)$ of the classic sieve of Eratosthenes, the difference between them is not so big. In practice the linear sieve runs about as fast as a typical implementation of the sieve of Eratosthenes. In comparison to optimized versions of the sieve of Erathosthenes, e.g. the segmented sieve, it is much slower. Considering the memory requirements of this algorithm - an array $lp []$ of length $n$ , and an array of $pr []$ of length $\\frac n {\\ln n}$ , this algorithm seems to be worse than the classic sieve in every way. However, its redeeming quality is that this algorithm calculates an array $lp []$ , which allows us to find factorization of any number in the segment $[2; n]$ in the time of the size order of this factorization. Moreover, using just one extra array will allow us to avoid divisions when looking for factorization. Knowing the factorizations of all numbers is very useful for some tasks, and this algorithm is one of the few which allow to find them in linear time. References \u00b6 Paul Pritchard, Linear Prime-Number Sieves: a Family Tree , Science of Computer Programming, vol. 9 (1987), pp.17-35.","title":"Linear Sieve"},{"location":"algebra/prime-sieve-linear.html#linear-sieve","text":"Given a number $n$ , find all prime numbers in a segment $[2;n]$ . The standard way of solving a task is to use the sieve of Eratosthenes . This algorithm is very simple, but it has runtime $O(n \\log \\log n)$ . Although there are a lot of known algorithms with sublinear runtime (i.e. $o(n)$ ), the algorithm described below is interesting by its simplicity: it isn't any more complex than the classic sieve of Eratosthenes. Besides, the algorithm given here calculates factorizations of all numbers in the segment $[2; n]$ as a side effect, and that can be helpful in many practical applications. The weakness of the given algorithm is in using more memory than the classic sieve of Eratosthenes': it requires an array of $n$ numbers, while for the classic sieve of Eratosthenes it is enough to have $n$ bits of memory (which is 32 times less). Thus, it makes sense to use the described algorithm only until for numbers of order $10^7$ and not greater. The algorithm is due to Paul Pritchard. It is a variant of Algorithm 3.3 in (Pritchard, 1987: see references in the end of the article).","title":"Linear Sieve"},{"location":"algebra/prime-sieve-linear.html#algorithm","text":"Our goal is to calculate minimum prime factor $lp [i]$ for every number $i$ in the segment $[2; n]$ . Besides, we need to store the list of all the found prime numbers - let's call it $pr []$ . We'll initialize the values $lp [i]$ with zeros, which means that we assume all numbers are prime. During the algorithm execution this array will be filled gradually. Now we'll go through the numbers from 2 to $n$ . We have two cases for the current number $i$ : $lp[i] = 0$ - that means that $i$ is prime, i.e. we haven't found any smaller factors for it. Hence, we assign $lp [i] = i$ and add $i$ to the end of the list $pr[]$ . $lp[i] \\neq 0$ - that means that $i$ is composite, and its minimum prime factor is $lp [i]$ . In both cases we update values of $lp []$ for the numbers that are divisible by $i$ . However, our goal is to learn to do so as to set a value $lp []$ at most once for every number. We can do it as follows: Let's consider numbers $x_j = i \\cdot p_j$ , where $p_j$ are all prime numbers less than or equal to $lp [i]$ (this is why we need to store the list of all prime numbers). We'll set a new value $lp [x_j] = p_j$ for all numbers of this form. The proof of correctness of this algorithm and its runtime can be found after the implementation.","title":"Algorithm"},{"location":"algebra/prime-sieve-linear.html#implementation","text":"const int N = 10000000 ; vector < int > lp ( N + 1 ); vector < int > pr ; for ( int i = 2 ; i <= N ; ++ i ) { if ( lp [ i ] == 0 ) { lp [ i ] = i ; pr . push_back ( i ); } for ( int j = 0 ; i * pr [ j ] <= N ; ++ j ) { lp [ i * pr [ j ]] = pr [ j ]; if ( pr [ j ] == lp [ i ]) { break ; } } }","title":"Implementation"},{"location":"algebra/prime-sieve-linear.html#correctness-proof","text":"We need to prove that the algorithm sets all values $lp []$ correctly, and that every value will be set exactly once. Hence, the algorithm will have linear runtime, since all the remaining actions of the algorithm, obviously, work for $O (n)$ . Notice that every number $i$ has exactly one representation in form: $$i = lp [i] \\cdot x,$$ where $lp [i]$ is the minimal prime factor of $i$ , and the number $x$ doesn't have any prime factors less than $lp [i]$ , i.e. $$lp [i] \\le lp [x].$$ Now, let's compare this with the actions of our algorithm: in fact, for every $x$ it goes through all prime numbers it could be multiplied by, i.e. all prime numbers up to $lp [x]$ inclusive, in order to get the numbers in the form given above. Hence, the algorithm will go through every composite number exactly once, setting the correct values $lp []$ there. Q.E.D.","title":"Correctness Proof"},{"location":"algebra/prime-sieve-linear.html#runtime-and-memory","text":"Although the running time of $O(n)$ is better than $O(n \\log \\log n)$ of the classic sieve of Eratosthenes, the difference between them is not so big. In practice the linear sieve runs about as fast as a typical implementation of the sieve of Eratosthenes. In comparison to optimized versions of the sieve of Erathosthenes, e.g. the segmented sieve, it is much slower. Considering the memory requirements of this algorithm - an array $lp []$ of length $n$ , and an array of $pr []$ of length $\\frac n {\\ln n}$ , this algorithm seems to be worse than the classic sieve in every way. However, its redeeming quality is that this algorithm calculates an array $lp []$ , which allows us to find factorization of any number in the segment $[2; n]$ in the time of the size order of this factorization. Moreover, using just one extra array will allow us to avoid divisions when looking for factorization. Knowing the factorizations of all numbers is very useful for some tasks, and this algorithm is one of the few which allow to find them in linear time.","title":"Runtime and Memory"},{"location":"algebra/prime-sieve-linear.html#references","text":"Paul Pritchard, Linear Prime-Number Sieves: a Family Tree , Science of Computer Programming, vol. 9 (1987), pp.17-35.","title":"References"},{"location":"algebra/primitive-root.html","text":"Primitive Root \u00b6 Definition \u00b6 In modular arithmetic, a number $g$ is called a primitive root modulo n if every number coprime to $n$ is congruent to a power of $g$ modulo $n$ . Mathematically, $g$ is a primitive root modulo n if and only if for any integer $a$ such that $\\gcd(a, n) = 1$ , there exists an integer $k$ such that: $g^k \\equiv a \\pmod n$ . $k$ is then called the index or discrete logarithm of $a$ to the base $g$ modulo $n$ . $g$ is also called the generator of the multiplicative group of integers modulo $n$ . In particular, for the case where $n$ is a prime, the powers of primitive root runs through all numbers from $1$ to $n-1$ . Existence \u00b6 Primitive root modulo $n$ exists if and only if: $n$ is 1, 2, 4, or $n$ is power of an odd prime number $(n = p^k)$ , or $n$ is twice power of an odd prime number $(n = 2 \\cdot p^k)$ . This theorem was proved by Gauss in 1801. Relation with the Euler function \u00b6 Let $g$ be a primitive root modulo $n$ . Then we can show that the smallest number $k$ for which $g^k \\equiv 1 \\pmod n$ is equal $\\phi (n)$ . Moreover, the reverse is also true, and this fact will be used in this article to find a primitive root. Furthermore, the number of primitive roots modulo $n$ , if there are any, is equal to $\\phi (\\phi (n) )$ . Algorithm for finding a primitive root \u00b6 A naive algorithm is to consider all numbers in range $[1, n-1]$ . And then check if each one is a primitive root, by calculating all its power to see if they are all different. This algorithm has complexity $O(g \\cdot n)$ , which would be too slow. In this section, we propose a faster algorithm using several well-known theorems. From previous section, we know that if the smallest number $k$ for which $g^k \\equiv 1 \\pmod n$ is $\\phi (n)$ , then $g$ is a primitive root. Since for any number $a$ relative prime to $n$ , we know from Euler's theorem that $a ^ { \\phi (n) } \\equiv 1 \\pmod n$ , then to check if $g$ is primitive root, it is enough to check that for all $d$ less than $\\phi (n)$ , $g^d \\not \\equiv 1 \\pmod n$ . However, this algorithm is still too slow. From Lagrange's theorem, we know that the index of 1 of any number modulo $n$ must be a divisor of $\\phi (n)$ . Thus, it is sufficient to verify for all proper divisor $d \\mid \\phi (n)$ that $g^d \\not \\equiv 1 \\pmod n$ . This is already a much faster algorithm, but we can still do better. Factorize $\\phi (n) = p_1 ^ {a_1} \\cdots p_s ^ {a_s}$ . We prove that in the previous algorithm, it is sufficient to consider only the values of $d$ which have the form $\\frac { \\phi (n) } {p_j}$ . Indeed, let $d$ be any proper divisor of $\\phi (n)$ . Then, obviously, there exists such $j$ that $d \\mid \\frac { \\phi (n) } {p_j}$ , i.e. $d \\cdot k = \\frac { \\phi (n) } {p_j}$ . However, if $g^d \\equiv 1 \\pmod n$ , we would get: $g ^ { \\frac { \\phi (n)} {p_j} } \\equiv g ^ {d \\cdot k} \\equiv (g^d) ^k \\equiv 1^k \\equiv 1 \\pmod n$ . i.e. among the numbers of the form $\\frac {\\phi (n)} {p_i}$ , there would be at least one such that the conditions were not met. Now we have a complete algorithm for finding the primitive root: First, find $\\phi (n)$ and factorize it. Then iterate through all numbers $g \\in [1, n]$ , and for each number, to check if it is primitive root, we do the following: Calculate all $g ^ { \\frac {\\phi (n)} {p_i}} \\pmod n$ . If all the calculated values are different from $1$ , then $g$ is a primitive root. Running time of this algorithm is $O(Ans \\cdot \\log \\phi (n) \\cdot \\log n)$ (assume that $\\phi (n)$ has $\\log \\phi (n)$ divisors). Shoup (1990, 1992) proved, assuming the generalized Riemann hypothesis , that $g$ is $O(\\log^6 p)$ . Implementation \u00b6 The following code assumes that the modulo p is a prime number. To make it works for any value of p , we must add calculation of $\\phi (p)$ . int powmod ( int a , int b , int p ) { int res = 1 ; while ( b ) if ( b & 1 ) res = int ( res * 1l l * a % p ), -- b ; else a = int ( a * 1l l * a % p ), b >>= 1 ; return res ; } int generator ( int p ) { vector < int > fact ; int phi = p -1 , n = phi ; for ( int i = 2 ; i * i <= n ; ++ i ) if ( n % i == 0 ) { fact . push_back ( i ); while ( n % i == 0 ) n /= i ; } if ( n > 1 ) fact . push_back ( n ); for ( int res = 2 ; res <= p ; ++ res ) { bool ok = true ; for ( size_t i = 0 ; i < fact . size () && ok ; ++ i ) ok &= powmod ( res , phi / fact [ i ], p ) != 1 ; if ( ok ) return res ; } return -1 ; }","title":"Primitive Root"},{"location":"algebra/primitive-root.html#primitive-root","text":"","title":"Primitive Root"},{"location":"algebra/primitive-root.html#definition","text":"In modular arithmetic, a number $g$ is called a primitive root modulo n if every number coprime to $n$ is congruent to a power of $g$ modulo $n$ . Mathematically, $g$ is a primitive root modulo n if and only if for any integer $a$ such that $\\gcd(a, n) = 1$ , there exists an integer $k$ such that: $g^k \\equiv a \\pmod n$ . $k$ is then called the index or discrete logarithm of $a$ to the base $g$ modulo $n$ . $g$ is also called the generator of the multiplicative group of integers modulo $n$ . In particular, for the case where $n$ is a prime, the powers of primitive root runs through all numbers from $1$ to $n-1$ .","title":"Definition"},{"location":"algebra/primitive-root.html#existence","text":"Primitive root modulo $n$ exists if and only if: $n$ is 1, 2, 4, or $n$ is power of an odd prime number $(n = p^k)$ , or $n$ is twice power of an odd prime number $(n = 2 \\cdot p^k)$ . This theorem was proved by Gauss in 1801.","title":"Existence"},{"location":"algebra/primitive-root.html#relation-with-the-euler-function","text":"Let $g$ be a primitive root modulo $n$ . Then we can show that the smallest number $k$ for which $g^k \\equiv 1 \\pmod n$ is equal $\\phi (n)$ . Moreover, the reverse is also true, and this fact will be used in this article to find a primitive root. Furthermore, the number of primitive roots modulo $n$ , if there are any, is equal to $\\phi (\\phi (n) )$ .","title":"Relation with the Euler function"},{"location":"algebra/primitive-root.html#algorithm-for-finding-a-primitive-root","text":"A naive algorithm is to consider all numbers in range $[1, n-1]$ . And then check if each one is a primitive root, by calculating all its power to see if they are all different. This algorithm has complexity $O(g \\cdot n)$ , which would be too slow. In this section, we propose a faster algorithm using several well-known theorems. From previous section, we know that if the smallest number $k$ for which $g^k \\equiv 1 \\pmod n$ is $\\phi (n)$ , then $g$ is a primitive root. Since for any number $a$ relative prime to $n$ , we know from Euler's theorem that $a ^ { \\phi (n) } \\equiv 1 \\pmod n$ , then to check if $g$ is primitive root, it is enough to check that for all $d$ less than $\\phi (n)$ , $g^d \\not \\equiv 1 \\pmod n$ . However, this algorithm is still too slow. From Lagrange's theorem, we know that the index of 1 of any number modulo $n$ must be a divisor of $\\phi (n)$ . Thus, it is sufficient to verify for all proper divisor $d \\mid \\phi (n)$ that $g^d \\not \\equiv 1 \\pmod n$ . This is already a much faster algorithm, but we can still do better. Factorize $\\phi (n) = p_1 ^ {a_1} \\cdots p_s ^ {a_s}$ . We prove that in the previous algorithm, it is sufficient to consider only the values of $d$ which have the form $\\frac { \\phi (n) } {p_j}$ . Indeed, let $d$ be any proper divisor of $\\phi (n)$ . Then, obviously, there exists such $j$ that $d \\mid \\frac { \\phi (n) } {p_j}$ , i.e. $d \\cdot k = \\frac { \\phi (n) } {p_j}$ . However, if $g^d \\equiv 1 \\pmod n$ , we would get: $g ^ { \\frac { \\phi (n)} {p_j} } \\equiv g ^ {d \\cdot k} \\equiv (g^d) ^k \\equiv 1^k \\equiv 1 \\pmod n$ . i.e. among the numbers of the form $\\frac {\\phi (n)} {p_i}$ , there would be at least one such that the conditions were not met. Now we have a complete algorithm for finding the primitive root: First, find $\\phi (n)$ and factorize it. Then iterate through all numbers $g \\in [1, n]$ , and for each number, to check if it is primitive root, we do the following: Calculate all $g ^ { \\frac {\\phi (n)} {p_i}} \\pmod n$ . If all the calculated values are different from $1$ , then $g$ is a primitive root. Running time of this algorithm is $O(Ans \\cdot \\log \\phi (n) \\cdot \\log n)$ (assume that $\\phi (n)$ has $\\log \\phi (n)$ divisors). Shoup (1990, 1992) proved, assuming the generalized Riemann hypothesis , that $g$ is $O(\\log^6 p)$ .","title":"Algorithm for finding a primitive root"},{"location":"algebra/primitive-root.html#implementation","text":"The following code assumes that the modulo p is a prime number. To make it works for any value of p , we must add calculation of $\\phi (p)$ . int powmod ( int a , int b , int p ) { int res = 1 ; while ( b ) if ( b & 1 ) res = int ( res * 1l l * a % p ), -- b ; else a = int ( a * 1l l * a % p ), b >>= 1 ; return res ; } int generator ( int p ) { vector < int > fact ; int phi = p -1 , n = phi ; for ( int i = 2 ; i * i <= n ; ++ i ) if ( n % i == 0 ) { fact . push_back ( i ); while ( n % i == 0 ) n /= i ; } if ( n > 1 ) fact . push_back ( n ); for ( int res = 2 ; res <= p ; ++ res ) { bool ok = true ; for ( size_t i = 0 ; i < fact . size () && ok ; ++ i ) ok &= powmod ( res , phi / fact [ i ], p ) != 1 ; if ( ok ) return res ; } return -1 ; }","title":"Implementation"},{"location":"algebra/sieve-of-eratosthenes.html","text":"Sieve of Eratosthenes \u00b6 Sieve of Eratosthenes is an algorithm for finding all the prime numbers in a segment $[1;n]$ using $O(n \\log \\log n)$ operations. The algorithm is very simple: at the beginning we write down all numbers between 2 and $n$ . We mark all proper multiples of 2 (since 2 is the smallest prime number) as composite. A proper multiple of a number $x$ , is a number greater than $x$ and divisible by $x$ . Then we find the next number that hasn't been marked as composite, in this case it is 3. Which means 3 is prime, and we mark all proper multiples of 3 as composite. The next unmarked number is 5, which is the next prime number, and we mark all proper multiples of it. And we continue this procedure until we have processed all numbers in the row. In the following image you can see a visualization of the algorithm for computing all prime numbers in the range $[1; 16]$ . It can be seen, that quite often we mark numbers as composite multiple times. The idea behind is this: A number is prime, if none of the smaller prime numbers divides it. Since we iterate over the prime numbers in order, we already marked all numbers, which are divisible by at least one of the prime numbers, as divisible. Hence if we reach a cell and it is not marked, then it isn't divisible by any smaller prime number and therefore has to be prime. Implementation \u00b6 int n ; vector < bool > is_prime ( n + 1 , true ); is_prime [ 0 ] = is_prime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) { if ( is_prime [ i ] && ( long long ) i * i <= n ) { for ( int j = i * i ; j <= n ; j += i ) is_prime [ j ] = false ; } } This code first marks all numbers except zero and one as potential prime numbers, then it begins the process of sifting composite numbers. For this it iterates over all numbers from $2$ to $n$ . If the current number $i$ is a prime number, it marks all numbers that are multiples of $i$ as composite numbers, starting from $i^2$ . This is already an optimization over naive way of implementing it, and is allowed as all smaller numbers that are multiples of $i$ necessary also have a prime factor which is less than $i$ , so all of them were already sifted earlier. Since $i^2$ can easily overflow the type int , the additional verification is done using type long long before the second nested loop. Using such implementation the algorithm consumes $O(n)$ of the memory (obviously) and performs $O(n \\log \\log n)$ (see next section). Asymptotic analysis \u00b6 It's simple to prove a running time of $O(n \\log n)$ without knowing anything about the distribution of primes - ignoring the is_prime check, the inner loop runs (at most) $n/i$ times for $i = 2, 3, 4, \\dots$ , leading the total number of operations in the inner loop to be a harmonic sum like $n(1/2 + 1/3 + 1/4 + \\cdots)$ , which is bounded by $O(n \\log n)$ . Let's prove that algorithm's running time is $O(n \\log \\log n)$ . The algorithm will perform $\\frac{n}{p}$ operations for every prime $p \\le n$ in the inner loop. Hence, we need to evaluate the next expression: $$\\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac n p = n \\cdot \\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac 1 p.$$ Let's recall two known facts. The number of prime numbers less than or equal to $n$ is approximately $\\frac n {\\ln n}$ . The $k$ -th prime number approximately equals $k \\ln k$ (this follows from the previous fact). Thus we can write down the sum in the following way: $$\\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac 1 p \\approx \\frac 1 2 + \\sum_{k = 2}^{\\frac n {\\ln n}} \\frac 1 {k \\ln k}.$$ Here we extracted the first prime number 2 from the sum, because $k = 1$ in approximation $k \\ln k$ is $0$ and causes a division by zero. Now, let's evaluate this sum using the integral of a same function over $k$ from $2$ to $\\frac n {\\ln n}$ (we can make such approximation because, in fact, the sum is related to the integral as its approximation using the rectangle method): $$\\sum_{k = 2}^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} \\approx \\int_2^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} dk.$$ The antiderivative for the integrand is $\\ln \\ln k$ . Using a substitution and removing terms of lower order, we'll get the result: $$\\int_2^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} dk = \\ln \\ln \\frac n {\\ln n} - \\ln \\ln 2 = \\ln(\\ln n - \\ln \\ln n) - \\ln \\ln 2 \\approx \\ln \\ln n.$$ Now, returning to the original sum, we'll get its approximate evaluation: $$\\sum_{\\substack{p \\le n, \\\\\\ p\\ is\\ prime}} \\frac n p \\approx n \\ln \\ln n + o(n).$$ You can find a more strict proof (that gives more precise evaluation which is accurate within constant multipliers) in the book authored by Hardy & Wright \"An Introduction to the Theory of Numbers\" (p. 349). Different optimizations of the Sieve of Eratosthenes \u00b6 The biggest weakness of the algorithm is, that it \"walks\" along the memory multiple times, only manipulating single elements. This is not very cache friendly. And because of that, the constant which is concealed in $O(n \\log \\log n)$ is comparably big. Besides, the consumed memory is a bottleneck for big $n$ . The methods presented below allow us to reduce the quantity of the performed operations, as well as to shorten the consumed memory noticeably. Sieving till root \u00b6 Obviously, to find all the prime numbers until $n$ , it will be enough just to perform the sifting only by the prime numbers, which do not exceed the root of $n$ . int n ; vector < bool > is_prime ( n + 1 , true ); is_prime [ 0 ] = is_prime [ 1 ] = false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( is_prime [ i ]) { for ( int j = i * i ; j <= n ; j += i ) is_prime [ j ] = false ; } } Such optimization doesn't affect the complexity (indeed, by repeating the proof presented above we'll get the evaluation $n \\ln \\ln \\sqrt n + o(n)$ , which is asymptotically the same according to the properties of logarithms), though the number of operations will reduce noticeably. Sieving by the odd numbers only \u00b6 Since all even numbers (except $2$ ) are composite, we can stop checking even numbers at all. Instead, we need to operate with odd numbers only. First, it will allow us to halve the needed memory. Second, it will reduce the number of operations performed by algorithm approximately in half. Memory consumption and speed of operations \u00b6 We should notice, that these two implementations of the Sieve of Eratosthenes use $n$ bits of memory by using the data structure vector<bool> . vector<bool> is not a regular container that stores a series of bool (as in most computer architectures a bool takes one byte of memory). It's a memory-optimization specialization of vector<T> , that only consumes $\\frac{N}{8}$ bytes of memory. Modern processors architectures work much more efficiently with bytes than with bits as they usually cannot access bits directly. So underneath the vector<bool> stores the bits in a large continuous memory, accesses the memory in blocks of a few bytes, and extracts/sets the bits with bit operations like bit masking and bit shifting. Because of that there is a certain overhead when you read or write bits with a vector<bool> , and quite often using a vector<char> (which uses 1 byte for each entry, so 8x the amount of memory) is faster. However, for the simple implementations of the Sieve of Eratosthenes using a vector<bool> is faster. You are limited by how fast you can load the data into the cache, and therefore using less memory gives a big advantage. A benchmark ( link ) shows, that using a vector<bool> is between 1.4x and 1.7x faster than using a vector<char> . The same considerations also apply to bitset . It's also an efficient way of storing bits, similar to vector<bool> , so it takes only $\\frac{N}{8}$ bytes of memory, but is a bit slower in accessing the elements. In the benchmark above bitset performs a bit worse than vector<bool> . Another drawback from bitset is that you need to know the size at compile time. Segmented Sieve \u00b6 It follows from the optimization \"sieving till root\" that there is no need to keep the whole array is_prime[1...n] at all times. For sieving it is enough to just keep the prime numbers until the root of $n$ , i.e. prime[1... sqrt(n)] , split the complete range into blocks, and sieve each block separately. Let $s$ be a constant which determines the size of the block, then we have $\\lceil {\\frac n s} \\rceil$ blocks altogether, and the block $k$ ( $k = 0 ... \\lfloor {\\frac n s} \\rfloor$ ) contains the numbers in a segment $[ks; ks + s - 1]$ . We can work on blocks by turns, i.e. for every block $k$ we will go through all the prime numbers (from $1$ to $\\sqrt n$ ) and perform sieving using them. It is worth noting, that we have to modify the strategy a little bit when handling the first numbers: first, all the prime numbers from $[1; \\sqrt n]$ shouldn't remove themselves; and second, the numbers $0$ and $1$ should be marked as non-prime numbers. While working on the last block it should not be forgotten that the last needed number $n$ is not necessarily located at the end of the block. As discussed previously, the typical implementation of the Sieve of Eratosthenes is limited by the speed how fast you can load data into the CPU caches. By splitting the range of potential prime numbers $[1; n]$ into smaller blocks, we never have to keep multiple blocks in memory at the same time, and all operations are much more cache-friendlier. As we are now no longer limited by the cache speeds, we can replace the vector<bool> with a vector<char> , and gain some additional performance as the processors can handle read and writes with bytes directly and don't need to rely on bit operations for extracting individual bits. The benchmark ( link ) shows, that using a vector<char> is about 3x faster in this situation than using a vector<bool> . A word of caution: those numbers might differ depending on architecture, compiler, and optimization levels. Here we have an implementation that counts the number of primes smaller than or equal to $n$ using block sieving. int count_primes ( int n ) { const int S = 10000 ; vector < int > primes ; int nsqrt = sqrt ( n ); vector < char > is_prime ( nsqrt + 2 , true ); for ( int i = 2 ; i <= nsqrt ; i ++ ) { if ( is_prime [ i ]) { primes . push_back ( i ); for ( int j = i * i ; j <= nsqrt ; j += i ) is_prime [ j ] = false ; } } int result = 0 ; vector < char > block ( S ); for ( int k = 0 ; k * S <= n ; k ++ ) { fill ( block . begin (), block . end (), true ); int start = k * S ; for ( int p : primes ) { int start_idx = ( start + p - 1 ) / p ; int j = max ( start_idx , p ) * p - start ; for (; j < S ; j += p ) block [ j ] = false ; } if ( k == 0 ) block [ 0 ] = block [ 1 ] = false ; for ( int i = 0 ; i < S && start + i <= n ; i ++ ) { if ( block [ i ]) result ++ ; } } return result ; } The running time of block sieving is the same as for regular sieve of Eratosthenes (unless the size of the blocks is very small), but the needed memory will shorten to $O(\\sqrt{n} + S)$ and we have better caching results. On the other hand, there will be a division for each pair of a block and prime number from $[1; \\sqrt{n}]$ , and that will be far worse for smaller block sizes. Hence, it is necessary to keep balance when selecting the constant $S$ . We achieved the best results for block sizes between $10^4$ and $10^5$ . Find primes in range \u00b6 Sometimes we need to find all prime numbers in a range $[L,R]$ of small size (e.g. $R - L + 1 \\approx 1e7$ ), where $R$ can be very large (e.g. $1e12$ ). To solve such a problem, we can use the idea of the Segmented sieve. We pre-generate all prime numbers up to $\\sqrt R$ , and use those primes to mark all composite numbers in the segment $[L, R]$ . vector < char > segmentedSieve ( long long L , long long R ) { // generate all primes up to sqrt(R) long long lim = sqrt ( R ); vector < char > mark ( lim + 1 , false ); vector < long long > primes ; for ( long long i = 2 ; i <= lim ; ++ i ) { if ( ! mark [ i ]) { primes . emplace_back ( i ); for ( long long j = i * i ; j <= lim ; j += i ) mark [ j ] = true ; } } vector < char > isPrime ( R - L + 1 , true ); for ( long long i : primes ) for ( long long j = max ( i * i , ( L + i - 1 ) / i * i ); j <= R ; j += i ) isPrime [ j - L ] = false ; if ( L == 1 ) isPrime [ 0 ] = false ; return isPrime ; } Time complexity of this approach is $O((R - L + 1) \\log \\log (R) + \\sqrt R \\log \\log \\sqrt R)$ . It's also possible that we don't pre-generate all prime numbers: vector < char > segmentedSieveNoPreGen ( long long L , long long R ) { vector < char > isPrime ( R - L + 1 , true ); long long lim = sqrt ( R ); for ( long long i = 2 ; i <= lim ; ++ i ) for ( long long j = max ( i * i , ( L + i - 1 ) / i * i ); j <= R ; j += i ) isPrime [ j - L ] = false ; if ( L == 1 ) isPrime [ 0 ] = false ; return isPrime ; } Obviously, the complexity is worse, which is $O((R - L + 1) \\log (R) + \\sqrt R)$ . However, it still runs very fast in practice. Linear time modification \u00b6 We can modify the algorithm in a such a way, that it only has linear time complexity. This approach is described in the article Linear Sieve . However, this algorithm also has its own weaknesses. Practice Problems \u00b6 Leetcode - Four Divisors Leetcode - Count Primes SPOJ - Printing Some Primes SPOJ - A Conjecture of Paul Erdos SPOJ - Primal Fear SPOJ - Primes Triangle (I) Codeforces - Almost Prime Codeforces - Sherlock And His Girlfriend SPOJ - Namit in Trouble SPOJ - Bazinga! Project Euler - Prime pair connection SPOJ - N-Factorful SPOJ - Binary Sequence of Prime Numbers UVA 11353 - A Different Kind of Sorting SPOJ - Prime Generator SPOJ - Printing some primes (hard) Codeforces - Nodbach Problem Codeforces - Colliders","title":"Sieve of Eratosthenes"},{"location":"algebra/sieve-of-eratosthenes.html#sieve-of-eratosthenes","text":"Sieve of Eratosthenes is an algorithm for finding all the prime numbers in a segment $[1;n]$ using $O(n \\log \\log n)$ operations. The algorithm is very simple: at the beginning we write down all numbers between 2 and $n$ . We mark all proper multiples of 2 (since 2 is the smallest prime number) as composite. A proper multiple of a number $x$ , is a number greater than $x$ and divisible by $x$ . Then we find the next number that hasn't been marked as composite, in this case it is 3. Which means 3 is prime, and we mark all proper multiples of 3 as composite. The next unmarked number is 5, which is the next prime number, and we mark all proper multiples of it. And we continue this procedure until we have processed all numbers in the row. In the following image you can see a visualization of the algorithm for computing all prime numbers in the range $[1; 16]$ . It can be seen, that quite often we mark numbers as composite multiple times. The idea behind is this: A number is prime, if none of the smaller prime numbers divides it. Since we iterate over the prime numbers in order, we already marked all numbers, which are divisible by at least one of the prime numbers, as divisible. Hence if we reach a cell and it is not marked, then it isn't divisible by any smaller prime number and therefore has to be prime.","title":"Sieve of Eratosthenes"},{"location":"algebra/sieve-of-eratosthenes.html#implementation","text":"int n ; vector < bool > is_prime ( n + 1 , true ); is_prime [ 0 ] = is_prime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) { if ( is_prime [ i ] && ( long long ) i * i <= n ) { for ( int j = i * i ; j <= n ; j += i ) is_prime [ j ] = false ; } } This code first marks all numbers except zero and one as potential prime numbers, then it begins the process of sifting composite numbers. For this it iterates over all numbers from $2$ to $n$ . If the current number $i$ is a prime number, it marks all numbers that are multiples of $i$ as composite numbers, starting from $i^2$ . This is already an optimization over naive way of implementing it, and is allowed as all smaller numbers that are multiples of $i$ necessary also have a prime factor which is less than $i$ , so all of them were already sifted earlier. Since $i^2$ can easily overflow the type int , the additional verification is done using type long long before the second nested loop. Using such implementation the algorithm consumes $O(n)$ of the memory (obviously) and performs $O(n \\log \\log n)$ (see next section).","title":"Implementation"},{"location":"algebra/sieve-of-eratosthenes.html#asymptotic-analysis","text":"It's simple to prove a running time of $O(n \\log n)$ without knowing anything about the distribution of primes - ignoring the is_prime check, the inner loop runs (at most) $n/i$ times for $i = 2, 3, 4, \\dots$ , leading the total number of operations in the inner loop to be a harmonic sum like $n(1/2 + 1/3 + 1/4 + \\cdots)$ , which is bounded by $O(n \\log n)$ . Let's prove that algorithm's running time is $O(n \\log \\log n)$ . The algorithm will perform $\\frac{n}{p}$ operations for every prime $p \\le n$ in the inner loop. Hence, we need to evaluate the next expression: $$\\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac n p = n \\cdot \\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac 1 p.$$ Let's recall two known facts. The number of prime numbers less than or equal to $n$ is approximately $\\frac n {\\ln n}$ . The $k$ -th prime number approximately equals $k \\ln k$ (this follows from the previous fact). Thus we can write down the sum in the following way: $$\\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac 1 p \\approx \\frac 1 2 + \\sum_{k = 2}^{\\frac n {\\ln n}} \\frac 1 {k \\ln k}.$$ Here we extracted the first prime number 2 from the sum, because $k = 1$ in approximation $k \\ln k$ is $0$ and causes a division by zero. Now, let's evaluate this sum using the integral of a same function over $k$ from $2$ to $\\frac n {\\ln n}$ (we can make such approximation because, in fact, the sum is related to the integral as its approximation using the rectangle method): $$\\sum_{k = 2}^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} \\approx \\int_2^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} dk.$$ The antiderivative for the integrand is $\\ln \\ln k$ . Using a substitution and removing terms of lower order, we'll get the result: $$\\int_2^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} dk = \\ln \\ln \\frac n {\\ln n} - \\ln \\ln 2 = \\ln(\\ln n - \\ln \\ln n) - \\ln \\ln 2 \\approx \\ln \\ln n.$$ Now, returning to the original sum, we'll get its approximate evaluation: $$\\sum_{\\substack{p \\le n, \\\\\\ p\\ is\\ prime}} \\frac n p \\approx n \\ln \\ln n + o(n).$$ You can find a more strict proof (that gives more precise evaluation which is accurate within constant multipliers) in the book authored by Hardy & Wright \"An Introduction to the Theory of Numbers\" (p. 349).","title":"Asymptotic analysis"},{"location":"algebra/sieve-of-eratosthenes.html#different-optimizations-of-the-sieve-of-eratosthenes","text":"The biggest weakness of the algorithm is, that it \"walks\" along the memory multiple times, only manipulating single elements. This is not very cache friendly. And because of that, the constant which is concealed in $O(n \\log \\log n)$ is comparably big. Besides, the consumed memory is a bottleneck for big $n$ . The methods presented below allow us to reduce the quantity of the performed operations, as well as to shorten the consumed memory noticeably.","title":"Different optimizations of the Sieve of Eratosthenes"},{"location":"algebra/sieve-of-eratosthenes.html#sieving-till-root","text":"Obviously, to find all the prime numbers until $n$ , it will be enough just to perform the sifting only by the prime numbers, which do not exceed the root of $n$ . int n ; vector < bool > is_prime ( n + 1 , true ); is_prime [ 0 ] = is_prime [ 1 ] = false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( is_prime [ i ]) { for ( int j = i * i ; j <= n ; j += i ) is_prime [ j ] = false ; } } Such optimization doesn't affect the complexity (indeed, by repeating the proof presented above we'll get the evaluation $n \\ln \\ln \\sqrt n + o(n)$ , which is asymptotically the same according to the properties of logarithms), though the number of operations will reduce noticeably.","title":"Sieving till root"},{"location":"algebra/sieve-of-eratosthenes.html#sieving-by-the-odd-numbers-only","text":"Since all even numbers (except $2$ ) are composite, we can stop checking even numbers at all. Instead, we need to operate with odd numbers only. First, it will allow us to halve the needed memory. Second, it will reduce the number of operations performed by algorithm approximately in half.","title":"Sieving by the odd numbers only"},{"location":"algebra/sieve-of-eratosthenes.html#memory-consumption-and-speed-of-operations","text":"We should notice, that these two implementations of the Sieve of Eratosthenes use $n$ bits of memory by using the data structure vector<bool> . vector<bool> is not a regular container that stores a series of bool (as in most computer architectures a bool takes one byte of memory). It's a memory-optimization specialization of vector<T> , that only consumes $\\frac{N}{8}$ bytes of memory. Modern processors architectures work much more efficiently with bytes than with bits as they usually cannot access bits directly. So underneath the vector<bool> stores the bits in a large continuous memory, accesses the memory in blocks of a few bytes, and extracts/sets the bits with bit operations like bit masking and bit shifting. Because of that there is a certain overhead when you read or write bits with a vector<bool> , and quite often using a vector<char> (which uses 1 byte for each entry, so 8x the amount of memory) is faster. However, for the simple implementations of the Sieve of Eratosthenes using a vector<bool> is faster. You are limited by how fast you can load the data into the cache, and therefore using less memory gives a big advantage. A benchmark ( link ) shows, that using a vector<bool> is between 1.4x and 1.7x faster than using a vector<char> . The same considerations also apply to bitset . It's also an efficient way of storing bits, similar to vector<bool> , so it takes only $\\frac{N}{8}$ bytes of memory, but is a bit slower in accessing the elements. In the benchmark above bitset performs a bit worse than vector<bool> . Another drawback from bitset is that you need to know the size at compile time.","title":"Memory consumption and speed of operations"},{"location":"algebra/sieve-of-eratosthenes.html#segmented-sieve","text":"It follows from the optimization \"sieving till root\" that there is no need to keep the whole array is_prime[1...n] at all times. For sieving it is enough to just keep the prime numbers until the root of $n$ , i.e. prime[1... sqrt(n)] , split the complete range into blocks, and sieve each block separately. Let $s$ be a constant which determines the size of the block, then we have $\\lceil {\\frac n s} \\rceil$ blocks altogether, and the block $k$ ( $k = 0 ... \\lfloor {\\frac n s} \\rfloor$ ) contains the numbers in a segment $[ks; ks + s - 1]$ . We can work on blocks by turns, i.e. for every block $k$ we will go through all the prime numbers (from $1$ to $\\sqrt n$ ) and perform sieving using them. It is worth noting, that we have to modify the strategy a little bit when handling the first numbers: first, all the prime numbers from $[1; \\sqrt n]$ shouldn't remove themselves; and second, the numbers $0$ and $1$ should be marked as non-prime numbers. While working on the last block it should not be forgotten that the last needed number $n$ is not necessarily located at the end of the block. As discussed previously, the typical implementation of the Sieve of Eratosthenes is limited by the speed how fast you can load data into the CPU caches. By splitting the range of potential prime numbers $[1; n]$ into smaller blocks, we never have to keep multiple blocks in memory at the same time, and all operations are much more cache-friendlier. As we are now no longer limited by the cache speeds, we can replace the vector<bool> with a vector<char> , and gain some additional performance as the processors can handle read and writes with bytes directly and don't need to rely on bit operations for extracting individual bits. The benchmark ( link ) shows, that using a vector<char> is about 3x faster in this situation than using a vector<bool> . A word of caution: those numbers might differ depending on architecture, compiler, and optimization levels. Here we have an implementation that counts the number of primes smaller than or equal to $n$ using block sieving. int count_primes ( int n ) { const int S = 10000 ; vector < int > primes ; int nsqrt = sqrt ( n ); vector < char > is_prime ( nsqrt + 2 , true ); for ( int i = 2 ; i <= nsqrt ; i ++ ) { if ( is_prime [ i ]) { primes . push_back ( i ); for ( int j = i * i ; j <= nsqrt ; j += i ) is_prime [ j ] = false ; } } int result = 0 ; vector < char > block ( S ); for ( int k = 0 ; k * S <= n ; k ++ ) { fill ( block . begin (), block . end (), true ); int start = k * S ; for ( int p : primes ) { int start_idx = ( start + p - 1 ) / p ; int j = max ( start_idx , p ) * p - start ; for (; j < S ; j += p ) block [ j ] = false ; } if ( k == 0 ) block [ 0 ] = block [ 1 ] = false ; for ( int i = 0 ; i < S && start + i <= n ; i ++ ) { if ( block [ i ]) result ++ ; } } return result ; } The running time of block sieving is the same as for regular sieve of Eratosthenes (unless the size of the blocks is very small), but the needed memory will shorten to $O(\\sqrt{n} + S)$ and we have better caching results. On the other hand, there will be a division for each pair of a block and prime number from $[1; \\sqrt{n}]$ , and that will be far worse for smaller block sizes. Hence, it is necessary to keep balance when selecting the constant $S$ . We achieved the best results for block sizes between $10^4$ and $10^5$ .","title":"Segmented Sieve"},{"location":"algebra/sieve-of-eratosthenes.html#find-primes-in-range","text":"Sometimes we need to find all prime numbers in a range $[L,R]$ of small size (e.g. $R - L + 1 \\approx 1e7$ ), where $R$ can be very large (e.g. $1e12$ ). To solve such a problem, we can use the idea of the Segmented sieve. We pre-generate all prime numbers up to $\\sqrt R$ , and use those primes to mark all composite numbers in the segment $[L, R]$ . vector < char > segmentedSieve ( long long L , long long R ) { // generate all primes up to sqrt(R) long long lim = sqrt ( R ); vector < char > mark ( lim + 1 , false ); vector < long long > primes ; for ( long long i = 2 ; i <= lim ; ++ i ) { if ( ! mark [ i ]) { primes . emplace_back ( i ); for ( long long j = i * i ; j <= lim ; j += i ) mark [ j ] = true ; } } vector < char > isPrime ( R - L + 1 , true ); for ( long long i : primes ) for ( long long j = max ( i * i , ( L + i - 1 ) / i * i ); j <= R ; j += i ) isPrime [ j - L ] = false ; if ( L == 1 ) isPrime [ 0 ] = false ; return isPrime ; } Time complexity of this approach is $O((R - L + 1) \\log \\log (R) + \\sqrt R \\log \\log \\sqrt R)$ . It's also possible that we don't pre-generate all prime numbers: vector < char > segmentedSieveNoPreGen ( long long L , long long R ) { vector < char > isPrime ( R - L + 1 , true ); long long lim = sqrt ( R ); for ( long long i = 2 ; i <= lim ; ++ i ) for ( long long j = max ( i * i , ( L + i - 1 ) / i * i ); j <= R ; j += i ) isPrime [ j - L ] = false ; if ( L == 1 ) isPrime [ 0 ] = false ; return isPrime ; } Obviously, the complexity is worse, which is $O((R - L + 1) \\log (R) + \\sqrt R)$ . However, it still runs very fast in practice.","title":"Find primes in range"},{"location":"algebra/sieve-of-eratosthenes.html#linear-time-modification","text":"We can modify the algorithm in a such a way, that it only has linear time complexity. This approach is described in the article Linear Sieve . However, this algorithm also has its own weaknesses.","title":"Linear time modification"},{"location":"algebra/sieve-of-eratosthenes.html#practice-problems","text":"Leetcode - Four Divisors Leetcode - Count Primes SPOJ - Printing Some Primes SPOJ - A Conjecture of Paul Erdos SPOJ - Primal Fear SPOJ - Primes Triangle (I) Codeforces - Almost Prime Codeforces - Sherlock And His Girlfriend SPOJ - Namit in Trouble SPOJ - Bazinga! Project Euler - Prime pair connection SPOJ - N-Factorful SPOJ - Binary Sequence of Prime Numbers UVA 11353 - A Different Kind of Sorting SPOJ - Prime Generator SPOJ - Printing some primes (hard) Codeforces - Nodbach Problem Codeforces - Colliders","title":"Practice Problems"},{"location":"intro/about.html","text":"\u5173\u4e8e\u672c\u9879\u76ee \u00b6 OI Wiki \u81f4\u529b\u4e8e\u6210\u4e3a\u4e00\u4e2a\u514d\u8d39\u5f00\u653e\u4e14\u6301\u7eed\u66f4\u65b0\u7684 \u7f16\u7a0b\u7ade\u8d5b (competitive programming) \u77e5\u8bc6\u6574\u5408\u7ad9\u70b9\u3002 \u4ea4\u6d41\u65b9\u5f0f \u00b6 \u672c\u9879\u76ee\u4e3b\u8981\u4f7f\u7528 Issues / QQ / Telegram \u8fdb\u884c\u4ea4\u6d41\u6c9f\u901a\u3002 Telegram \u7fa4\u7ec4\u94fe\u63a5\u4e3a @OI_wiki \uff0cQQ \u7fa4\u53f7\u7801\u4e3a 588793226 \uff0c\u6b22\u8fce\u52a0\u5165\u3002 Note \u539f\u5219\u4e0a\u6765\u8bf4\uff0c\u4e0a\u8ff0\u7fa4\u7ec4\u662f OI Wiki \u8ba8\u8bba\u7fa4 \uff0c\u6240\u4ee5\u8bf7\u5c3d\u91cf\u4e0d\u8981\u5728\u7fa4\u7ec4\u4e2d\u53d1\u8868\u8fc7\u591a\u4e0e OI Wiki \u65e0\u5173\u7684\u5185\u5bb9\u3002 \u9879\u76ee\u65b9\u9488 \u00b6 OI Wiki \u4e0d\u662f\u4ec0\u4e48","title":"About"},{"location":"intro/about.html#_1","text":"OI Wiki \u81f4\u529b\u4e8e\u6210\u4e3a\u4e00\u4e2a\u514d\u8d39\u5f00\u653e\u4e14\u6301\u7eed\u66f4\u65b0\u7684 \u7f16\u7a0b\u7ade\u8d5b (competitive programming) \u77e5\u8bc6\u6574\u5408\u7ad9\u70b9\u3002","title":"\u5173\u4e8e\u672c\u9879\u76ee"},{"location":"intro/about.html#_2","text":"\u672c\u9879\u76ee\u4e3b\u8981\u4f7f\u7528 Issues / QQ / Telegram \u8fdb\u884c\u4ea4\u6d41\u6c9f\u901a\u3002 Telegram \u7fa4\u7ec4\u94fe\u63a5\u4e3a @OI_wiki \uff0cQQ \u7fa4\u53f7\u7801\u4e3a 588793226 \uff0c\u6b22\u8fce\u52a0\u5165\u3002 Note \u539f\u5219\u4e0a\u6765\u8bf4\uff0c\u4e0a\u8ff0\u7fa4\u7ec4\u662f OI Wiki \u8ba8\u8bba\u7fa4 \uff0c\u6240\u4ee5\u8bf7\u5c3d\u91cf\u4e0d\u8981\u5728\u7fa4\u7ec4\u4e2d\u53d1\u8868\u8fc7\u591a\u4e0e OI Wiki \u65e0\u5173\u7684\u5185\u5bb9\u3002","title":"\u4ea4\u6d41\u65b9\u5f0f"},{"location":"intro/about.html#_3","text":"OI Wiki \u4e0d\u662f\u4ec0\u4e48","title":"\u9879\u76ee\u65b9\u9488"},{"location":"intro/docker-deploy.html","text":"\u672c\u9875\u9762\u5c06\u4ecb\u7ecd\u4f7f\u7528 Docker \u90e8\u7f72 OI Wiki \u73af\u5883\u7684\u65b9\u5f0f\u3002 Warning \u4ee5\u4e0b\u6b65\u9aa4\u987b\u5728 root \u7528\u6237\u4e0b\u6216 docker \u7ec4\u7528\u6237\u4e0b\u6267\u884c\u3002 \u62c9\u53d6 OI Wiki \u955c\u50cf \u00b6 # \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c\u5176\u4e2d\u4e00\u4e2a\u5373\u53ef # Docker Hub \u955c\u50cf\uff08\u5b98\u65b9\u955c\u50cf\u4ed3\u5e93\uff09 docker pull 24oi/oi-wiki # DaoCloud Hub \u955c\u50cf\uff08\u56fd\u5185\u955c\u50cf\u4ed3\u5e93\uff09 docker pull daocloud.io/sirius/oi-wiki # Tencent Hub \u955c\u50cf\uff08\u56fd\u5185\u955c\u50cf\u4ed3\u5e93\uff09 docker pull ccr.ccs.tencentyun.com/oi-wiki/oi-wiki \u81ea\u884c\u6784\u5efa\u955c\u50cf \u00b6 # \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c # \u514b\u9686 Git \u4ed3\u5e93 git clone https://github.com/OI-wiki/OI-wiki.git cd OI-wiki/ # \u6784\u5efa\u955c\u50cf docker build -t [ name ][ :tag ] . --build-arg [ variable1 ]=[ value1 ] [ variable2 ]=[ value2 ] ... \uff08\u5fc5\u987b\uff09\u8bbe\u7f6e [name] \u4ee5\u8bbe\u7f6e\u955c\u50cf\u540d\uff0c\uff08\u53ef\u9009\uff09\u8bbe\u7f6e [tag] \u4ee5\u8bbe\u7f6e\u955c\u50cf\u6807\u7b7e\uff08\u82e5\u8bbe\u7f6e\uff0c\u5219\u8fd0\u884c\u65f6\u955c\u50cf\u540d\u7531\u4e24\u90e8\u5206\u6784\u6210\uff09\u3002 \u53ef\u4ee5\u901a\u8fc7 --build-arg \u53c2\u6570\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u3002 \u53ef\u4ee5\u4f7f\u7528\u7684\u73af\u5883\u53d8\u91cf\uff1a \u53ef\u4ee5\u8bbe\u7f6e WIKI_REPO \u6765\u4f7f\u7528 Wiki \u4ed3\u5e93\u7684\u955c\u50cf\u7ad9\u70b9\uff08\u5f53\u672a\u8bbe\u7f6e\u65f6\u81ea\u52a8\u4f7f\u7528 GitHub\uff09 \u53ef\u4ee5\u8bbe\u7f6e PYPI_MIRROR \u6765\u4f7f\u7528 PyPI \u4ed3\u5e93\u7684\u955c\u50cf\u7ad9\u70b9\uff08\u5f53\u672a\u8bbe\u7f6e\u65f6\u81ea\u52a8\u4f7f\u7528\u5b98\u65b9 PyPI\uff09 \u5728\u56fd\u5185\u5efa\u8bae\u4f7f\u7528 TUNA \u955c\u50cf\u7ad9 https://pypi.tuna.tsinghua.edu.cn/simple/ \u53ef\u4ee5\u8bbe\u7f6e LISTEN_IP \u6765\u66f4\u6539\u76d1\u542c IP\uff08\u5f53\u672a\u8bbe\u7f6e\u65f6\u4e3a 0.0.0.0 \uff0c\u5373\u76d1\u542c\u6240\u6709 IP \u7684\u8bbf\u95ee\uff09 \u53ef\u4ee5\u8bbe\u7f6e LISTEN_PORT \u6765\u66f4\u6539\u76d1\u542c\u7aef\u53e3\uff08\u5f53\u672a\u8bbe\u7f6e\u65f6\u4e3a 8000 \uff09 \u793a\u4f8b\uff1a docker build -t OI_Wiki . --build-arg WIKI_REPO = https://hub.fastgit.xyz/OI-wiki/OI-wiki.git PYPI_MIRROR = https://pypi.tuna.tsinghua.edu.cn/simple/ # \u6784\u5efa\u4e00\u4e2a\u540d\u4e3a OI_Wiki \uff08\u6807\u7b7e\u9ed8\u8ba4\uff09\u7684\u955c\u50cf\uff0c\u4f7f\u7528 FastGit \u670d\u52a1\u52a0\u901f\u514b\u9686\uff0c\u4f7f\u7528 TUNA \u955c\u50cf\u7ad9\u3002 \u8fd0\u884c\u5bb9\u5668 \u00b6 # \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c docker run -d -it [ image ] \uff08\u5fc5\u987b\uff09\u8bbe\u7f6e [image] \u4ee5\u8bbe\u7f6e\u955c\u50cf\u3002\u4f8b\u5982\uff0c\u4ece Docker Hub \u62c9\u53d6\u7684\u4e3a 24oi/oi-wiki \uff1bDaoCloud Hub \u62c9\u53d6\u7684\u5219\u4e3a daocloud.io/sirius/oi-wiki \u3002 \uff08\u5fc5\u987b\uff09\u8bbe\u7f6e -p [port]:8000 \u4ee5\u6620\u5c04\u5bb9\u5668\u7aef\u53e3\u81f3\u4e3b\u673a\u7aef\u53e3\uff08\u4e0d\u5199\u8be5\u8bed\u53e5\u5219\u9ed8\u8ba4\u4e3a\u4e0d\u66b4\u9732\u7aef\u53e3\u3002\u8bbe\u7f6e\u65f6\u8bf7\u66ff\u6362 [port] \u4e3a\u4e3b\u673a\u7aef\u53e3\uff09\u3002\u8bbe\u7f6e\u540e\u53ef\u4ee5\u5728\u4e3b\u673a\u4f7f\u7528 http://127.0.0.1:[port] \u8bbf\u95ee OI Wiki \u3002 \u8bbe\u7f6e --name [name] \u4ee5\u8bbe\u7f6e\u5bb9\u5668\u540d\u5b57\u3002\uff08\u9ed8\u8ba4\u7a7a\u3002\u8bbe\u7f6e\u65f6\u8bf7\u66ff\u6362 [name] \u4e3a\u81ea\u5b9a\u4e49\u7684\u5bb9\u5668\u540d\u5b57\u3002\u82e5\u60f3\u67e5\u770b\u5bb9\u5668 id\uff0c\u5219\u8f93\u5165 docker ps \uff09 \u4f7f\u7528\u5bb9\u5668 \u00b6 Note \u793a\u4f8b\u57fa\u4e8e Ubuntu latest \u90e8\u7f72\u3002 \u8fdb\u5165\u5bb9\u5668\uff1a # \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c docker exec -it [ name ] /bin/bash \u82e5\u5728\u4e0a\u8ff0\u8fd0\u884c\u5bb9\u5668\u4e2d\u53bb\u6389 -d \uff0c\u5219\u53ef\u4ee5\u76f4\u63a5\u8fdb\u5165\u5bb9\u5668 bash\uff0c\u9000\u51fa\u540e\u5bb9\u5668\u505c\u6b62\uff0c\u52a0\u4e0a -d \u5219\u540e\u53f0\u8fd0\u884c\uff0c\u8bf7\u624b\u52a8\u505c\u6b62\u3002\u4e0a\u8ff0\u8fdb\u5165\u5bb9\u5668\u9488\u5bf9\u52a0\u4e0a -d \u7684\u65b9\u6cd5\u8fd0\u884c\u3002 \u7279\u6b8a\u7528\u6cd5\uff1a # \u4ee5\u4e0b\u547d\u4ee4\u5728\u5bb9\u5668\u4e2d\u8fd0\u884c # \u66f4\u65b0 git \u4ed3\u5e93 wiki-upd # \u4f7f\u7528\u6211\u4eec\u7684\u81ea\u5b9a\u4e49\u4e3b\u9898 wiki-theme # \u6784\u5efa mkdocs \uff0c\u4f1a\u5728 site \u6587\u4ef6\u5939\u4e0b\u5f97\u5230\u9759\u6001\u9875\u9762 wiki-bld # \u6784\u5efa mkdocs \u5e76\u6e32\u67d3 MathJax \uff0c\u4f1a\u5728 site \u6587\u4ef6\u5939\u4e0b\u5f97\u5230\u9759\u6001\u9875\u9762 wiki-bld-math # \u8fd0\u884c\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u8bbf\u95ee\u5bb9\u5668\u4e2d http://127.0.0.1:8000 \u6216\u8bbf\u95ee\u4e3b\u673a\u4e2d http://127.0.0.1:[port] \u53ef\u4ee5\u67e5\u770b\u6548\u679c wiki-svr # \u4fee\u6b63 Markdown wiki-o \u9000\u51fa\u5bb9\u5668\uff1a # \u4ee5\u4e0b\u547d\u4ee4\u5728\u5bb9\u5668\u4e2d\u8fd0\u884c # \u9000\u51fa exit \u505c\u6b62\u5bb9\u5668 \u00b6 # \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c docker stop [ name ] \u542f\u52a8\u5bb9\u5668 \u00b6 # \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c docker start [ name ] \u91cd\u542f\u5bb9\u5668 \u00b6 # \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c docker restart [ name ] \u5220\u9664\u5bb9\u5668 \u00b6 # \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c # \u5220\u9664\u524d\u8bf7\u5148\u505c\u6b62\u5bb9\u5668 docker rm [ name ] \u66f4\u65b0\u955c\u50cf \u00b6 \u91cd\u65b0\u518d pull \u4e00\u6b21\u5373\u53ef\uff0c\u901a\u5e38\u4e0d\u4f1a\u66f4\u65b0\u3002 \u5220\u9664\u955c\u50cf \u00b6 # \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c # \u5220\u9664\u524d\u8bf7\u5148\u5220\u9664\u4f7f\u7528 oi-wiki \u955c\u50cf\u6784\u5efa\u7684\u5bb9\u5668 docker rmi [ image ] \u7591\u95ee \u00b6 \u5982\u679c\u60a8\u6709\u7591\u95ee\uff0c\u6b22\u8fce\u63d0\u51fa issue \uff01","title":"Docker deploy"},{"location":"intro/docker-deploy.html#oi-wiki","text":"# \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c\u5176\u4e2d\u4e00\u4e2a\u5373\u53ef # Docker Hub \u955c\u50cf\uff08\u5b98\u65b9\u955c\u50cf\u4ed3\u5e93\uff09 docker pull 24oi/oi-wiki # DaoCloud Hub \u955c\u50cf\uff08\u56fd\u5185\u955c\u50cf\u4ed3\u5e93\uff09 docker pull daocloud.io/sirius/oi-wiki # Tencent Hub \u955c\u50cf\uff08\u56fd\u5185\u955c\u50cf\u4ed3\u5e93\uff09 docker pull ccr.ccs.tencentyun.com/oi-wiki/oi-wiki","title":"\u62c9\u53d6 OI Wiki \u955c\u50cf"},{"location":"intro/docker-deploy.html#_1","text":"# \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c # \u514b\u9686 Git \u4ed3\u5e93 git clone https://github.com/OI-wiki/OI-wiki.git cd OI-wiki/ # \u6784\u5efa\u955c\u50cf docker build -t [ name ][ :tag ] . --build-arg [ variable1 ]=[ value1 ] [ variable2 ]=[ value2 ] ... \uff08\u5fc5\u987b\uff09\u8bbe\u7f6e [name] \u4ee5\u8bbe\u7f6e\u955c\u50cf\u540d\uff0c\uff08\u53ef\u9009\uff09\u8bbe\u7f6e [tag] \u4ee5\u8bbe\u7f6e\u955c\u50cf\u6807\u7b7e\uff08\u82e5\u8bbe\u7f6e\uff0c\u5219\u8fd0\u884c\u65f6\u955c\u50cf\u540d\u7531\u4e24\u90e8\u5206\u6784\u6210\uff09\u3002 \u53ef\u4ee5\u901a\u8fc7 --build-arg \u53c2\u6570\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u3002 \u53ef\u4ee5\u4f7f\u7528\u7684\u73af\u5883\u53d8\u91cf\uff1a \u53ef\u4ee5\u8bbe\u7f6e WIKI_REPO \u6765\u4f7f\u7528 Wiki \u4ed3\u5e93\u7684\u955c\u50cf\u7ad9\u70b9\uff08\u5f53\u672a\u8bbe\u7f6e\u65f6\u81ea\u52a8\u4f7f\u7528 GitHub\uff09 \u53ef\u4ee5\u8bbe\u7f6e PYPI_MIRROR \u6765\u4f7f\u7528 PyPI \u4ed3\u5e93\u7684\u955c\u50cf\u7ad9\u70b9\uff08\u5f53\u672a\u8bbe\u7f6e\u65f6\u81ea\u52a8\u4f7f\u7528\u5b98\u65b9 PyPI\uff09 \u5728\u56fd\u5185\u5efa\u8bae\u4f7f\u7528 TUNA \u955c\u50cf\u7ad9 https://pypi.tuna.tsinghua.edu.cn/simple/ \u53ef\u4ee5\u8bbe\u7f6e LISTEN_IP \u6765\u66f4\u6539\u76d1\u542c IP\uff08\u5f53\u672a\u8bbe\u7f6e\u65f6\u4e3a 0.0.0.0 \uff0c\u5373\u76d1\u542c\u6240\u6709 IP \u7684\u8bbf\u95ee\uff09 \u53ef\u4ee5\u8bbe\u7f6e LISTEN_PORT \u6765\u66f4\u6539\u76d1\u542c\u7aef\u53e3\uff08\u5f53\u672a\u8bbe\u7f6e\u65f6\u4e3a 8000 \uff09 \u793a\u4f8b\uff1a docker build -t OI_Wiki . --build-arg WIKI_REPO = https://hub.fastgit.xyz/OI-wiki/OI-wiki.git PYPI_MIRROR = https://pypi.tuna.tsinghua.edu.cn/simple/ # \u6784\u5efa\u4e00\u4e2a\u540d\u4e3a OI_Wiki \uff08\u6807\u7b7e\u9ed8\u8ba4\uff09\u7684\u955c\u50cf\uff0c\u4f7f\u7528 FastGit \u670d\u52a1\u52a0\u901f\u514b\u9686\uff0c\u4f7f\u7528 TUNA \u955c\u50cf\u7ad9\u3002","title":"\u81ea\u884c\u6784\u5efa\u955c\u50cf"},{"location":"intro/docker-deploy.html#_2","text":"# \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c docker run -d -it [ image ] \uff08\u5fc5\u987b\uff09\u8bbe\u7f6e [image] \u4ee5\u8bbe\u7f6e\u955c\u50cf\u3002\u4f8b\u5982\uff0c\u4ece Docker Hub \u62c9\u53d6\u7684\u4e3a 24oi/oi-wiki \uff1bDaoCloud Hub \u62c9\u53d6\u7684\u5219\u4e3a daocloud.io/sirius/oi-wiki \u3002 \uff08\u5fc5\u987b\uff09\u8bbe\u7f6e -p [port]:8000 \u4ee5\u6620\u5c04\u5bb9\u5668\u7aef\u53e3\u81f3\u4e3b\u673a\u7aef\u53e3\uff08\u4e0d\u5199\u8be5\u8bed\u53e5\u5219\u9ed8\u8ba4\u4e3a\u4e0d\u66b4\u9732\u7aef\u53e3\u3002\u8bbe\u7f6e\u65f6\u8bf7\u66ff\u6362 [port] \u4e3a\u4e3b\u673a\u7aef\u53e3\uff09\u3002\u8bbe\u7f6e\u540e\u53ef\u4ee5\u5728\u4e3b\u673a\u4f7f\u7528 http://127.0.0.1:[port] \u8bbf\u95ee OI Wiki \u3002 \u8bbe\u7f6e --name [name] \u4ee5\u8bbe\u7f6e\u5bb9\u5668\u540d\u5b57\u3002\uff08\u9ed8\u8ba4\u7a7a\u3002\u8bbe\u7f6e\u65f6\u8bf7\u66ff\u6362 [name] \u4e3a\u81ea\u5b9a\u4e49\u7684\u5bb9\u5668\u540d\u5b57\u3002\u82e5\u60f3\u67e5\u770b\u5bb9\u5668 id\uff0c\u5219\u8f93\u5165 docker ps \uff09","title":"\u8fd0\u884c\u5bb9\u5668"},{"location":"intro/docker-deploy.html#_3","text":"Note \u793a\u4f8b\u57fa\u4e8e Ubuntu latest \u90e8\u7f72\u3002 \u8fdb\u5165\u5bb9\u5668\uff1a # \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c docker exec -it [ name ] /bin/bash \u82e5\u5728\u4e0a\u8ff0\u8fd0\u884c\u5bb9\u5668\u4e2d\u53bb\u6389 -d \uff0c\u5219\u53ef\u4ee5\u76f4\u63a5\u8fdb\u5165\u5bb9\u5668 bash\uff0c\u9000\u51fa\u540e\u5bb9\u5668\u505c\u6b62\uff0c\u52a0\u4e0a -d \u5219\u540e\u53f0\u8fd0\u884c\uff0c\u8bf7\u624b\u52a8\u505c\u6b62\u3002\u4e0a\u8ff0\u8fdb\u5165\u5bb9\u5668\u9488\u5bf9\u52a0\u4e0a -d \u7684\u65b9\u6cd5\u8fd0\u884c\u3002 \u7279\u6b8a\u7528\u6cd5\uff1a # \u4ee5\u4e0b\u547d\u4ee4\u5728\u5bb9\u5668\u4e2d\u8fd0\u884c # \u66f4\u65b0 git \u4ed3\u5e93 wiki-upd # \u4f7f\u7528\u6211\u4eec\u7684\u81ea\u5b9a\u4e49\u4e3b\u9898 wiki-theme # \u6784\u5efa mkdocs \uff0c\u4f1a\u5728 site \u6587\u4ef6\u5939\u4e0b\u5f97\u5230\u9759\u6001\u9875\u9762 wiki-bld # \u6784\u5efa mkdocs \u5e76\u6e32\u67d3 MathJax \uff0c\u4f1a\u5728 site \u6587\u4ef6\u5939\u4e0b\u5f97\u5230\u9759\u6001\u9875\u9762 wiki-bld-math # \u8fd0\u884c\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u8bbf\u95ee\u5bb9\u5668\u4e2d http://127.0.0.1:8000 \u6216\u8bbf\u95ee\u4e3b\u673a\u4e2d http://127.0.0.1:[port] \u53ef\u4ee5\u67e5\u770b\u6548\u679c wiki-svr # \u4fee\u6b63 Markdown wiki-o \u9000\u51fa\u5bb9\u5668\uff1a # \u4ee5\u4e0b\u547d\u4ee4\u5728\u5bb9\u5668\u4e2d\u8fd0\u884c # \u9000\u51fa exit","title":"\u4f7f\u7528\u5bb9\u5668"},{"location":"intro/docker-deploy.html#_4","text":"# \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c docker stop [ name ]","title":"\u505c\u6b62\u5bb9\u5668"},{"location":"intro/docker-deploy.html#_5","text":"# \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c docker start [ name ]","title":"\u542f\u52a8\u5bb9\u5668"},{"location":"intro/docker-deploy.html#_6","text":"# \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c docker restart [ name ]","title":"\u91cd\u542f\u5bb9\u5668"},{"location":"intro/docker-deploy.html#_7","text":"# \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c # \u5220\u9664\u524d\u8bf7\u5148\u505c\u6b62\u5bb9\u5668 docker rm [ name ]","title":"\u5220\u9664\u5bb9\u5668"},{"location":"intro/docker-deploy.html#_8","text":"\u91cd\u65b0\u518d pull \u4e00\u6b21\u5373\u53ef\uff0c\u901a\u5e38\u4e0d\u4f1a\u66f4\u65b0\u3002","title":"\u66f4\u65b0\u955c\u50cf"},{"location":"intro/docker-deploy.html#_9","text":"# \u4ee5\u4e0b\u547d\u4ee4\u5728\u4e3b\u673a\u4e2d\u8fd0\u884c # \u5220\u9664\u524d\u8bf7\u5148\u5220\u9664\u4f7f\u7528 oi-wiki \u955c\u50cf\u6784\u5efa\u7684\u5bb9\u5668 docker rmi [ image ]","title":"\u5220\u9664\u955c\u50cf"},{"location":"intro/docker-deploy.html#_10","text":"\u5982\u679c\u60a8\u6709\u7591\u95ee\uff0c\u6b22\u8fce\u63d0\u51fa issue \uff01","title":"\u7591\u95ee"},{"location":"intro/faq.html","text":"\u672c\u9875\u9762\u4e3b\u8981\u89e3\u7b54\u4e00\u4e9b\u5e38\u89c1\u7684\u95ee\u9898\u3002 \u6211\u60f3\u95ee\u70b9\u4e0e\u8fd9\u4e2a Wiki \u76f8\u5173\u7684\u95ee\u9898 \u00b6 Q\uff1a\u4f60\u4eec\u662f\u4e3a\u4ec0\u4e48\u60f3\u8981\u505a\u8fd9\u4e2a Wiki \u7684\u5462\uff1f A\uff1a\u4e0d\u77e5\u9053\u4f60\u5728\u5b66 OI \u7684\u65f6\u5019\uff0c\u9762\u5bf9\u5e9e\u5927\u7684\u77e5\u8bc6\u4f53\u7cfb\uff0c\u6709\u6ca1\u6709\u611f\u5230\u8fc7\u8ff7\u832b\u65e0\u52a9\u7684\u65f6\u5019\uff1f OI Wiki \u60f3\u8981\u505a\u7684\u4e8b\u60c5\u53ef\u80fd\u7c7b\u4f3c\u4e8e\u300c\u8ba9\u66f4\u591a\u7ade\u8d5b\u8d44\u6e90\u4e0d\u5145\u88d5\u7684\u540c\u5b66\u80fd\u65b9\u4fbf\u5730\u63a5\u89e6\u5230\u8bad\u7ec3\u8d44\u6e90\u300d\u3002\u5f53\u7136\u8fd9\u4e48\u8868\u8ff0\u4e5f\u4e0d\u5b8c\u5168\uff0c\u505a Wiki \u7684\u52a8\u673a\u53ef\u80fd\u4e5f\u5f88\u7eaf\u7cb9\uff0c\u53ea\u662f\u7b80\u5355\u5730\u60f3\u8981\u5bf9 OI \u7684\u53d1\u5c55\u505a\u51fa\u4e00\u70b9\u70b9\u5fae\u5c0f\u7684\u8d21\u732e\u5427\u3002XD Q\uff1a\u6211\u5f88\u611f\u5174\u8da3\uff0c\u600e\u4e48\u53c2\u4e0e\uff1f A\uff1a OI Wiki \u73b0\u5728\u6258\u7ba1\u5728 GitHub \u4e0a\uff0c\u4f60\u53ef\u4ee5\u76f4\u63a5\u8bbf\u95ee\u8fd9\u4e2a repo \u6765\u67e5\u770b\u6700\u65b0\u8fdb\u5c55\u3002\u53c2\u4e0e\u7684\u9014\u5f84\u5305\u62ec\u5728 GitHub \u4e0a\u9762\u5f00 Issue \u3001 Pull Request \uff0c\u6216\u8005\u5728\u4ea4\u6d41\u7fa4\u4e2d\u5206\u4eab\u4f60\u7684\u60f3\u6cd5\u3001\u76f4\u63a5\u5411\u7ba1\u7406\u5458\u6295\u7a3f\u3002\u76ee\u524d\uff0c\u6211\u4eec\u4f7f\u7528\u7684\u6846\u67b6\u662f\u7528 Python \u5f00\u53d1\u7684 MkDocs \uff0c\u652f\u6301 Markdown \u683c\u5f0f\uff08\u4e5f\u652f\u6301\u63d2\u5165\u6570\u5b66\u516c\u5f0f\uff09\u3002 Q\uff1a\u53ef\u662f\u6211\u6bd4\u8f83\u5f31\u2026\u2026\u4e0d\u77e5\u9053\u6211\u80fd\u505a\u70b9\u4ec0\u4e48\u3002 A\uff1a\u4e00\u5207\u6e90\u4e8e\u70ed\u7231\u3002\u4f60\u53ef\u4ee5\u534f\u52a9\u5176\u4ed6\u4eba\u5ba1\u6838\u4fee\u6539\u7a3f\u4ef6\uff0c\u5e2e\u52a9\u6211\u4eec\u5ba3\u4f20 OI Wiki \uff0c\u4e3a\u793e\u533a\u8425\u9020\u826f\u597d\u5b66\u4e60\u4ea4\u6d41\u6c1b\u56f4\uff01 Q\uff1a\u73b0\u5728\u4e3b\u8981\u662f\u8c01\u5728\u505a\u8fd9\u4ef6\u4e8b\u554a\uff1f\u611f\u89c9\u8fd9\u662f\u4e2a\u5927\u5751\uff0c\u771f\u7684\u80fd\u505a\u597d\u5417\uff1f A\uff1a\u6700\u5f00\u59cb\u4e3b\u8981\u662f\u4e00\u4e9b\u9000\u5f79\u8001\u5e74\u9009\u624b\u5728\u505a\u8fd9\u4ef6\u4e8b\uff0c\u540e\u6765\u9047\u5230\u4e86\u5f88\u591a\u5fd7\u540c\u9053\u5408\u7684\u5c0f\u4f19\u4f34\uff1a\u6709\u73b0\u5f79\u9009\u624b\uff0c\u9000\u5f79\u73a9\u5bb6\uff0c\u4e5f\u6709\u4ece\u672a\u53c2\u52a0\u8fc7 OI \u7684\u670b\u53cb\u3002\u76ee\u524d\uff0c\u8fd9\u4e2a\u9879\u76ee\u4e3b\u8981\u662f\u7531 OI Wiki \u9879\u76ee\u7ec4\u6765\u7ef4\u62a4\uff08\u4e0b\u9762\u662f\u4e00\u5f20\u5408\u5f71\uff09\u3002 \u5f53\u7136\uff0c\u8fd9\u4e2a\u9879\u76ee\u53ea\u9760\u6211\u4eec\u7684\u529b\u91cf\u662f\u5f88\u96be\u505a\u5f97\u5341\u5168\u5341\u7f8e\u7684\uff0c\u6211\u4eec\u8bda\u631a\u5730\u9080\u8bf7\u4f60\u4e00\u8d77\u6765\u5b8c\u5584 OI Wiki \u3002 Q\uff1a\u4f60\u4eec\u600e\u4e48\u4fdd\u8bc1\u6211\u4eec\u6dfb\u52a0\u7684\u5185\u5bb9\u4e0d\u4f1a\u7a81\u7136\u6d88\u5931\uff1f A\uff1a\u6211\u4eec\u628a\u5185\u5bb9\u6258\u7ba1\u5728 GitHub \u4e0a\u9762\uff0c\u5373\u4f7f\u6211\u4eec\u7684\u670d\u52a1\u5668\u7ffb\u8f66\u4e86\uff0c\u5185\u5bb9\u4e5f\u4e0d\u4f1a\u4e22\u5931\u3002\u53e6\u5916\uff0c\u6211\u4eec\u4e5f\u4f1a\u5b9a\u671f\u5907\u4efd\u5927\u5bb6\u7684\u5fc3\u8840\uff0c\u5373\u4f7f\u6709\u4e00\u5929 GitHub \u5012\u95ed\u4e86\uff08\uff1f\uff09\uff0c\u6211\u4eec\u7684\u5185\u5bb9\u4e5f\u4e0d\u4f1a\u4e22\u5931\u3002 Q\uff1a OI Wiki \u597d\u50cf\u6709\u7a7a\u7684\u9875\u9762\u554a\uff01 A\uff1a\u662f\u7684\u3002\u53d7\u9650\u4e8e\u9879\u76ee\u7ec4\u6210\u5458\u7684\u6c34\u5e73\u548c\u65f6\u95f4\uff0c\u6211\u4eec\u6682\u65f6\u65e0\u6cd5\u5b8c\u6210\u8fd9\u4e9b\u7a7a\u9875\u9762\u3002\u6240\u4ee5\u6211\u4eec\u5728\u8fd9\u91cc\u8fdb\u884c\u5f81\u7a3f\u548c\u62db\u52df\uff0c\u5e0c\u671b\u53ef\u4ee5\u9047\u5230\u6709\u540c\u6837\u60f3\u6cd5\u7684\u670b\u53cb\uff0c\u6211\u4eec\u4e00\u8d77\u628a OI Wiki \u5b8c\u5584\u8d77\u6765\u3002 Q\uff1a\u4e3a\u4ec0\u4e48\u4e0d\u76f4\u63a5\u53bb\u5199 \u4e2d\u6587\u7ef4\u57fa\u767e\u79d1 \u5462\uff1f A\uff1a\u56e0\u4e3a\u6211\u4eec\u5e0c\u671b\u53ef\u4ee5\u771f\u6b63\u5e2e\u5230\u66f4\u591a\u7684\u9009\u624b\u6216\u8005\u5bf9\u8fd9\u4e9b\u5185\u5bb9\u611f\u5174\u8da3\u7684\u4eba\u3002\u800c\u4e14\u7531\u4e8e\u4f17\u6240\u5468\u77e5\u7684\u539f\u56e0\uff0c\u4e2d\u6587\u7ef4\u57fa\u4e0a\u7684\u5185\u5bb9\u5e76\u4e0d\u662f\u65e0\u95e8\u69db\u5c31\u53ef\u4ee5\u83b7\u53d6\u5230\u7684\u3002 \u6211\u60f3\u53c2\u4e0e\u8fdb\u6765\uff01 \u00b6 Q\uff1a\u6211\u8981\u600e\u4e48\u4e0e\u9879\u76ee\u7ec4\u4ea4\u6d41\uff1f A\uff1a\u53ef\u4ee5\u901a\u8fc7 \u5173\u4e8e\u672c\u9879\u76ee\u91cc\u7684\u4ea4\u6d41\u65b9\u5f0f \u8054\u7cfb\u6211\u4eec\u3002 Q\uff1a\u6211\u8981\u600e\u4e48\u8d21\u732e\u4ee3\u7801\u6216\u8005\u5185\u5bb9\uff1f \u8bf7\u53c2\u8003 \u5982\u4f55\u53c2\u4e0e \u9875\u9762\u3002 Q\uff1a\u76ee\u5f55\u5728\u54ea\uff1f A\uff1a\u76ee\u5f55\u5728\u9879\u76ee\u6839\u76ee\u5f55\u4e0b\u7684 mkdocs.yml \u6587\u4ef6\u4e2d\u3002 Q\uff1a\u5982\u4f55\u4fee\u6539\u4e00\u4e2a topic \u7684\u5185\u5bb9\uff1f A\uff1a\u5728\u5bf9\u5e94\u9875\u9762\u53f3\u4e0a\u65b9\u6709\u4e00\u4e2a\u7f16\u8f91\u6309\u94ae edit \uff0c\u70b9\u51fb\u5e76\u786e\u8ba4\u9605\u8bfb\u4e86 \u5982\u4f55\u8d21\u732e \u4e4b\u540e\u4f1a\u8df3\u8f6c\u5230 GitHub \u4e0a\u5bf9\u5e94\u6587\u4ef6\u7684\u4f4d\u7f6e\u3002 \u6216\u8005\u4e5f\u53ef\u4ee5\u81ea\u884c\u9605\u8bfb\u76ee\u5f55 (mkdocs.yml) \u67e5\u627e\u6587\u4ef6\u4f4d\u7f6e\u3002 Q\uff1a\u5982\u4f55\u6dfb\u52a0\u4e00\u4e2a topic\uff1f A\uff1a\u6709\u4e24\u79cd\u9009\u62e9\uff1a \u53ef\u4ee5\u5f00\u4e00\u4e2a Issue\uff0c\u6ce8\u660e\u5e0c\u671b\u80fd\u6dfb\u52a0\u7684\u5185\u5bb9\u3002 \u53ef\u4ee5\u5f00\u4e00\u4e2a Pull Request\uff0c\u5728\u76ee\u5f55 (mkdocs.yml) \u4e2d\u52a0\u4e0a\u65b0\u7684 topic\uff0c\u5e76\u5728 docs \u6587\u4ef6\u5939\u4e0b\u5bf9\u5e94\u4f4d\u7f6e\u521b\u5efa\u4e00\u4e2a\u7a7a\u7684 .md \u6587\u4ef6\u3002\u6587\u6863\u7684\u683c\u5f0f\u7ec6\u8282\u8bf7\u53c2\u8003 \u683c\u5f0f\u624b\u518c \u3002 Q\uff1a\u6211\u5c1d\u8bd5\u8bbf\u95ee GitHub \u7684\u65f6\u5019\u9047\u5230\u4e86\u56f0\u96be\u3002 A\uff1a\u63a8\u8350\u5728 hosts \u6587\u4ef6\u4e2d\u52a0\u5165\u5982\u4e0b\u51e0\u884c ^ref1 \uff1a # GitHub Start 140.82.114.25 alive.github.com 140.82.113.5 api.github.com 185.199.110.153 assets-cdn.github.com 185.199.111.133 avatars.githubusercontent.com 185.199.111.133 avatars0.githubusercontent.com 185.199.111.133 avatars1.githubusercontent.com 185.199.111.133 avatars2.githubusercontent.com 185.199.111.133 avatars3.githubusercontent.com 185.199.111.133 avatars4.githubusercontent.com 185.199.111.133 avatars5.githubusercontent.com 185.199.111.133 camo.githubusercontent.com 140.82.112.22 central.github.com 185.199.111.133 cloud.githubusercontent.com 140.82.114.9 codeload.github.com 140.82.113.22 collector.github.com 185.199.111.133 desktop.githubusercontent.com 185.199.111.133 favicons.githubusercontent.com 140.82.112.3 gist.github.com 52.216.163.147 github-cloud.s3.amazonaws.com 52.217.124.1 github-com.s3.amazonaws.com 52.216.144.83 github-production-release-asset-2e65be.s3.amazonaws.com 52.217.121.249 github-production-repository-file-5c1aeb.s3.amazonaws.com 52.217.206.57 github-production-user-asset-6210df.s3.amazonaws.com 192.0.66.2 github.blog 140.82.114.4 github.com 140.82.113.18 github.community 185.199.110.154 github.githubassets.com 151.101.1.194 github.global.ssl.fastly.net 185.199.110.153 github.io 185.199.111.133 github.map.fastly.net 185.199.110.153 githubstatus.com 140.82.112.25 live.github.com 185.199.111.133 media.githubusercontent.com 185.199.111.133 objects.githubusercontent.com 13.107.42.16 pipelines.actions.githubusercontent.com 185.199.111.133 raw.githubusercontent.com 185.199.111.133 user-images.githubusercontent.com 13.107.253.40 vscode.dev 140.82.112.21 education.github.com # GitHub End \u53ef\u4ee5\u5728 GitHub520 \u4e0a\u4e86\u89e3\u5230\u6700\u65b0\u5185\u5bb9\u548c\u66f4\u591a\u4fe1\u606f\u3002 Linux \u548c macOS \u7528\u6237\u53ef\u4ee5\u5c1d\u8bd5\u4f7f\u7528 \u4f9d\u4e91 \u7684 gh-check \u811a\u672c \u83b7\u53d6\u8bbf\u95ee\u6700\u5feb\u7684 IP\uff0c\u4f7f\u7528 --hosts \u53c2\u6570\u53ef\u4ee5\u76f4\u63a5\u66f4\u65b0 hosts \u6587\u4ef6\u3002\u4f7f\u7528 --help \u53c2\u6570\u53ef\u4ee5\u83b7\u53d6\u4f7f\u7528\u5e2e\u52a9\u3002\u4f7f\u7528\u5148\u9700\u8981\u5b89\u88c5 Python3 \u548c aiohttp\uff08 pip install aiohttp -i https://pypi.tuna.tsinghua.edu.cn/simple/ \uff09\u3002\u4f9d\u4e91\u535a\u5ba2\u7684\u4ecb\u7ecd\uff1a \u5bfb\u627e\u6700\u5feb\u7684 GitHub IP \u3002 \u540c\u65f6\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 Gitclone \u670d\u52a1\u52a0\u901f Clone\uff0c\u53ef\u4ee5\u9605\u8bfb\u5176\u9996\u9875\u4e0a\u7684\u8bf4\u660e\u3002 \u5982\u679c\u60a8\u4ec5\u4ec5\u662f\u60f3 Clone OI Wiki \u7684\u4ed3\u5e93\uff0c\u90a3\u4e48\uff1a git clone https://gitclone.com/github.com/OI-wiki/OI-wiki \u5982\u679c\u60a8\u9700\u8981\u5411 OI Wiki \u8d21\u732e\uff0c\u90a3\u4e48\u9996\u5148 fork OI Wiki \u7684\u4ed3\u5e93\uff0c\u7136\u540e\uff08\u5c06 username \u66ff\u6362\u4e3a\u60a8\u7684\u7528\u6237\u540d\uff09\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\u63d0\u4f9b\u7684\u793a\u4f8b\u5c06\u4f7f\u60a8\u4f7f\u7528 SSH \u8fde\u63a5\u5230 GitHub[^only-ssh-connect]\uff1a git clone https://gitclone.com/github.com/username/OI-wiki git remote set-url origin git@github.com:username/OI-wiki.git Q\uff1a\u6211\u8fd9\u91cc pip \u4e5f\u592a\u6162\u4e86\uff01 A\uff1a\u53ef\u4ee5\u9009\u62e9\u66f4\u6362\u56fd\u5185\u6e90[^ref2]\uff0c\u6216\u8005\uff1a pip install -U -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/ Q\uff1a\u6211\u5728\u5ba2\u6237\u7aef clone \u4e86\u8fd9\u4e2a\u9879\u76ee\uff0c\u901f\u5ea6\u592a\u6162\u3002 A\uff1a\u5982\u679c\u6709\u5b89\u88c5 git bash \uff0c\u53ef\u4ee5\u52a0\u51e0\u4e2a\u9650\u5236\u6765\u51cf\u5c11\u4e0b\u8f7d\u91cf\u3002[^ref3] git clone https://github.com/OI-wiki/OI-wiki.git --depth = 1 -b master Q\uff1a\u6211\u6ca1\u88c5\u8fc7 Python 3\u3002 A\uff1a\u53ef\u4ee5\u8bbf\u95ee Python \u5b98\u7f51 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002 Q\uff1a\u597d\u50cf\u63d0\u793a\u6211 pip \u7248\u672c\u8fc7\u4f4e\u3002 A\uff1a\u8fdb\u5165 cmd/shell \u4e4b\u540e\uff0c\u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\uff1a python -m pip install --upgrade pip Q\uff1a\u6211\u5b89\u88c5\u4f9d\u8d56\u5931\u8d25\u4e86\u3002 A\uff1a\u68c0\u67e5\u4e00\u4e0b\uff1a\u7f51\u7edc\uff1f\u6743\u9650\uff1f\u67e5\u770b\u9519\u8bef\u4fe1\u606f\uff1f Q\uff1a\u6211\u5df2\u7ecf clone \u4e0b\u6765\u4e86\uff0c\u4e3a\u4ec0\u4e48\u90e8\u7f72\u4e0d\u4e86\uff1f A\uff1a\u68c0\u67e5\u4e00\u4e0b\u662f\u5426\u5b89\u88c5\u597d\u4e86\u4f9d\u8d56\uff1f Q\uff1a\u6211 clone \u4e86\u5f88\u4e45\u4e4b\u524d\u7684 repo\uff0c\u600e\u4e48\u66f4\u65b0\u5230\u65b0\u7248\u672c\u5462\uff1f A\uff1a\u8bf7\u53c2\u8003 GitHub \u5b98\u65b9\u7684\u5e2e\u52a9\u9875\u9762 Syncing a fork - GitHub Docs \u3002 Q\uff1a\u5982\u679c\u662f\u88c5\u4e86\u4e4b\u524d\u7684\u4f9d\u8d56\u600e\u4e48\u66f4\u65b0\uff1f A\uff1a\u8bf7\u8f93\u5165\u4ee5\u4e0b\u547d\u4ee4\uff1a pip install -U -r requirements.txt Q\uff1a\u4e3a\u4ec0\u4e48\u6211\u7684 markdown \u683c\u5f0f\u4e71\u4e86\uff1f A\uff1a\u53ef\u4ee5\u67e5\u9605 cyent \u7684\u7b14\u8bb0 \uff0c\u6216\u8005 MkDocs \u4f7f\u7528\u8bf4\u660e \u3002 \u6211\u4eec\u76ee\u524d\u4f7f\u7528 remark-lint \u6765\u81ea\u52a8\u5316\u4fee\u6b63\u683c\u5f0f\uff0c\u53ef\u80fd\u8fd8\u6709\u4e00\u4e9b \u914d\u7f6e \u4e0d\u591f\u597d\u7684\u5730\u65b9\uff0c\u6b22\u8fce\u6307\u51fa\u3002 Q\uff1aGitHub \u662f\u4e0d\u662f\u4e0d\u663e\u793a\u6211\u7684\u6570\u5b66\u516c\u5f0f\uff1f A\uff1a\u662f\u7684\uff0cGitHub \u7684\u9884\u89c8\u4e0d\u663e\u793a\u6570\u5b66\u516c\u5f0f\u3002\u4f46\u662f\u8bf7\u653e\u5fc3\uff0cMkDocs \u662f\u652f\u6301\u6570\u5b66\u516c\u5f0f\u7684\uff0c\u53ef\u4ee5\u6b63\u5e38\u4f7f\u7528\uff0c\u53ea\u8981\u662f MathJax \u652f\u6301\u7684\u53e5\u5f0f\u90fd\u53ef\u4ee5\u4f7f\u7528\u3002 Q\uff1a\u6211\u7684\u6570\u5b66\u516c\u5f0f\u600e\u4e48\u4e71\u7801\u4e86\uff1f A\uff1a\u5982\u679c\u662f\u884c\u95f4\u516c\u5f0f\uff08\u7528\u7684 $$ \uff09\uff0c\u76ee\u524d\u5df2\u77e5\u7684\u95ee\u9898\u662f\u9700\u8981\u5728 $$ \u4e24\u4fa7\u7559\u6709\u7a7a\u884c\uff0c\u4e14 $$ \u8981 \u5355\u72ec \u653e\u5728\u4e00\u884c\u91cc\uff08\u4e14\u4e0d\u8981\u5728\u524d\u52a0\u7a7a\u683c\uff09\u3002\u683c\u5f0f\u5982\u4e0b\uff1a // \u7a7a\u884c $$ a_i $$ // \u7a7a\u884c Q\uff1a\u6211\u7684\u516c\u5f0f\u4e3a\u4ec0\u4e48\u5728\u76ee\u5f55\u91cc\u6ca1\u6709\u6b63\u5e38\u663e\u793a\uff1f\u597d\u50cf\u53cc\u500d\u4e86\u3002 A\uff1a\u662f\u7684\uff0c\u8fd9\u4e2a\u662f python-markdown \u7684\u4e00\u4e2a bug\uff0c\u53ef\u80fd\u8fd1\u671f\u4f1a\u4fee\u590d\u3002 \u5982\u679c\u60f3\u8981\u907f\u514d\u76ee\u5f55\u4e2d\u51fa\u73b0\u53cc\u500d\u516c\u5f0f\uff0c\u53ef\u4ee5\u53c2\u8003 string \u5206\u7c7b\u4e0b SAM \u7684\u76ee\u5f55\u5199\u6cd5 \u3002 \u7ed3\u675f\u4f4d\u7f6e <script type=\"math/tex\">endpos</script> \u5728\u76ee\u5f55\u4e2d\u4f1a\u53d8\u6210 \u7ed3\u675f\u4f4d\u7f6e endpos \u6ce8\uff1a\u73b0\u5728\u8bf7\u5c3d\u91cf\u907f\u514d\u5728\u76ee\u5f55\u4e2d\u5f15\u5165 MathJax \u516c\u5f0f\u3002 Q\uff1a\u5982\u4f55\u7ed9\u4e00\u4e2a\u9875\u9762\u5355\u72ec\u58f0\u660e\u7248\u6743\u4fe1\u606f\uff1f A\uff1a\u5728\u9875\u9762\u5f00\u5934\u52a0\u4e00\u884c\u5373\u53ef\u3002[^ref4] \u6bd4\u5982\uff1a copyright: SATA \u6ce8\uff1a\u9ed8\u8ba4\u7684\u662f CC BY-SA 4.0 \u548c SATA\u3002 Q\uff1a\u4e3a\u4ec0\u4e48\u4f5c\u8005\u4fe1\u606f\u7edf\u8ba1\u5904\u6ca1\u6709\u6211\u7684\u540d\u5b57\uff1f A\uff1a\u5982\u679c\u4f60\u53d1\u73b0\u81ea\u5df1\u5199\u8fc7\u4e00\u4e2a\u9875\u9762\u4e2d\u7684\u90e8\u5206\u5185\u5bb9\uff0c\u4f46\u662f\u4f60\u6ca1\u6709\u88ab\u8bb0\u5f55\u8fdb\u4f5c\u8005\u5217\u8868\uff0c\u53ef\u4ee5\u628a\u81ea\u5df1\u7684 GitHub ID \u52a0\u5165\u5230\u6587\u4ef6\u5934\u7684 author \u5b57\u6bb5 \u3002 \u611f\u8c22\u4f60\u770b\u5230\u4e86\u6700\u540e\uff0c\u6211\u4eec\u73b0\u5728\u4e9f\u9700\u7684\uff0c\u5c31\u662f\u4f60\u7684\u5e2e\u52a9\u3002 OI Wiki \u9879\u76ee\u7ec4 2018.8 \u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca \u00b6 [^ref2]: \u66f4\u6539 pip \u6e90\u81f3\u56fd\u5185\u955c\u50cf - L \u745c - CSDN \u535a\u5ba2 [^ref3]: GIT--- \u770b\u6211\u4e00\u6b65\u6b65\u5165\u95e8\uff08Windows Git Bash\uff09 [^ref4]: Metadata - Material for MkDocs [^only-ssh-connect]: GitHub \u5f03\u7528\u4e86\u57fa\u4e8e\u5bc6\u7801\u8eab\u4efd\u9a8c\u8bc1\u7684 HTTPS \u534f\u8bae\uff0c\u8fde\u63a5\u5fc5\u987b\u4f7f\u7528 SSH \u6216\u8005 Personal Access Token\uff0c\u53c2\u89c1 \u6211\u5e94\u4f7f\u7528\u54ea\u4e2a\u8fdc\u7a0b URL\uff1f \uff0c \u521b\u5efa\u4e2a\u4eba\u8bbf\u95ee\u4ee4\u724c \u548c \u4f7f\u7528 SSH \u8fde\u63a5\u5230 GitHub \u3002","title":"Faq"},{"location":"intro/faq.html#wiki","text":"Q\uff1a\u4f60\u4eec\u662f\u4e3a\u4ec0\u4e48\u60f3\u8981\u505a\u8fd9\u4e2a Wiki \u7684\u5462\uff1f A\uff1a\u4e0d\u77e5\u9053\u4f60\u5728\u5b66 OI \u7684\u65f6\u5019\uff0c\u9762\u5bf9\u5e9e\u5927\u7684\u77e5\u8bc6\u4f53\u7cfb\uff0c\u6709\u6ca1\u6709\u611f\u5230\u8fc7\u8ff7\u832b\u65e0\u52a9\u7684\u65f6\u5019\uff1f OI Wiki \u60f3\u8981\u505a\u7684\u4e8b\u60c5\u53ef\u80fd\u7c7b\u4f3c\u4e8e\u300c\u8ba9\u66f4\u591a\u7ade\u8d5b\u8d44\u6e90\u4e0d\u5145\u88d5\u7684\u540c\u5b66\u80fd\u65b9\u4fbf\u5730\u63a5\u89e6\u5230\u8bad\u7ec3\u8d44\u6e90\u300d\u3002\u5f53\u7136\u8fd9\u4e48\u8868\u8ff0\u4e5f\u4e0d\u5b8c\u5168\uff0c\u505a Wiki \u7684\u52a8\u673a\u53ef\u80fd\u4e5f\u5f88\u7eaf\u7cb9\uff0c\u53ea\u662f\u7b80\u5355\u5730\u60f3\u8981\u5bf9 OI \u7684\u53d1\u5c55\u505a\u51fa\u4e00\u70b9\u70b9\u5fae\u5c0f\u7684\u8d21\u732e\u5427\u3002XD Q\uff1a\u6211\u5f88\u611f\u5174\u8da3\uff0c\u600e\u4e48\u53c2\u4e0e\uff1f A\uff1a OI Wiki \u73b0\u5728\u6258\u7ba1\u5728 GitHub \u4e0a\uff0c\u4f60\u53ef\u4ee5\u76f4\u63a5\u8bbf\u95ee\u8fd9\u4e2a repo \u6765\u67e5\u770b\u6700\u65b0\u8fdb\u5c55\u3002\u53c2\u4e0e\u7684\u9014\u5f84\u5305\u62ec\u5728 GitHub \u4e0a\u9762\u5f00 Issue \u3001 Pull Request \uff0c\u6216\u8005\u5728\u4ea4\u6d41\u7fa4\u4e2d\u5206\u4eab\u4f60\u7684\u60f3\u6cd5\u3001\u76f4\u63a5\u5411\u7ba1\u7406\u5458\u6295\u7a3f\u3002\u76ee\u524d\uff0c\u6211\u4eec\u4f7f\u7528\u7684\u6846\u67b6\u662f\u7528 Python \u5f00\u53d1\u7684 MkDocs \uff0c\u652f\u6301 Markdown \u683c\u5f0f\uff08\u4e5f\u652f\u6301\u63d2\u5165\u6570\u5b66\u516c\u5f0f\uff09\u3002 Q\uff1a\u53ef\u662f\u6211\u6bd4\u8f83\u5f31\u2026\u2026\u4e0d\u77e5\u9053\u6211\u80fd\u505a\u70b9\u4ec0\u4e48\u3002 A\uff1a\u4e00\u5207\u6e90\u4e8e\u70ed\u7231\u3002\u4f60\u53ef\u4ee5\u534f\u52a9\u5176\u4ed6\u4eba\u5ba1\u6838\u4fee\u6539\u7a3f\u4ef6\uff0c\u5e2e\u52a9\u6211\u4eec\u5ba3\u4f20 OI Wiki \uff0c\u4e3a\u793e\u533a\u8425\u9020\u826f\u597d\u5b66\u4e60\u4ea4\u6d41\u6c1b\u56f4\uff01 Q\uff1a\u73b0\u5728\u4e3b\u8981\u662f\u8c01\u5728\u505a\u8fd9\u4ef6\u4e8b\u554a\uff1f\u611f\u89c9\u8fd9\u662f\u4e2a\u5927\u5751\uff0c\u771f\u7684\u80fd\u505a\u597d\u5417\uff1f A\uff1a\u6700\u5f00\u59cb\u4e3b\u8981\u662f\u4e00\u4e9b\u9000\u5f79\u8001\u5e74\u9009\u624b\u5728\u505a\u8fd9\u4ef6\u4e8b\uff0c\u540e\u6765\u9047\u5230\u4e86\u5f88\u591a\u5fd7\u540c\u9053\u5408\u7684\u5c0f\u4f19\u4f34\uff1a\u6709\u73b0\u5f79\u9009\u624b\uff0c\u9000\u5f79\u73a9\u5bb6\uff0c\u4e5f\u6709\u4ece\u672a\u53c2\u52a0\u8fc7 OI \u7684\u670b\u53cb\u3002\u76ee\u524d\uff0c\u8fd9\u4e2a\u9879\u76ee\u4e3b\u8981\u662f\u7531 OI Wiki \u9879\u76ee\u7ec4\u6765\u7ef4\u62a4\uff08\u4e0b\u9762\u662f\u4e00\u5f20\u5408\u5f71\uff09\u3002 \u5f53\u7136\uff0c\u8fd9\u4e2a\u9879\u76ee\u53ea\u9760\u6211\u4eec\u7684\u529b\u91cf\u662f\u5f88\u96be\u505a\u5f97\u5341\u5168\u5341\u7f8e\u7684\uff0c\u6211\u4eec\u8bda\u631a\u5730\u9080\u8bf7\u4f60\u4e00\u8d77\u6765\u5b8c\u5584 OI Wiki \u3002 Q\uff1a\u4f60\u4eec\u600e\u4e48\u4fdd\u8bc1\u6211\u4eec\u6dfb\u52a0\u7684\u5185\u5bb9\u4e0d\u4f1a\u7a81\u7136\u6d88\u5931\uff1f A\uff1a\u6211\u4eec\u628a\u5185\u5bb9\u6258\u7ba1\u5728 GitHub \u4e0a\u9762\uff0c\u5373\u4f7f\u6211\u4eec\u7684\u670d\u52a1\u5668\u7ffb\u8f66\u4e86\uff0c\u5185\u5bb9\u4e5f\u4e0d\u4f1a\u4e22\u5931\u3002\u53e6\u5916\uff0c\u6211\u4eec\u4e5f\u4f1a\u5b9a\u671f\u5907\u4efd\u5927\u5bb6\u7684\u5fc3\u8840\uff0c\u5373\u4f7f\u6709\u4e00\u5929 GitHub \u5012\u95ed\u4e86\uff08\uff1f\uff09\uff0c\u6211\u4eec\u7684\u5185\u5bb9\u4e5f\u4e0d\u4f1a\u4e22\u5931\u3002 Q\uff1a OI Wiki \u597d\u50cf\u6709\u7a7a\u7684\u9875\u9762\u554a\uff01 A\uff1a\u662f\u7684\u3002\u53d7\u9650\u4e8e\u9879\u76ee\u7ec4\u6210\u5458\u7684\u6c34\u5e73\u548c\u65f6\u95f4\uff0c\u6211\u4eec\u6682\u65f6\u65e0\u6cd5\u5b8c\u6210\u8fd9\u4e9b\u7a7a\u9875\u9762\u3002\u6240\u4ee5\u6211\u4eec\u5728\u8fd9\u91cc\u8fdb\u884c\u5f81\u7a3f\u548c\u62db\u52df\uff0c\u5e0c\u671b\u53ef\u4ee5\u9047\u5230\u6709\u540c\u6837\u60f3\u6cd5\u7684\u670b\u53cb\uff0c\u6211\u4eec\u4e00\u8d77\u628a OI Wiki \u5b8c\u5584\u8d77\u6765\u3002 Q\uff1a\u4e3a\u4ec0\u4e48\u4e0d\u76f4\u63a5\u53bb\u5199 \u4e2d\u6587\u7ef4\u57fa\u767e\u79d1 \u5462\uff1f A\uff1a\u56e0\u4e3a\u6211\u4eec\u5e0c\u671b\u53ef\u4ee5\u771f\u6b63\u5e2e\u5230\u66f4\u591a\u7684\u9009\u624b\u6216\u8005\u5bf9\u8fd9\u4e9b\u5185\u5bb9\u611f\u5174\u8da3\u7684\u4eba\u3002\u800c\u4e14\u7531\u4e8e\u4f17\u6240\u5468\u77e5\u7684\u539f\u56e0\uff0c\u4e2d\u6587\u7ef4\u57fa\u4e0a\u7684\u5185\u5bb9\u5e76\u4e0d\u662f\u65e0\u95e8\u69db\u5c31\u53ef\u4ee5\u83b7\u53d6\u5230\u7684\u3002","title":"\u6211\u60f3\u95ee\u70b9\u4e0e\u8fd9\u4e2a Wiki \u76f8\u5173\u7684\u95ee\u9898"},{"location":"intro/faq.html#_1","text":"Q\uff1a\u6211\u8981\u600e\u4e48\u4e0e\u9879\u76ee\u7ec4\u4ea4\u6d41\uff1f A\uff1a\u53ef\u4ee5\u901a\u8fc7 \u5173\u4e8e\u672c\u9879\u76ee\u91cc\u7684\u4ea4\u6d41\u65b9\u5f0f \u8054\u7cfb\u6211\u4eec\u3002 Q\uff1a\u6211\u8981\u600e\u4e48\u8d21\u732e\u4ee3\u7801\u6216\u8005\u5185\u5bb9\uff1f \u8bf7\u53c2\u8003 \u5982\u4f55\u53c2\u4e0e \u9875\u9762\u3002 Q\uff1a\u76ee\u5f55\u5728\u54ea\uff1f A\uff1a\u76ee\u5f55\u5728\u9879\u76ee\u6839\u76ee\u5f55\u4e0b\u7684 mkdocs.yml \u6587\u4ef6\u4e2d\u3002 Q\uff1a\u5982\u4f55\u4fee\u6539\u4e00\u4e2a topic \u7684\u5185\u5bb9\uff1f A\uff1a\u5728\u5bf9\u5e94\u9875\u9762\u53f3\u4e0a\u65b9\u6709\u4e00\u4e2a\u7f16\u8f91\u6309\u94ae edit \uff0c\u70b9\u51fb\u5e76\u786e\u8ba4\u9605\u8bfb\u4e86 \u5982\u4f55\u8d21\u732e \u4e4b\u540e\u4f1a\u8df3\u8f6c\u5230 GitHub \u4e0a\u5bf9\u5e94\u6587\u4ef6\u7684\u4f4d\u7f6e\u3002 \u6216\u8005\u4e5f\u53ef\u4ee5\u81ea\u884c\u9605\u8bfb\u76ee\u5f55 (mkdocs.yml) \u67e5\u627e\u6587\u4ef6\u4f4d\u7f6e\u3002 Q\uff1a\u5982\u4f55\u6dfb\u52a0\u4e00\u4e2a topic\uff1f A\uff1a\u6709\u4e24\u79cd\u9009\u62e9\uff1a \u53ef\u4ee5\u5f00\u4e00\u4e2a Issue\uff0c\u6ce8\u660e\u5e0c\u671b\u80fd\u6dfb\u52a0\u7684\u5185\u5bb9\u3002 \u53ef\u4ee5\u5f00\u4e00\u4e2a Pull Request\uff0c\u5728\u76ee\u5f55 (mkdocs.yml) \u4e2d\u52a0\u4e0a\u65b0\u7684 topic\uff0c\u5e76\u5728 docs \u6587\u4ef6\u5939\u4e0b\u5bf9\u5e94\u4f4d\u7f6e\u521b\u5efa\u4e00\u4e2a\u7a7a\u7684 .md \u6587\u4ef6\u3002\u6587\u6863\u7684\u683c\u5f0f\u7ec6\u8282\u8bf7\u53c2\u8003 \u683c\u5f0f\u624b\u518c \u3002 Q\uff1a\u6211\u5c1d\u8bd5\u8bbf\u95ee GitHub \u7684\u65f6\u5019\u9047\u5230\u4e86\u56f0\u96be\u3002 A\uff1a\u63a8\u8350\u5728 hosts \u6587\u4ef6\u4e2d\u52a0\u5165\u5982\u4e0b\u51e0\u884c ^ref1 \uff1a # GitHub Start 140.82.114.25 alive.github.com 140.82.113.5 api.github.com 185.199.110.153 assets-cdn.github.com 185.199.111.133 avatars.githubusercontent.com 185.199.111.133 avatars0.githubusercontent.com 185.199.111.133 avatars1.githubusercontent.com 185.199.111.133 avatars2.githubusercontent.com 185.199.111.133 avatars3.githubusercontent.com 185.199.111.133 avatars4.githubusercontent.com 185.199.111.133 avatars5.githubusercontent.com 185.199.111.133 camo.githubusercontent.com 140.82.112.22 central.github.com 185.199.111.133 cloud.githubusercontent.com 140.82.114.9 codeload.github.com 140.82.113.22 collector.github.com 185.199.111.133 desktop.githubusercontent.com 185.199.111.133 favicons.githubusercontent.com 140.82.112.3 gist.github.com 52.216.163.147 github-cloud.s3.amazonaws.com 52.217.124.1 github-com.s3.amazonaws.com 52.216.144.83 github-production-release-asset-2e65be.s3.amazonaws.com 52.217.121.249 github-production-repository-file-5c1aeb.s3.amazonaws.com 52.217.206.57 github-production-user-asset-6210df.s3.amazonaws.com 192.0.66.2 github.blog 140.82.114.4 github.com 140.82.113.18 github.community 185.199.110.154 github.githubassets.com 151.101.1.194 github.global.ssl.fastly.net 185.199.110.153 github.io 185.199.111.133 github.map.fastly.net 185.199.110.153 githubstatus.com 140.82.112.25 live.github.com 185.199.111.133 media.githubusercontent.com 185.199.111.133 objects.githubusercontent.com 13.107.42.16 pipelines.actions.githubusercontent.com 185.199.111.133 raw.githubusercontent.com 185.199.111.133 user-images.githubusercontent.com 13.107.253.40 vscode.dev 140.82.112.21 education.github.com # GitHub End \u53ef\u4ee5\u5728 GitHub520 \u4e0a\u4e86\u89e3\u5230\u6700\u65b0\u5185\u5bb9\u548c\u66f4\u591a\u4fe1\u606f\u3002 Linux \u548c macOS \u7528\u6237\u53ef\u4ee5\u5c1d\u8bd5\u4f7f\u7528 \u4f9d\u4e91 \u7684 gh-check \u811a\u672c \u83b7\u53d6\u8bbf\u95ee\u6700\u5feb\u7684 IP\uff0c\u4f7f\u7528 --hosts \u53c2\u6570\u53ef\u4ee5\u76f4\u63a5\u66f4\u65b0 hosts \u6587\u4ef6\u3002\u4f7f\u7528 --help \u53c2\u6570\u53ef\u4ee5\u83b7\u53d6\u4f7f\u7528\u5e2e\u52a9\u3002\u4f7f\u7528\u5148\u9700\u8981\u5b89\u88c5 Python3 \u548c aiohttp\uff08 pip install aiohttp -i https://pypi.tuna.tsinghua.edu.cn/simple/ \uff09\u3002\u4f9d\u4e91\u535a\u5ba2\u7684\u4ecb\u7ecd\uff1a \u5bfb\u627e\u6700\u5feb\u7684 GitHub IP \u3002 \u540c\u65f6\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 Gitclone \u670d\u52a1\u52a0\u901f Clone\uff0c\u53ef\u4ee5\u9605\u8bfb\u5176\u9996\u9875\u4e0a\u7684\u8bf4\u660e\u3002 \u5982\u679c\u60a8\u4ec5\u4ec5\u662f\u60f3 Clone OI Wiki \u7684\u4ed3\u5e93\uff0c\u90a3\u4e48\uff1a git clone https://gitclone.com/github.com/OI-wiki/OI-wiki \u5982\u679c\u60a8\u9700\u8981\u5411 OI Wiki \u8d21\u732e\uff0c\u90a3\u4e48\u9996\u5148 fork OI Wiki \u7684\u4ed3\u5e93\uff0c\u7136\u540e\uff08\u5c06 username \u66ff\u6362\u4e3a\u60a8\u7684\u7528\u6237\u540d\uff09\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\u63d0\u4f9b\u7684\u793a\u4f8b\u5c06\u4f7f\u60a8\u4f7f\u7528 SSH \u8fde\u63a5\u5230 GitHub[^only-ssh-connect]\uff1a git clone https://gitclone.com/github.com/username/OI-wiki git remote set-url origin git@github.com:username/OI-wiki.git Q\uff1a\u6211\u8fd9\u91cc pip \u4e5f\u592a\u6162\u4e86\uff01 A\uff1a\u53ef\u4ee5\u9009\u62e9\u66f4\u6362\u56fd\u5185\u6e90[^ref2]\uff0c\u6216\u8005\uff1a pip install -U -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/ Q\uff1a\u6211\u5728\u5ba2\u6237\u7aef clone \u4e86\u8fd9\u4e2a\u9879\u76ee\uff0c\u901f\u5ea6\u592a\u6162\u3002 A\uff1a\u5982\u679c\u6709\u5b89\u88c5 git bash \uff0c\u53ef\u4ee5\u52a0\u51e0\u4e2a\u9650\u5236\u6765\u51cf\u5c11\u4e0b\u8f7d\u91cf\u3002[^ref3] git clone https://github.com/OI-wiki/OI-wiki.git --depth = 1 -b master Q\uff1a\u6211\u6ca1\u88c5\u8fc7 Python 3\u3002 A\uff1a\u53ef\u4ee5\u8bbf\u95ee Python \u5b98\u7f51 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002 Q\uff1a\u597d\u50cf\u63d0\u793a\u6211 pip \u7248\u672c\u8fc7\u4f4e\u3002 A\uff1a\u8fdb\u5165 cmd/shell \u4e4b\u540e\uff0c\u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\uff1a python -m pip install --upgrade pip Q\uff1a\u6211\u5b89\u88c5\u4f9d\u8d56\u5931\u8d25\u4e86\u3002 A\uff1a\u68c0\u67e5\u4e00\u4e0b\uff1a\u7f51\u7edc\uff1f\u6743\u9650\uff1f\u67e5\u770b\u9519\u8bef\u4fe1\u606f\uff1f Q\uff1a\u6211\u5df2\u7ecf clone \u4e0b\u6765\u4e86\uff0c\u4e3a\u4ec0\u4e48\u90e8\u7f72\u4e0d\u4e86\uff1f A\uff1a\u68c0\u67e5\u4e00\u4e0b\u662f\u5426\u5b89\u88c5\u597d\u4e86\u4f9d\u8d56\uff1f Q\uff1a\u6211 clone \u4e86\u5f88\u4e45\u4e4b\u524d\u7684 repo\uff0c\u600e\u4e48\u66f4\u65b0\u5230\u65b0\u7248\u672c\u5462\uff1f A\uff1a\u8bf7\u53c2\u8003 GitHub \u5b98\u65b9\u7684\u5e2e\u52a9\u9875\u9762 Syncing a fork - GitHub Docs \u3002 Q\uff1a\u5982\u679c\u662f\u88c5\u4e86\u4e4b\u524d\u7684\u4f9d\u8d56\u600e\u4e48\u66f4\u65b0\uff1f A\uff1a\u8bf7\u8f93\u5165\u4ee5\u4e0b\u547d\u4ee4\uff1a pip install -U -r requirements.txt Q\uff1a\u4e3a\u4ec0\u4e48\u6211\u7684 markdown \u683c\u5f0f\u4e71\u4e86\uff1f A\uff1a\u53ef\u4ee5\u67e5\u9605 cyent \u7684\u7b14\u8bb0 \uff0c\u6216\u8005 MkDocs \u4f7f\u7528\u8bf4\u660e \u3002 \u6211\u4eec\u76ee\u524d\u4f7f\u7528 remark-lint \u6765\u81ea\u52a8\u5316\u4fee\u6b63\u683c\u5f0f\uff0c\u53ef\u80fd\u8fd8\u6709\u4e00\u4e9b \u914d\u7f6e \u4e0d\u591f\u597d\u7684\u5730\u65b9\uff0c\u6b22\u8fce\u6307\u51fa\u3002 Q\uff1aGitHub \u662f\u4e0d\u662f\u4e0d\u663e\u793a\u6211\u7684\u6570\u5b66\u516c\u5f0f\uff1f A\uff1a\u662f\u7684\uff0cGitHub \u7684\u9884\u89c8\u4e0d\u663e\u793a\u6570\u5b66\u516c\u5f0f\u3002\u4f46\u662f\u8bf7\u653e\u5fc3\uff0cMkDocs \u662f\u652f\u6301\u6570\u5b66\u516c\u5f0f\u7684\uff0c\u53ef\u4ee5\u6b63\u5e38\u4f7f\u7528\uff0c\u53ea\u8981\u662f MathJax \u652f\u6301\u7684\u53e5\u5f0f\u90fd\u53ef\u4ee5\u4f7f\u7528\u3002 Q\uff1a\u6211\u7684\u6570\u5b66\u516c\u5f0f\u600e\u4e48\u4e71\u7801\u4e86\uff1f A\uff1a\u5982\u679c\u662f\u884c\u95f4\u516c\u5f0f\uff08\u7528\u7684 $$ \uff09\uff0c\u76ee\u524d\u5df2\u77e5\u7684\u95ee\u9898\u662f\u9700\u8981\u5728 $$ \u4e24\u4fa7\u7559\u6709\u7a7a\u884c\uff0c\u4e14 $$ \u8981 \u5355\u72ec \u653e\u5728\u4e00\u884c\u91cc\uff08\u4e14\u4e0d\u8981\u5728\u524d\u52a0\u7a7a\u683c\uff09\u3002\u683c\u5f0f\u5982\u4e0b\uff1a // \u7a7a\u884c $$ a_i $$ // \u7a7a\u884c Q\uff1a\u6211\u7684\u516c\u5f0f\u4e3a\u4ec0\u4e48\u5728\u76ee\u5f55\u91cc\u6ca1\u6709\u6b63\u5e38\u663e\u793a\uff1f\u597d\u50cf\u53cc\u500d\u4e86\u3002 A\uff1a\u662f\u7684\uff0c\u8fd9\u4e2a\u662f python-markdown \u7684\u4e00\u4e2a bug\uff0c\u53ef\u80fd\u8fd1\u671f\u4f1a\u4fee\u590d\u3002 \u5982\u679c\u60f3\u8981\u907f\u514d\u76ee\u5f55\u4e2d\u51fa\u73b0\u53cc\u500d\u516c\u5f0f\uff0c\u53ef\u4ee5\u53c2\u8003 string \u5206\u7c7b\u4e0b SAM \u7684\u76ee\u5f55\u5199\u6cd5 \u3002 \u7ed3\u675f\u4f4d\u7f6e <script type=\"math/tex\">endpos</script> \u5728\u76ee\u5f55\u4e2d\u4f1a\u53d8\u6210 \u7ed3\u675f\u4f4d\u7f6e endpos \u6ce8\uff1a\u73b0\u5728\u8bf7\u5c3d\u91cf\u907f\u514d\u5728\u76ee\u5f55\u4e2d\u5f15\u5165 MathJax \u516c\u5f0f\u3002 Q\uff1a\u5982\u4f55\u7ed9\u4e00\u4e2a\u9875\u9762\u5355\u72ec\u58f0\u660e\u7248\u6743\u4fe1\u606f\uff1f A\uff1a\u5728\u9875\u9762\u5f00\u5934\u52a0\u4e00\u884c\u5373\u53ef\u3002[^ref4] \u6bd4\u5982\uff1a copyright: SATA \u6ce8\uff1a\u9ed8\u8ba4\u7684\u662f CC BY-SA 4.0 \u548c SATA\u3002 Q\uff1a\u4e3a\u4ec0\u4e48\u4f5c\u8005\u4fe1\u606f\u7edf\u8ba1\u5904\u6ca1\u6709\u6211\u7684\u540d\u5b57\uff1f A\uff1a\u5982\u679c\u4f60\u53d1\u73b0\u81ea\u5df1\u5199\u8fc7\u4e00\u4e2a\u9875\u9762\u4e2d\u7684\u90e8\u5206\u5185\u5bb9\uff0c\u4f46\u662f\u4f60\u6ca1\u6709\u88ab\u8bb0\u5f55\u8fdb\u4f5c\u8005\u5217\u8868\uff0c\u53ef\u4ee5\u628a\u81ea\u5df1\u7684 GitHub ID \u52a0\u5165\u5230\u6587\u4ef6\u5934\u7684 author \u5b57\u6bb5 \u3002 \u611f\u8c22\u4f60\u770b\u5230\u4e86\u6700\u540e\uff0c\u6211\u4eec\u73b0\u5728\u4e9f\u9700\u7684\uff0c\u5c31\u662f\u4f60\u7684\u5e2e\u52a9\u3002 OI Wiki \u9879\u76ee\u7ec4 2018.8","title":"\u6211\u60f3\u53c2\u4e0e\u8fdb\u6765\uff01"},{"location":"intro/faq.html#_2","text":"[^ref2]: \u66f4\u6539 pip \u6e90\u81f3\u56fd\u5185\u955c\u50cf - L \u745c - CSDN \u535a\u5ba2 [^ref3]: GIT--- \u770b\u6211\u4e00\u6b65\u6b65\u5165\u95e8\uff08Windows Git Bash\uff09 [^ref4]: Metadata - Material for MkDocs [^only-ssh-connect]: GitHub \u5f03\u7528\u4e86\u57fa\u4e8e\u5bc6\u7801\u8eab\u4efd\u9a8c\u8bc1\u7684 HTTPS \u534f\u8bae\uff0c\u8fde\u63a5\u5fc5\u987b\u4f7f\u7528 SSH \u6216\u8005 Personal Access Token\uff0c\u53c2\u89c1 \u6211\u5e94\u4f7f\u7528\u54ea\u4e2a\u8fdc\u7a0b URL\uff1f \uff0c \u521b\u5efa\u4e2a\u4eba\u8bbf\u95ee\u4ee4\u724c \u548c \u4f7f\u7528 SSH \u8fde\u63a5\u5230 GitHub \u3002","title":"\u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca"},{"location":"intro/format.html","text":"\u5728\u6587\u7ae0\u5f00\u59cb\u4e4b\u524d\uff0c OI Wiki \u9879\u76ee\u7ec4\u5168\u4f53\u6210\u5458\u5341\u5206\u6b22\u8fce\u60a8\u4e3a\u672c\u9879\u76ee\u8d21\u732e\u9875\u9762\u3002\u6b63\u56e0\u4e3a\u6709\u4e86\u4e0a\u767e\u4f4d\u50cf\u60a8\u4e00\u6837\u7684\u4eba\uff0c\u624d\u6709\u4e86 OI Wiki \u7684\u4eca\u5929\uff01 \u672c\u9875\u9762\u5c06\u5217\u51fa\u5728 OI Wiki \u7f16\u5199\u8fc7\u7a0b\u65f6\u63a8\u8350\u4f7f\u7528\u7684\u683c\u5f0f\u89c4\u8303\u4e0e\u7f16\u8f91\u65b9\u9488\u3002\u8bf7\u60a8\u5728\u64b0\u7a3f\u6216\u8005\u4fee\u6b63 Wiki \u9875\u9762\u4ee5\u524d\uff0c\u4ed4\u7ec6\u9605\u8bfb\u4ee5\u4e0b\u5185\u5bb9\uff0c\u4ee5\u5e2e\u52a9\u60a8\u5b8c\u6210\u66f4\u9ad8\u8d28\u91cf\u7684\u5185\u5bb9\u3002 \u5982\u679c\u60a8\u5df2\u8feb\u4e0d\u53ca\u5f85\uff0c\u60f3\u8981\u5feb\u901f\u4e0a\u624b\uff0c\u5efa\u8bae\u5148\u9605\u8bfb\u56fe\u7247\u4e3e\u4f8b\u7684\u7ae0\u8282\u3002 \u8d21\u732e\u6587\u6863\u8981\u6c42 \u00b6 \u5f53\u4f60\u6253\u7b97\u8d21\u732e\u67d0\u90e8\u5206\u7684\u5185\u5bb9\u65f6\uff0c\u4f60\u5e94\u8be5\u5c3d\u91cf\u719f\u6089\u4ee5\u4e0b\u4e09\u90e8\u5206\uff1a \u6587\u6863\u5b58\u50a8\u7684\u683c\u5f0f \u6587\u6863\u7684\u5408\u7406\u6027 remark-lint \u548c $\\rm{\\LaTeX}$ \u516c\u5f0f\u7684\u683c\u5f0f\u8981\u6c42 \u6587\u6863\u5f15\u7528\u4e0e\u5b58\u50a8\u7684\u683c\u5f0f \u00b6 \u6587\u4ef6\u540d\u8bf7\u52a1\u5fc5\u90fd\u5c0f\u5199\uff0c\u4ee5 - \u5206\u5272\u3002 \u4f8b\u5982\uff1a file-name.md \u3002 \u8bf7\u52a1\u5fc5\u786e\u4fdd\u6587\u6863\u4e2d\u5f15\u7528\u7684 \u5916\u94fe \u56fe\u7247\u5df2\u7ecf\u5168\u90e8\u8f6c\u5b58\u5230\u4e86 \u672c\u5e93\u5185 \u5bf9\u5e94\u7684 images \u6587\u4ef6\u5939\u4e2d\uff08\u9632\u6b62\u89e6\u53d1\u67d0\u4e9b\u7f51\u7ad9\u7684\u9632\u76d7\u94fe\uff09\uff0c\u5efa\u8bae\u5904\u7406\u6210 MD \u6587\u6863\u540d\u79f0 + \u7f16\u53f7 \u7684\u5f62\u5f0f\uff08\u53ef\u53c2\u8003\u5df2\u6709\u6587\u6863\u4e2d\u56fe\u7247\u7684\u5904\u7406\u65b9\u5f0f\uff09\u3002\u4f8b\u5982\uff1a\u672c\u7bc7\u6587\u6863\u7684\u6587\u4ef6\u540d\u79f0\u4e3a format\uff0c\u5219\u6587\u6863\u4e2d\u5f15\u7528\u7684\u7b2c\u4e00\u5f20\u56fe\u7247\u7684\u540d\u5b57\u4e3a format1.png \u3002 \u63a8\u8350\u4f7f\u7528 SVG \u683c\u5f0f\u7684\u56fe\u7247 ^ref4 \uff0c\u4ee5\u83b7\u53d6\u8f83\u597d\u7684\u6e05\u6670\u5ea6\u548c\u7f29\u653e\u6548\u679c\u3002 \u52a8\u56fe\u5982\u679c\u65e0\u6cd5\u6216\u8005\u4e0d\u4f1a\u5236\u4f5c SVG \u683c\u5f0f\u7684\uff0c\u5219\u63a8\u8350\u4f7f\u7528 APNG \u683c\u5f0f ^apng \u7684\u6587\u4ef6\u3002Windows \u7528\u6237\u53ef\u4f7f\u7528 ScreenToGif \u5f55\u5236\uff0cLinux \u7528\u6237\u53ef\u4f7f\u7528 Peek \u5f55\u5236\uff0c\u6ce8\u610f\u9700\u8981\u5728\u8bbe\u7f6e\u91cc\u8c03\u6574\u4e3a\u5f55\u5236 APNG\u3002\u5176\u4ed6\u60c5\u51b5\u5219\u63a8\u8350\u5148\u5236\u4f5c\u4e3a MP4 \u7b49\u89c6\u9891\u6587\u4ef6\u518d\u8f6c\u6362\u4e3a APNG\uff0c\u5982\u679c\u4f7f\u7528 ffmpeg \u5219\u53ef\u4ee5\u4f7f\u7528 ffmpeg -i filename.mp4 -f apng filename.apng -plays 0 \u8f6c\u6362\u3002 ^intro-apng \u540c\u65f6\u5177\u6709\u6e90\u6587\u4ef6\u548c\u5bfc\u51fa\u56fe\u50cf\u7684\u56fe\u7247\uff08\u4f8b\u5982 JPG \u6587\u4ef6\u4e0e PSD \u6587\u4ef6\u6216\u8005 SVG \u56fe\u50cf\u4e0e TikZ TeX \u6e90\u4ee3\u7801\uff09\uff0c\u5efa\u8bae\u5c06\u6e90\u6587\u4ef6\u4ee5\u4e0e\u56fe\u7247\u76f8\u540c\u7684\u6587\u4ef6\u540d\u4fdd\u5b58\u4e8e\u540c\u4e00\u76ee\u5f55\u4e0b\u3002 \u8bf7\u786e\u4fdd\u60a8\u7684\u6587\u6863\u4e2d\u7684\u5f15\u7528\u94fe\u63a5\u7684\u7a33\u5b9a\u6027\u3002 \u4e0d\u63a8\u8350 \u5f15\u7528 \u81ea\u5efa \u670d\u52a1\u4e2d\u7684\u8d44\u6e90\uff08\u5982\u81ea\u5efa OJ \u91cc\u7684\u9898\u76ee\uff09\u3002\u5efa\u8bae\u5728\u6dfb\u52a0\u65f6\u540c\u65f6\u5c06\u8be5\u5916\u94fe\u5b58\u4e8e\u4e92\u8054\u7f51\u6863\u6848\u9986[^webarchive]\uff0c\u4ee5\u9632\u65e0\u6cd5\u66ff\u4ee3\u7684\u94fe\u63a5\u5931\u6548\u3002 \u7ad9\u5185\u94fe\u63a5\u8bf7\u53bb\u6389\u7f51\u7ad9\u57df\u540d\uff0c\u5e76\u4e14\u4f7f\u7528\u76f8\u5bf9\u8def\u5f84\u94fe\u63a5\u5bf9\u5e94 .md \u6587\u4ef6\u3002\u4f8b\u5982\uff0c\u5728\u672c\u9875\u9762\uff08 intro/format \uff09\u4e2d\u94fe\u63a5\u6742\u9879\u7b80\u4ecb\uff08 misc \uff09\uff0c\u5e94\u4f7f\u7528 [\u6742\u9879\u7b80\u4ecb](../misc/index.md) \u3002\u53ef\u4ee5\u5728\u94fe\u63a5\u4e2d\u6dfb\u52a0 hash \u6765\u94fe\u63a5\u5230\u67d0\u4e00\u8282\uff0c\u4f8b\u5982 [Pull Request \u4fe1\u606f\u683c\u5f0f\u89c4\u8303](./htc.md#pull-request-\u4fe1\u606f\u683c\u5f0f\u89c4\u8303) \uff0chash \u7684\u503c\u53ef\u4ee5\u901a\u8fc7\u4f4d\u4e8e\u6bcf\u4e2a\u6807\u9898\u53f3\u4fa7\u7684\u6309\u94ae\u6216\u8005\u4f4d\u4e8e\u7f51\u9875\u53f3\u4fa7\u7684\u76ee\u5f55\u4e2d\u7684\u94fe\u63a5\u5f97\u5230\u3002 \u6587\u6863\u7684\u5408\u7406\u6027 \u00b6 \u5408\u7406\u6027 \uff0c\u6307\u6240\u7f16\u5199\u7684 \u5185\u5bb9 \u5fc5\u987b\u5177\u6709\u5982\u4e0b\u7684\u7279\u6027\uff1a \u7531\u6d45\u5165\u6df1\uff0c\u5185\u5bb9\u7684\u96be\u5ea6\u5e94\u8be5\u5177\u6709\u6e10\u8fdb\u6027\u3002 \u903b\u8f91\u6027\u3002 \u5bf9\u4e8e\u7b97\u6cd5\u6216\u6570\u5b66\u6982\u5ff5\u7c7b\u5185\u5bb9\u7684\u64b0\u5199\u5e94\u8be5\u5c3d\u91cf\u5305\u542b\u4ee5\u4e0b\u7684\u5185\u5bb9\uff1a \u539f\u7406\uff1a\u8bf4\u660e\u8be5\u5185\u5bb9\u5bf9\u5e94\u7684\u539f\u7406\uff1b \u4f8b\u5b50\uff1a\u7ed9\u51fa 1 \\~ 2 \u4e2a\u5178\u578b\u7684\u4f8b\u5b50\uff1b \u9898\u76ee\uff1a\u5728\u8be5\u6807\u9898\u4e0b\uff0c \u53ea\u9700\u8981\u7ed9\u51fa\u9898\u76ee\u540d\u5b57\u548c\u9898\u76ee\u94fe\u63a5 \u3002\u5bf9\u4e8e\u7b97\u6cd5\u7c7b\u9898\u76ee\uff0c\u9898\u76ee\u94fe\u63a5 OJ \u7684\u4f18\u5148\u7ea7\u4e3a\uff1a\u539f OJ\uff08\u56fd\u5916 OJ \u8981\u6c42\u56fd\u5185\u53ef\u6d41\u7545\u8bbf\u95ee\uff09> UOJ > LOJ > \u6d1b\u8c37\u3002 \u793a\u4f8b\u9875\u9762\uff1a IDA* \u5bf9\u4e8e\u5de5\u5177\u7c7b\u5185\u5bb9\u7684\u64b0\u5199\u5e94\u8be5\u5c3d\u91cf\u5305\u542b\u4ee5\u4e0b\u7684\u5185\u5bb9\uff1a \u7b80\u4ecb\uff1a\u9610\u660e\u8be5\u5de5\u5177\u7684\u80cc\u666f\u4e0e\u7528\u9014\u3002 \u914d\u7f6e\u65b9\u5f0f\uff1a\u8be6\u7ec6\u7ed9\u51fa\u914d\u7f6e\u73af\u5883\u4e0e\u4f7f\u7528\u7684\u8fc7\u7a0b\uff0c\u4e0b\u8f7d\u4e0e\u5b89\u88c5\u65b9\u6cd5\u5efa\u8bae\u5c3d\u91cf\u5f15\u7528\u5b98\u65b9\u6587\u6863\u3002 \u793a\u4f8b\u9875\u9762\uff1a WSL (Windows 10) \u9664\u73b0\u6709\u5185\u5bb9\u8d28\u91cf\u8f83\u4f4e\u7684\u60c5\u51b5\u5916\uff0c\u5efa\u8bae\u5c3d\u91cf\u4ece \u8865\u5145 \u7684\u89d2\u5ea6\u6765\u505a\u8d21\u732e\uff0c\u800c\u975e\u91c7\u53d6\u76f4\u63a5\u8986\u76d6\u7684\u65b9\u5f0f\u3002\u5982\u679c\u62ff\u4e0d\u51c6\u4e3b\u610f\uff0c\u53ef\u4ee5\u53c2\u8003 \u5173\u4e8e\u672c\u9879\u76ee\u7684\u4ea4\u6d41\u65b9\u5f0f \u4e00\u8282\uff0c\u4e0e OI Wiki \u9879\u76ee\u7ec4\u8054\u7cfb\u3002 \u6587\u6863\u7684\u57fa\u672c\u683c\u5f0f\u8981\u6c42 \u00b6 Remark-lint \u7684\u683c\u5f0f\u8981\u6c42 \u00b6 remark-lint \u53ef\u4ee5\u81ea\u52a8\u7ed9\u9879\u76ee\u5185\u6587\u4ef6\u7edf\u4e00\u98ce\u683c\u3002 OI Wiki \u73b0\u5728\u542f\u7528\u7684\u914d\u7f6e\u6587\u4ef6\u6258\u7ba1\u5728 .remarkrc \u3002 \u5728\u914d\u7f6e\u8fc7\u7a0b\u4e2d OI Wiki \u9879\u76ee\u7ec4\u4e5f\u9047\u5230\u4e86\u4e00\u4e9b remark-lint \u4e0d\u80fd\u5f88\u597d\u5904\u7406\u7684\u95ee\u9898\uff0c\u6240\u4ee5\u8bf7\u4e25\u683c\u6309\u7167\u4e0b\u5217\u8981\u6c42\u7f16\u8f91\u6587\u6863\uff1a \u4e0d\u8981\u4f7f\u7528\u5982 <h1> \u6216\u8005 # \u6807\u9898 \u7684\u4e00\u7ea7\u6807\u9898\u3002 \u6807\u9898\u8981\u7a7a\u4e00\u4e2a\u82f1\u6587\u534a\u89d2\u7a7a\u683c\uff0c\u4f8b\u5982\uff1a ## \u7b80\u4ecb \u3002 \u7531\u4e8e remark-lint \u4e0d\u80fd\u5f88\u597d\u5730\u5904\u7406\u5220\u9664\u7ebf\uff0c\u56e0\u6b64\u8bf7\u4e0d\u8981\u4f7f\u7528\u5220\u9664\u7ebf\u8bed\u6cd5\uff08\u4e0d\u4f7f\u7528\u5220\u9664\u7ebf\u8bed\u6cd5\u7684\u53e6\u5916\u4e00\u4e2a\u539f\u56e0\u662f\uff0c\u5220\u9664\u7ebf\u5212\u53bb\u7684\u5185\u5bb9\u5927\u591a\u4e3a\u300c\u6296\u673a\u7075\u300d\u6027\u8d28\uff0c\u5bf9\u8bfb\u8005\u7406\u89e3\u5e2e\u52a9\u4e0d\u5927\uff0c\u4e0d\u7b26\u5408\u4e0b\u9762\u7684\u300c\u6587\u672c\u5185\u5bb9\u7684\u683c\u5f0f\u8981\u6c42\u300d\u4e2d\u5bf9\u5185\u5bb9\u8868\u8ff0\u7684\u8981\u6c42\uff09\u3002 \u5217\u8868\uff1a \u5217\u8868\u524d\u8981\u6709\u7a7a\u884c\uff0c\u65b0\u5f00\u4e00\u6bb5\u3002 \u4f7f\u7528\u6709\u5e8f\u5217\u8868\uff08\u5982 1. \u4f8b\u5b50 \uff09\u65f6\uff0c\u70b9\u53f7\u540e\u8981\u6709\u7a7a\u683c\u3002 \u884c\u95f4\u516c\u5f0f\u524d\u540e\u5404\u8981\u6709\u4e00\u884c\u7a7a\u884c\uff0c\u5426\u5219\u4f1a\u88ab\u5f53\u505a\u662f\u884c\u5185\u516c\u5f0f\u3002 \u4f7f\u7528 ??? \u6216 !!! \u5f00\u5934\u7684 Details \u8bed\u6cd5\u65f6\uff0c\u6bcf\u4e00\u884c\u8981\u5305\u62ec\u5728 Details \u8bed\u6cd5\u7684\u6587\u672c\u6846\u7684\u6587\u672c\uff0c\u5f00\u5934\u5fc5\u987b\u81f3\u5c11\u6709 4 \u4e2a\u7a7a\u683c\u3002 \u5373\u4f7f\u662f\u7a7a\u884c\uff0c\u4e5f\u5fc5\u987b\u4fdd\u6301\u4e0e\u5176\u4ed6\u884c\u4e00\u81f4\u7684\u7f29\u8fdb\u3002\u8bf7\u4e0d\u8981\u4f7f\u7528\u7f16\u8f91\u5668\u7684\u81ea\u52a8\u88c1\u526a\u884c\u672b\u7a7a\u683c\u529f\u80fd\u3002 \u793a\u4f8b ???+ warning \u8bf7\u8bb0\u5f97\u5728\u6587\u672c\u524d\u9762\u6dfb\u52a0 4 \u4e2a\u7a7a\u683c\u3002\u5176\u4ed6\u7684\u8bed\u6cd5\u8fd8\u662f\u4e0e Markdown \u8bed\u6cd5\u4e00\u81f4\u3002 \u4e0d\u6dfb\u52a0 4 \u4e2a\u7a7a\u683c\u7684\u8bdd\uff0c\u6587\u672c\u5c31\u4e0d\u4f1a\u51fa\u73b0\u5728 Details \u6587\u672c\u6846\u91cc\u4e86\u3002 \u8fd9\u4e2a`???`\u662f\u4ec0\u4e48\u7684\u95ee\u9898\u4f1a\u5728\u4e0b\u6587\u89e3\u7b54\u3002 Warning \u8bf7\u8bb0\u5f97\u5728\u6587\u672c\u524d\u9762\u6dfb\u52a0 4 \u4e2a\u7a7a\u683c\u3002\u5176\u4ed6\u7684\u8bed\u6cd5\u8fd8\u662f\u4e0e Markdown \u8bed\u6cd5\u4e00\u81f4\u3002 \u4e0d\u6dfb\u52a0 4 \u4e2a\u7a7a\u683c\u7684\u8bdd\uff0c\u6587\u672c\u5c31\u4e0d\u4f1a\u51fa\u73b0\u5728 Details \u6587\u672c\u6846\u91cc\u4e86\u3002 \u8fd9\u4e2a ??? \u662f\u4ec0\u4e48\u7684\u95ee\u9898\u4f1a\u5728\u4e0b\u6587\u89e3\u7b54\u3002 \u4ee3\u7801\u6837\u5f0f\u7684\u7eaf\u6587\u672c\u5757\u8bf7\u4f7f\u7528 ```text \u3002\u76f4\u63a5\u4f7f\u7528 ``` \u800c\u4e0d\u6307\u5b9a\u7eaf\u6587\u672c\u5757\u91cc\u7684\u8bed\u8a00\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u5185\u5bb9\u88ab\u9519\u8bef\u5730\u7f29\u8fdb\u3002 \u6807\u70b9\u7b26\u53f7\u7684\u4f7f\u7528 \u00b6 \u8bf7\u5728\u6bcf\u53e5\u8bdd\u7684\u672b\u5c3e\u6dfb\u52a0 \u53e5\u53f7 \u3002 \u8bf7\u6b63\u786e\u4f7f\u7528 \u5168\u89d2 \u6807\u70b9\u7b26\u53f7\u4e0e \u534a\u89d2 \u6807\u70b9\u7b26\u53f7\u3002\u6c49\u8bed\u8bf7\u4f7f\u7528\u5168\u89d2\u7b26\u53f7\uff0c\u82f1\u8bed\u8bf7\u4f7f\u7528\u534a\u89d2\u7b26\u53f7\u3002\u4e2d\u6587\u4e2d\u5939\u7528\u82f1\u6587\u65f6\uff0c\u8bf7\u53c2\u8003 \u4e2d\u6587\u51fa\u7248\u7269\u5939\u7528\u82f1\u6587\u7684\u7f16\u8f91\u89c4\u8303 \u3002 \u7531\u4e8e \u201c\u2026\u2026\u201d \u672a\u533a\u5206\u5168\u534a\u89d2\uff0c\u8bf7\u4f7f\u7528 \u300c\u2026\u2026\u300d \u4f5c\u4e3a\u5168\u89d2\u5f15\u53f7\uff0c \"...\" \u4f5c\u4e3a\u534a\u89d2\u5f15\u53f7\u3002 \u6ce8\u610f\u533a\u5206 \u987f\u53f7 \u4e0e \u9017\u53f7 \u7684\u4f7f\u7528\u3002 \u6ce8\u610f \u62ec\u53f7 \u7684\u4f4d\u7f6e\u3002\u53e5\u5185\u62ec\u53f7\u4e0e\u53e5\u5916\u62ec\u53f7\u7684\u4f4d\u7f6e\u4e0d\u540c\u3002 \u901a\u5e38\u4f7f\u7528 \u5206\u53f7 \u6765\u8868\u793a\u5217\u8868\u73af\u5883\u4e2d\u5404\u590d\u53e5\u4e4b\u95f4\u7684\u5173\u7cfb\u3002 \u5bf9\u4e8e\u6709\u5e8f\u5217\u8868\uff0c\u63a8\u8350\u5728\u6bcf\u4e00\u9879\u7684\u540e\u9762\u6dfb\u52a0 \u5206\u53f7 \uff0c\u5728\u5217\u8868\u6700\u540e\u4e00\u9879\u7684\u540e\u9762\u6dfb\u52a0 \u53e5\u53f7 \uff1b\u5bf9\u4e8e\u65e0\u5e8f\u5217\u8868\uff0c\u63a8\u8350\u5728\u6bcf\u4e00\u9879\u7684\u540e\u9762\u6dfb\u52a0 \u53e5\u53f7 \u3002 \u6ce8\u610f\u533a\u5206\u5404\u79cd\u4e0d\u540c\u7684\u8fde\u63a5\u53f7\uff0c\u5982 hyphen\uff08\u4e00\u822c\u4f7f\u7528 U+002D hyphen-minus\uff08-\uff09\uff0c\u5373\u952e\u76d8\u4e0a\u7684\u300c\u51cf\u53f7\u300d\u4ee3\u66ff\uff09\uff0cU+2013 en dash\uff08\u2013\uff09\u548c U+2014 em dash\uff08\u2014\uff09\u3002\uff08\u82f1\u6587\u4e2d\u8fde\u63a5\u591a\u4e2a\u4eba\u540d\u65f6\uff0c\u987b\u7528 en dash\uff0c\u4f46\u662f\u6781\u5e38\u8bef\u7528\u4e3a hyphen\u3002\u5176\u4ed6\u8bef\u7528\u8f83\u4e3a\u7f55\u89c1\uff0c\u57fa\u672c\u4e0a\u53ea\u9700\u8bb0\u4f4f\u8fd9\u4e00\u70b9\u5373\u53ef\u3002\uff09\u8be6\u89c1 \u8fde\u63a5\u53f7 - \u7ef4\u57fa\u767e\u79d1 \u3002 \u793a\u4f8b \u4e2d\u5b66\u751f\u5b66\u79d1\u7ade\u8d5b\u4e3b\u8981\u5305\u62ec\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\u3001\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\u3001\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\u3001\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\u548c\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\uff08\u8c01\u5199\u7684\u8fd9\u4e2a\u793a\u4f8b\uff0c\u5efa\u8bae\u62ac\u8d70\uff09\u3002 \u300c\u4f60\u5403\u4e86\u5417\uff1f\u300d\u674e\u56db\u95ee\u5f20\u4e09\u3002 \u6211\u60f3\u5bf9\u4f60\u8bf4\uff1a\u300c\u6211\u771f\u662f\u592a\u559c\u6b22\u4f60\u4e86\u3002\u300d \u300c\u82df\u5229\u56fd\u5bb6\u751f\u6b7b\u4ee5\uff0c\u5c82\u56e0\u7978\u798f\u907f\u8d8b\u4e4b\uff01\u300d \u5f20\u534e\u8003\u4e0a\u4e86\u5927\u5b66\uff1b\u674e\u840d\u8fdb\u4e86\u6280\u6821\uff1b\u6211\u5f53\u4e86\u5de5\u4eba\uff1a\u6211\u4eec\u90fd\u6709\u7f8e\u597d\u7684\u524d\u9014\u3002 ^note1 \u4ee5\u4e0b\u662f\u8fd9\u4e2a\u7b97\u6cd5\u7684\u57fa\u672c\u6d41\u7a0b\uff1a \u521d\u59cb\u5316\u5230\u5404\u70b9\u7684\u8ddd\u79bb\u4e3a\u65e0\u7a77\u5927\uff0c\u5c06\u6240\u6709\u70b9\u8bbe\u7f6e\u4e3a\u672a\u88ab\u8bbf\u95ee\u8fc7\uff0c\u521d\u59cb\u5316\u4e00\u4e2a\u961f\u5217\uff1b \u5c06\u8d77\u70b9\u653e\u5165\u961f\u5217\uff0c\u5c06\u8d77\u70b9\u8bbe\u7f6e\u4e3a\u5df2\u88ab\u8bbf\u95ee\u8fc7\uff0c\u66f4\u65b0\u5230\u8d77\u70b9\u7684\u8ddd\u79bb\u4e3a $0$ \uff1b \u53d6\u51fa\u961f\u9996\u5143\u7d20\uff0c\u5c06\u8be5\u5143\u7d20\u8bbe\u7f6e\u4e3a\u672a\u88ab\u8bbf\u95ee\u8fc7\uff1b \u904d\u5386\u6240\u6709\u4e0e\u6b64\u5143\u7d20\u76f8\u8fde\u7684\u8fb9\uff0c\u82e5\u5230\u8fd9\u4e2a\u70b9\u5b58\u5728\u66f4\u77ed\u7684\u8ddd\u79bb\uff0c\u5219\u8fdb\u884c\u677e\u5f1b\u64cd\u4f5c\uff1b \u82e5\u8fd9\u4e2a\u70b9\u672a\u88ab\u8bbf\u95ee\u8fc7\uff0c\u5219\u5c06\u8fd9\u4e2a\u70b9\u653e\u5165\u961f\u5217\uff0c\u4e14\u8bbe\u7f6e\u8fd9\u4e2a\u70b9\u4e3a\u5df2\u7ecf\u8bbf\u95ee\u8fc7\uff1b \u56de\u5230\u7b2c\u4e09\u6b65\uff0c\u76f4\u5230\u961f\u5217\u4e3a\u7a7a\u3002 KMP \u7b97\u6cd5\uff08Knuth\u2013Morris\u2013Pratt algorithm, KMP algorithm\uff09\u7531 Knuth\u3001Pratt \u548c Morris \u5728 1977 \u5e74\u5171\u540c\u53d1\u5e03\u3002 ^note2 Markdown \u683c\u5f0f\u4e0e\u4e3b\u9898\u6269\u5c55\u683c\u5f0f\u8981\u6c42 \u00b6 \u8868\u793a\u5f3a\u8c03\u65f6\u8bf7\u4f7f\u7528 **SOMETHING** \u548c \u300c\u300d \uff0c\u800c\u975e\u67d0\u7ea7\u6807\u9898\uff0c\u56e0\u4e3a\u4f7f\u7528\u6807\u9898\u4f1a\u5bfc\u81f4\u6587\u7ae0\u7ed3\u6784\u5c42\u6b21\u6df7\u4e71\u548c\uff08\u6216\uff09\u76ee\u5f55\u51fa\u73b0\u95ee\u9898\u3002 \u5f53\u9700\u8981\u5f15\u7528\u9898\u76ee\u94fe\u63a5\u65f6\uff0c\u5e94\u5c3d\u53ef\u80fd\u4f7f\u7528\u539f OJ \u9898\u5e93\u4e2d\u7684\u94fe\u63a5\u800c\u4e0d\u662f\u955c\u50cf\u94fe\u63a5\u3002 \u8bf7\u6b63\u786e\u4f7f\u7528 Markdown \u7684\u533a\u5757\u529f\u80fd\u3002\u63d2\u5165\u884c\u5185\u4ee3\u7801\u8bf7\u4f7f\u7528\u4e00\u5bf9\u53cd\u5f15\u53f7\u5305\u56f4\u4ee3\u7801\u533a\u5757\uff1b\u884c\u95f4\u4ee3\u7801\u8bf7\u4f7f\u7528\u4e00\u5bf9 ``` \u5305\u56f4\u4ee3\u7801\u533a\u5757\uff0c\u5176\u4e2d\u53cd\u5f15\u53f7\u5c31\u662f\u952e\u76d8\u5de6\u4e0a\u89d2\u6ce2\u6d6a\u7ebf\u4e0b\u9762\u90a3\u4e2a\u7b26\u53f7\uff0c\u884c\u95f4\u4ee3\u7801\u8bf7\u5728\u7b2c\u4e00\u4e2a ``` \u7684\u540e\u9762\u52a0\u4e0a\u8bed\u8a00\u540d\u79f0\uff08\u5982\uff1a ```cpp \uff09\u3002 \u793a\u4f8b ```cpp // #include<stdio.h> //\u4e0d\u597d\u7684\u5199\u6cd5 #include <cstdio> //\u597d\u7684\u5199\u6cd5 ``` // #include<stdio.h> //\u4e0d\u597d\u7684\u5199\u6cd5 #include <cstdio> //\u597d\u7684\u5199\u6cd5 \u300c\u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca\u300d\u4f7f\u7528 Markdown \u7684\u811a\u6ce8\u529f\u80fd\u8fdb\u884c\u7f16\u5199\u3002\u683c\u5f0f\u4e3a\uff1a \u6587\u672c\u5185\u5bb9\u3002[^\u811a\u6ce8\u540d] [ ^\u811a\u6ce8\u540d ]: \u53c2\u8003\u8d44\u6599\u5185\u5bb9\u3002\u6ce8\u610f\uff1a\u5192\u53f7\u662f\u82f1\u6587\u5192\u53f7\uff0c\u5192\u53f7\u540e\u9762\u8ddf\u7740\u4e00\u4e2a\u7a7a\u683c\u3002 \u811a\u6ce8\u540d\u65e2\u53ef\u4ee5\u4f7f\u7528\u6570\u5b57\u4e5f\u53ef\u4ee5\u4f7f\u7528\u6587\u672c\u3002\u811a\u6ce8\u540d\u6446\u653e\u7684\u4f4d\u7f6e\u4e0e\u62ec\u53f7\u7684\u7528\u6cd5\u4e00\u81f4\u3002\u4e3a\u7f8e\u89c2\u8d77\u89c1\uff0c\u5efa\u8bae\u540c\u4e00\u4e2a\u9875\u9762\u5185\u7684\u811a\u6ce8\u540d\u9075\u5faa\u7edf\u4e00\u7684\u547d\u540d\u89c4\u5f8b\uff0c\u5982\uff1aref1\u3001ref2\u3001note1\u2026\u2026 \u811a\u6ce8\u7684\u5185\u5bb9\u7edf\u4e00\u653e\u5728 ## \u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca \u4e8c\u7ea7\u6807\u9898\u4e0b\u3002 \u793a\u4f8b \u5f53 `#include <cxxxx>` \u53ef\u4ee5\u66ff\u4ee3 `#include <xxxx.h>` \u65f6\uff0c\u5e94\u4f7f\u7528\u524d\u8005\u3002[^ref1] 2020\u5e741\u670821\u65e5\uff0cCCF\u5ba3\u5e03\u6062\u590dNOIP\u3002[^ref2] ## \u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca [ ^ref1 ]: [cstdio stdio.h namespace](https://stackoverflow.com/questions/10460250/cstdio-stdio-h-namespace) [ ^ref2 ]: [CCF\u5173\u4e8e\u6062\u590dNOIP\u7ade\u8d5b\u7684\u516c\u544a-\u4e2d\u56fd\u8ba1\u7b97\u673a\u5b66\u4f1a](https://www.ccf.org.cn/c/2020-01-21/694716.shtml) \u5f53 #include <cxxxx> \u53ef\u4ee5\u66ff\u4ee3 #include <xxxx.h> \u65f6\uff0c\u5e94\u4f7f\u7528\u524d\u8005\u3002[^ref1] 2020 \u5e74 1 \u6708 21 \u65e5\uff0cCCF \u5ba3\u5e03\u6062\u590d NOIP\u3002[^ref2] \u5efa\u8bae\u4f7f\u7528\u4e3b\u9898\u6269\u5c55\u7684 ???+note \u683c\u5f0f\uff08\u5373 Collapsible Blocks \uff09\u6765\u63cf\u8ff0\u9898\u9762\u548c\u53c2\u8003\u4ee3\u7801\u3002\u4e5f\u53ef\u4ee5\u7528\u8fd9\u79cd\u683c\u5f0f\u6765\u5c55\u793a\u5176\u4ed6\u9700\u8981\u8865\u5145\u4ecb\u7ecd\u7684\u5185\u5bb9\u3002 \u793a\u4f8b\u4ee3\u7801\uff1a ??? note \"\u6807\u9898\" \u8fd9\u4e2a\u6587\u672c\u6846\u4f1a\u88ab\u9ed8\u8ba4\u6298\u53e0\u3002 \u63a8\u8350\u5c06 **\u89e3\u9898\u4ee3\u7801** \u653e\u5728\u6298\u53e0\u6587\u672c\u6846\u5185\u3002 ???+note \"[HDOJ \u7684\u300cA + B Problem\u300d](https://acm.hdu.edu.cn/showproblem.php?pid=1000)\" \u6807\u9898\u4e5f\u53ef\u4ee5\u4f7f\u7528 Markdown \u7684\u8d85\u94fe\u63a5\u3002\u8fd9\u91cc\u7684\u8d85\u94fe\u63a5\u662f HDOJ \u7684\u300cA + B Problem\u300d\u3002 \u800c\u4e14\u63a8\u8350\u4ee5\u8fd9\u79cd\u65b9\u5f0f**\u6807\u6ce8\u539f\u9898\u94fe\u63a5**\u3002 \u6ce8\u610f\u53cc\u5f15\u53f7\u7684\u4f4d\u7f6e\u3002 \u6548\u679c\uff1a \u6807\u9898 \u8fd9\u4e2a\u6587\u672c\u6846\u4f1a\u88ab\u9ed8\u8ba4\u6298\u53e0\u3002 \u63a8\u8350\u5c06 \u89e3\u9898\u4ee3\u7801 \u653e\u5728\u6298\u53e0\u6587\u672c\u6846\u5185\u3002 HDOJ \u7684\u300cA + B Problem\u300d \u6807\u9898\u4e5f\u53ef\u4ee5\u4f7f\u7528 Markdown \u7684\u8d85\u94fe\u63a5\u3002\u8fd9\u91cc\u7684\u8d85\u94fe\u63a5\u662f HDOJ \u7684\u300cA + B Problem\u300d\u3002 \u800c\u4e14\u63a8\u8350\u4ee5\u8fd9\u79cd\u65b9\u5f0f \u6807\u6ce8\u539f\u9898\u94fe\u63a5 \u3002 \u6ce8\u610f\u53cc\u5f15\u53f7\u7684\u4f4d\u7f6e\u3002 \u4e24\u79cd\u683c\u5f0f\u7684\u533a\u522b\u662f\uff0c\u5e26 + \u7684\u4f1a\u9ed8\u8ba4\u4fdd\u6301\u5c55\u5f00\uff0c\u800c\u4e0d\u5e26 + \u7684\u4f1a\u9ed8\u8ba4\u4fdd\u6301\u6298\u53e0\u3002 \u6298\u53e0\u6846\u7684\u6807\u9898\uff0c\u5373 ???+note \u4e2d note \u540e\u7684\u5185\u5bb9\u5e94\u4ee5 \" \u5305\u88f9\u8d77\u6765\u3002\u5176\u4e2d\u7684\u5185\u5bb9\u652f\u6301 Markdown \u8bed\u6cd5\u3002\u8be6\u89c1 Admonition - Changing the title \u3002\uff08\u4e0d\u5177\u5907\u6298\u53e0\u529f\u80fd\u7684\u4e3a\u4e00\u822c\u7684 Admonitions\uff0c\u53c2\u8003 Admonitions - Material for MkDocs \uff09 \u5f53\u9700\u8981\u6dfb\u52a0\u4e0d\u540c\u8bed\u8a00\u7684\u4ee3\u7801\u65f6\uff0c\u63a8\u8350\u4f7f\u7528 Content tabs\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4e0d\u540c\u8bed\u8a00\u4ee3\u7801\u7684\u5207\u6362\u3002Content tabs \u8fd8\u6709\u5176\u4ed6\u7684\u7528\u6cd5\uff0c\u8be6\u89c1 Content tabs \u3002\u5176\u4f7f\u7528\u65b9\u6cd5\u548c\u6548\u679c\u5982\u4e0b\u3002 \u793a\u4f8b \u6ce8\u610f\u9700\u8981\u5728\u6587\u672c\u524d\u9762\u6dfb\u52a0 4 \u4e2a\u7a7a\u683c\u3002\u5176\u4ed6\u7684\u8bed\u6cd5\u8fd8\u662f\u4e0e Markdown \u8bed\u6cd5\u4e00\u81f4\u3002 === \"C\" ``` c #include <stdio.h> int main(void) { printf(\"Hello world!\\n\"); return 0; } ``` === \"C++\" ``` c++ #include <iostream> int main(void) { std::cout << \"Hello world!\" << std::endl; return 0; } ``` C C++ #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } #include <iostream> int main ( void ) { std :: cout << \"Hello world!\" << std :: endl ; return 0 ; } \u5982\u679c\u5bf9 mkdocs-material\uff08\u6211\u4eec\u4f7f\u7528\u7684\u8fd9\u4e2a\u4e3b\u9898\uff09\u8fd8\u6709\u4ec0\u4e48\u95ee\u9898\uff0c\u8fd8\u53ef\u4ee5\u67e5\u9605 MkDocs \u4f7f\u7528\u8bf4\u660e \uff0c\u5176\u4ecb\u7ecd\u4e86 mkdocs-material \u4e3b\u9898\u7684\u63d2\u4ef6\u4f7f\u7528\u65b9\u5f0f\u3002 \u6587\u672c\u5185\u5bb9\u7684\u683c\u5f0f\u8981\u6c42 \u00b6 \u6240\u6709\u7684 OI Wiki \u6587\u672c\u90fd\u5e94\u4f7f\u7528\u7c97\u4f53\u6807\u8bb0\u3002 \u5728\u9875\u9762\u7684\u5f00\u5934\u5e94\u6709\u4e00\u6bb5\u7b80\u77ed\u7684\u6587\u5b57\uff08\u5982\u300c\u672c\u9875\u9762\u5c06\u4ecb\u7ecd\u2026\u2026\u300d\uff09\uff0c\u7528\u4e8e\u6982\u8ff0\u9875\u9762\u5185\u5bb9\u3002 \u793a\u4f8b \u672c\u9875\u9762\u5c06\u5217\u51fa\u5728 OI Wiki \u7f16\u5199\u8fc7\u7a0b\u65f6\u63a8\u8350\u4f7f\u7528\u7684\u683c\u5f0f\u89c4\u8303\u4e0e\u7f16\u8f91\u65b9\u9488\u3002 \u6d89\u53ca\u5230\u300c\u524d\u7f6e\u77e5\u8bc6\u300d\u7684\u9875\u9762\uff0c\u8bf7\u5728\u5f00\u5934\u6dfb\u52a0\u4e00\u884c \u524d\u7f6e\u77e5\u8bc6\uff1a\u2026\u2026 \uff0c\u653e\u5728\u9875\u9762\u6982\u8ff0\u524d\u3002\u683c\u5f0f\u5982\u4e0b\uff1a \u524d\u7f6e\u77e5\u8bc6\uff1a[\u7ad9\u5185\u9875\u97621](url1)\u3001[\u7ad9\u5185\u9875\u97622](url2)\u548c[\u7ad9\u5185\u9875\u97623](url3) \u793a\u4f8b \u524d\u7f6e\u77e5\u8bc6\uff1a \u65f6\u95f4\u590d\u6742\u5ea6 \u672c\u9875\u9762\u5c06\u4ecb\u7ecd\u57fa\u7840\u7684\u8ba1\u7b97\u7406\u8bba\u7684\u77e5\u8bc6\u3002 \u8bf7\u6ce8\u610f\u6587\u6863\u7ed3\u6784\u3002\u6587\u6863\u7ed3\u6784\u5e94\u5f53\u5341\u5206\u6761\u7406\uff0c\u5c42\u6b21\u6e05\u6670\u3002\u8bf7\u4e0d\u8981\u8ba9\u8bf8\u5982\u300c\u4e94\u7ea7\u6807\u9898\u300d\u8fd9\u79cd\u4e8b\u60c5\u518d\u6b21\u53d1\u751f\u4e86\uff0c\u4e00\u7bc7\u6b63\u5e38\u7684\u6587\u7ae0\u662f\u7528\u4e0d\u5230\u5982\u6b64\u590d\u6742\u7684\u7ed3\u6784\u5c42\u6b21\u7684\u3002 \u8bf7\u6ce8\u610f\u5185\u5bb9\u7684\u8868\u8ff0\u3002\u4f5c\u4e3a\u4e00\u4e2a\u767e\u79d1\u7f51\u7ad9\uff0c OI Wiki \u4f7f\u7528\u7684\u8bed\u8a00\u5e94\u8be5\u662f\u4e66\u9762\u7684\uff0c\u5ba2\u89c2\u7684\u3002\u8bf8\u5982\u300c\u6296\u673a\u7075\u300d\u6027\u8d28\u7684\uff0c\u5bf9\u8bfb\u8005\u7406\u89e3\u5e2e\u52a9\u4e0d\u5927\u7684\u5185\u5bb9\uff0c\u4e0d\u5e94\u8be5\u51fa\u73b0\u5728 OI Wiki \u5f53\u4e2d\u3002 \u8bf7\u5c3d\u91cf\u4e3a\u94fe\u63a5\u63d0\u4f9b\u5b8c\u6574\u7684\u6807\u9898\u3001\u6216\u8005\u53ef\u88ab\u8bc6\u522b\u7684\u63d0\u793a\uff0c\u907f\u514d\u4f7f\u7528\u88f8\u5730\u5740\u548c\u300c\u8fd9\u300d\u3001\u300c\u6b64\u300d\u4e4b\u7c7b\u7684\u6a21\u7cca\u4e0d\u6e05\u7684\u63cf\u8ff0\u3002\u6bcf\u4e00\u4e2a\u8d85\u94fe\u63a5\u90fd\u5e94\u5c3d\u91cf\u5bf9\u5176\u52a0\u4ee5\u6e05\u695a\u660e\u786e\u7684\u63cf\u8ff0\uff0c\u65b9\u4fbf\u8bfb\u8005\u660e\u767d\u8be5\u8d85\u94fe\u63a5\u5c06\u6307\u5411\u4f55\u5904\u3002 \u5efa\u8bae\u4f7f\u7528\u6e90\u6587\u7ae0\u6216\u8005\u6807\u7b7e\u9875\u7684\u6807\u9898\u3002 \u4e0d\u63a8\u8350\u7684\u5199\u6cd5 \u8bf7\u53c2\u8003[\u8fd9\u4e2a\u9875\u9762](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) \u8bf7\u53c2\u8003 <https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork> \u8bf7\u53c2\u8003 \u8fd9\u4e2a\u9875\u9762 \u8bf7\u53c2\u8003 https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork \u63a8\u8350\u7684\u5199\u6cd5 \u8bf7\u53c2\u8003 GitHub \u5b98\u65b9\u7684\u5e2e\u52a9\u9875\u9762 [ Syncing a fork - GitHub Docs ]( https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork ) \u8bf7\u53c2\u8003 GitHub \u5b98\u65b9\u7684\u5e2e\u52a9\u9875\u9762 Syncing a fork - GitHub Docs \u53d7 Markdown \u683c\u5f0f\u9650\u5236\uff0c ## \u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca \u4e8c\u7ea7\u6807\u9898\u5fc5\u987b\u653e\u5728\u6587\u672b\u3002 \u6240\u6709\u7528\u4f5c\u5e8f\u53f7\u7684\u6570\u5b57\u5efa\u8bae\u4f7f\u7528\u4e2d\u6587\u3002\u793a\u4f8b\uff1a \u6570\u5217\u7684\u7b2c\u4e00\u9879\u3002 \u8f93\u5165\u6587\u4ef6\u7684\u7b2c\u4e00\u884c\u3002 \u8bf7\u5c3d\u91cf\u907f\u514d\u5728\u6807\u9898\u4e2d\u4f7f\u7528 MathJax \u516c\u5f0f\uff0c\u65e0\u8bba\u662f\u51e0\u7ea7\u6807\u9898\u3002\u5728\u6807\u9898\u4e2d\u4f7f\u7528\u516c\u5f0f\u6709\u53ef\u80fd\u4f1a\u5bfc\u81f4\u76ee\u5f55\u663e\u793a\u9519\u8bef\u3002 ^ref3 \u8bf7\u6ce8\u610f\u4ee3\u7801\u7684\u53ef\u8bfb\u6027\u3002 \u4ee3\u7801\u5e94\u62e5\u6709\u6e05\u6670\u7684\u903b\u8f91\u3002 \u5efa\u8bae\u5728\u53c2\u8003\u4ee3\u7801\u4e2d\u6dfb\u52a0\u9002\u5f53\u6ce8\u91ca\u4ee5\u65b9\u4fbf\u8bfb\u8005\u7406\u89e3\u3002 \u5c3d\u91cf\u907f\u514d\u51fa\u73b0\u5f71\u54cd\u9605\u8bfb\u7684\u9884\u7f16\u8bd1\u6307\u4ee4\u548c\u5b8f\u5b9a\u4e49\u3002 LaTeX \u516c\u5f0f\u7684\u683c\u5f0f\u8981\u6c42 \u00b6 LaTeX \u4f5c\u4e3a\u516c\u5f0f\u6392\u7248\u7684\u9996\u9009\uff0c\u6211\u4eec\u5e94\u5f53\u6b63\u786e\u5730\u4f7f\u7528\u5b83\u3002\u56e0\u6b64\u5bf9\u4e8e LaTeX \u7684\u4f7f\u7528\u6211\u4eec\u6709\u4e25\u683c\u7684\u8981\u6c42\u3002\u5982\u679c\u60a8\u60f3\u8981\u5feb\u901f\u4e0a\u624b\uff0c\u53ef\u4ee5\u9605\u8bfb\u672c\u7ae0\u8282\u672b\u7ed9\u51fa\u7684\u8868\u683c\u3002 \u60a8\u4f7f\u7528\u7684\u7b26\u53f7\u4e0d\u5e94\u4e0e \u6570\u5b66\u7b26\u53f7\u8868 \u89c4\u5b9a\u7684\u7b26\u53f7\u51b2\u7a81\u3002 \u4f7f\u7528 Roman \u4f53\u8868\u793a\u6570\u5b57\u3001\u5e38\u91cf\u3001\u7b97\u5b50\u548c\u51fd\u6570\u3002\u4f7f\u7528 Italic \u4f53\u8868\u793a\u53d8\u91cf\u3001\u4e0b\u6807\u3002LaTeX \u5df2\u7ecf\u9884\u5148\u5b9a\u4e49\u597d\u4e86\u4e00\u4e9b\u5e38\u89c1\u7684\u5e38\u91cf\u3001\u51fd\u6570\u3001\u8fd0\u7b97\u7b26\u7b49\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\uff1a \\log , \\ln , \\lg , \\sin , \\cos , \\tan , \\sec , \\csc , \\cot , \\gcd , \\min , \\max , \\exp , \\inf , \\mod , \\bmod , \\pmod \u6240\u4ee5\u5728\u8f93\u5165\u5e38\u91cf\u3001\u51fd\u6570\u540d\u3001\u8fd0\u7b97\u7b26\u7b49\u65f6\uff0c\u8bf7\u5148\u68c0\u67e5\u4e00\u4e0b\u662f\u5426\u5e94\u8be5\u4f7f\u7528 Roman \u4f53\u6216\u5176\u5b83\u5b57\u4f53\u3002LaTeX \u7b26\u53f7\u7684\u4e66\u5199\u53ef\u53c2\u8003 KaTeX \u7684 Supported Functions \u9875\u9762 \uff08\u4e0d\u662f\u5168\u90e8\uff09\uff0c\u4e5f\u53ef\u4ee5\u641c\u7d22\u6c42\u89e3\u3002 \u7531\u4e8e LaTeX \u4e66\u5199 Roman \u4f53\u5c0f\u5199\u5e0c\u814a\u5b57\u6bcd\u8f83\u4e3a\u56f0\u96be\uff0c\u6545\u5c0f\u5199\u5e0c\u814a\u5b57\u6bcd\u5e38\u91cf\u3001\u7b97\u5b50\u548c\u51fd\u6570\u53ef\u4ee5\u4f7f\u7528 Italic \u4f53\uff0c\u5982 $\\pi$ \u4ee5\u53ca $\\delta x$ \u4e2d\u7684 $\\delta$ . \u5982\u679c\u9047\u5230\u6ca1\u6709\u9884\u5148\u5b9a\u4e49\u597d\u7684\u9700\u8981\u4f7f\u7528 Roman \u4f53\u7684 \u51fd\u6570\u540d \uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 $\\operatorname{something}$ \u6765\u4ea7\u751f\uff0c\u5982\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 $\\operatorname{lcm}$ \u4ea7\u751f\u6b63\u4f53\u7684\u6700\u5c0f\u516c\u500d\u6570\uff08\u51fd\u6570\uff09\u7b26\u53f7\u3002\u540c\u7406\uff0c\u4ea7\u751f Roman \u4f53\u7684 \u5e38\u91cf \u5e94\u7528 $\\mathrm{}$ \uff1b\u4ea7\u751f Roman \u4f53\u7c97\u4f53\u7b26\u53f7\u5e94\u7528 $\\mathbf{}$ \uff1b\u4ea7\u751f Italic \u4f53\u7c97\u4f53\u7b26\u53f7\u5e94\u7528 $\\boldsymbol{}$ \uff08\u5982\u5411\u91cf $\\boldsymbol{a}$ \uff09\u3002\u5bf9\u4e8e\u591a\u5b57\u6bcd\u7684\u53d8\u91cf\uff0c\u5e94\u5f53\u4f7f\u7528 $\\textit{}$ \u3002\u5176\u4ed6\u975e\u6570\u5b66\u5185\u5bb9\uff0c\u5305\u62ec\u82f1\u6587\u3001\u7279\u6b8a\u7b26\u53f7\u7b49\uff0c\u4e00\u5f8b\u4f7f\u7528 $\\text{}$ \u3002\u4e2d\u6587\u6211\u4eec\u5219\u5efa\u8bae\u4e0d\u653e\u5728 LaTeX \u516c\u5f0f\u4e2d\u3002 \u5982\u679c\u8868\u8fbe\u5f0f\u987b\u6298\u884c\uff08\u5e38\u89c1\u4e8e\u8f83\u957f\u7684\u884c\u95f4\u516c\u5f0f\u4e2d\uff09\uff0c\u5219\u5e94\u9075\u5faa\u5982\u4e0b\u6362\u884c\u89c4\u5219\uff1a \u5c06\u6362\u884c\u7b26\u653e\u5728 $=$ \uff0c $+$ \uff0c $-$ \uff0c $\\pm$ \uff0c $\\mp$ \u4e4b\u524d\uff0c\u5982\u679c\u6709\u5fc5\u8981\uff0c\u4e5f\u53ef\u653e\u5728 $\\times$ \uff0c $\\cdot$ \uff0c $/$ \u4e4b\u524d\uff0c\u5982\uff1a $$ \\begin{aligned} \\mathrm{e}^x &= \\sum\\limits_{n=0}^{\\infty} \\frac{x^n}{n!} \\\\ &= \\phantom{+} 1 + x + \\frac{x^2}{2} \\\\ & \\phantom{=} + \\frac{x^3}{6} + \\frac{x^4}{24} + \\dots \\\\ \\end{aligned} $$ \u540c\u4e00\u8fd0\u7b97\u7b26\u4e0d\u5e94\u5728\u6362\u884c\u7b26\u524d\u540e\u540c\u65f6\u51fa\u73b0\uff0c \u6362\u884c\u7b26\u5c3d\u91cf\u4e0d\u8981\u51fa\u73b0\u5728\u62ec\u53f7\u5185\u7684\u8868\u8fbe\u5f0f\u4e2d\u3002 \u5728\u884c\u5185\u4f7f\u7528\u5206\u6570\u7684\u65f6\u5019\uff0c\u8bf7\u4f7f\u7528 $\\dfrac{}{}$ \u3002\u6bd4\u5982 $\\dfrac{1}{2}$ \uff0c\u6548\u679c $\\dfrac{1}{2}$ \uff0c\u800c\u4e0d\u662f $\\frac{1}{2}$ \uff0c\u6548\u679c $\\frac{1}{2}$ \u3002 \u7ec4\u5408\u6570\u8bf7\u4f7f\u7528 \\dbinom{n}{m} \uff0c\u6548\u679c $\\dbinom{n}{m}$ \uff0c\u800c\u4e0d\u662f {n \\choose m} \uff08\u5728 LaTeX \u4e2d\u8fd9\u79cd\u5199\u6cd5\u5df2\u4e0d\u63a8\u8350\uff09\uff1b\u4e0e\u4e0a\u4e00\u6761\u5173\u4e8e\u5206\u6570\u7684\u7ea6\u5b9a\u76f8\u4f3c\uff0c\u8bf7\u4e0d\u8981\u4f7f\u7528 \\binom{n}{m} \uff0c\u6548\u679c $\\binom{n}{m}$ \u3002 \u5c3d\u53ef\u80fd\u907f\u514d\u5728\u884c\u5185\u4f7f\u7528\u5de8\u8fd0\u7b97\u7b26\uff08\u5982 $\\sum$ \uff0c $\\prod$ \uff0c $\\int$ \u7b49\uff09\u3002 \u5728\u4e0d\u4f1a\u5f15\u8d77\u6b67\u4e49\u7684\u60c5\u51b5\u4e0b\uff0c\u8bf7\u7528 $\\times$ \u4ee3\u66ff\u661f\u53f7\uff0c\u53c9\u4e58\u8bf7\u4f7f\u7528 $\\times$ \uff0c\u70b9\u4e58\u8bf7\u4f7f\u7528 $\\cdot$ \u3002\u5982 $a\\times b$ \uff0c $a\\cdot b$ \uff0c\u800c\u4e0d\u662f $a\\ast b$ \u3002 \u8bf7\u7528 $\\cdots$ \uff08\u5c45\u4e8e\u6392\u7248\u57fa\u7ebf\u4e0e\u9876\u7ebf\u4e2d\u95f4\uff09\uff0c $\\ldots$ \uff08\u5c45\u4e8e\u6392\u7248\u57fa\u7ebf\u7684\u4f4d\u7f6e\uff09\uff0c $\\vdots$ \uff08\u7ad6\u7740\u7684\u7701\u7565\u53f7\uff09\u4ee3\u66ff $...$ \u3002\u5982 $a_1,a_2,\\cdots a_n$ \uff0c\u800c\u4e0d\u662f $a_1,a_2,... a_n$ \u3002 \u8bf7\u6ce8\u610f\uff0c\u4e0d\u8981\u5728\u975e\u4ee3\u7801\u533a\u57df\u4f7f\u7528\u4efb\u4f55\u7a0b\u5e8f\u8bbe\u8ba1\u8bed\u8a00\u7684\u8868\u793a\u65b9\u5f0f\uff0c\u800c\u662f\u4f7f\u7528 LaTeX \u516c\u5f0f\u3002\u4f8b\u5982\uff0c\u4f7f\u7528 $=$ \u800c\u4e0d\u662f $==$ \uff08\u5982 $a=b$ \uff0c\u800c\u4e0d\u662f $a==b$ \uff09\u3001\u4f7f\u7528 `a<<1` \u6216\u8005 $a\\times 2$ \u800c\u4e0d\u662f $a<<1$ \u3001\u4f7f\u7528 $a\\bmod b$ \u4ee3\u66ff $a\\%b$ \uff08\u5982 $a\\bmod b$ \uff0c\u800c\u4e0d\u662f $a\\%b$ \uff09\u7b49\u3002 \u516c\u5f0f\u4e2d\u4e0d\u8981\u4f7f\u7528\u4e2d\u62ec\u53f7\u8fde\u7f00\uff08\u5373 C++ \u9ad8\u7ef4\u6570\u7ec4\u7684\u8868\u793a\u65b9\u5f0f\uff09\u800c\u591a\u4f7f\u7528\u4e0b\u6807\u3002\u5373 $a_{i,j,k}$ \u800c\u4e0d\u662f $a[i][j][k]$ \u3002\u5728\u516c\u5f0f\u4e2d\u4e0b\u6807\u8f83\u590d\u6742\u7684\u60c5\u51b5\u4e0b\u5efa\u8bae\u6539\u7528\u591a\u5143\u51fd\u6570\uff08 $f(i,j,k)$ \uff09\u6216\u5185\u8054\u4ee3\u7801\u683c\u5f0f\u3002\u5bf9\u4e8e\u4e00\u5143\u7b80\u5355\u51fd\u6570\u4f7f\u7528 $f_i$ \u3001 $f(i)$ \u6216 $f[i]$ \u5747\u53ef\u3002 \u4e3a\u4e86\u7edf\u4e00\u4e14\u4e66\u5199\u65b9\u4fbf\uff0c\u590d\u6742\u5ea6\u5206\u6790\u65f6\u5927 $O$ \u8bb0\u53f7\u8bf7\u76f4\u63a5\u4f7f\u7528 $O()$ \u800c\u4e0d\u662f $\\mathcal O()$ \u3002 \u5728\u8868\u793a\u7b49\u4ef7\u5173\u7cfb\u65f6\uff0c\u8bf7\u4f7f\u7528 $\\iff$ \uff0c\u6548\u679c $\\iff$ \uff0c\u800c\u4e0d\u662f $\\Leftrightarrow$ \uff0c\u6548\u679c $\\Leftrightarrow$ \u3002 \u5206\u6bb5\u51fd\u6570\u73af\u5883 cases \u53ea\u80fd\u6709\u4e24\u5217 \uff08\u5373\u4e00\u4e2a & \u5206\u9694\u7b26\uff09\u3002 \u8bf7\u4e0d\u8981\u6ee5\u7528 LaTeX \u516c\u5f0f\u3002\u8fd9\u4e0d\u4ec5\u4f1a\u9020\u6210\u9875\u9762\u52a0\u8f7d\u7f13\u6162\uff08\u56e0\u4e3a MathJax \u7684\u6548\u7387\u4f4e\u662f\u51fa\u4e86\u540d\u7684\uff09\uff0c\u540c\u65f6\u4e5f\u4f1a\u5bfc\u81f4\u9875\u9762\u7684\u6392\u7248\u6df7\u4e71\u3002\u6211\u4eec\u901a\u5e38\u4f7f\u7528 LaTeX \u516c\u5f0f\u5b57\u4f53\u8868\u793a\u53d8\u91cf\u540d\u79f0\u3002\u6211\u4eec\u7684\u5efa\u8bae\u662f\uff0c\u5982\u975e\u5fc5\u8981\uff0c\u5c3d\u91cf\u51cf\u5c11\u516c\u5f0f\u4e0e\u666e\u901a\u6b63\u6587\u5b57\u4f53\u7684 \u5927\u91cf \u6df7\u5408\u4f7f\u7528\uff0c\u5982\u975e\u5fc5\u8981\uff0c\u5c3d\u91cf\u4e0d\u8981\u4f7f\u7528\u516c\u5f0f\uff0c\u5982\uff1a \u6211\u4eec\u5c06\u8981\u5b66\u4e60 $ Network - flow $ \u4e2d\u7684 $ SPFA $ \u6700\u5c0f\u8d39\u7528\u6d41\uff0c\u9700\u8981\u4f7f\u7528 $ Edmonds\u2013Karp $ \u7b97\u6cd5\u8fdb\u884c\u589e\u5e7f\u3002 \u5c31\u662f\u4e00\u4e2a\u5178\u578b\u7684 \u6ee5\u7528\u516c\u5f0f\u5b57\u4f53 \u7684\u4f8b\u5b50\u3002\uff08\u5728\u9875\u9762\u4e2d\u4f7f\u7528\u659c\u4f53\u8bf7\u7528 *\u6587\u672c* \u8868\u793a\u3002\uff09 \u8bf7\u6b63\u786e\u4f7f\u7528\u5bf9\u5e94\u7684 LaTeX \u7b26\u53f7\uff0c\u5c24\u5176\u662f\u516c\u5f0f\u4e2d\u7684\u5e0c\u814a\u5b57\u6bcd\u7b49\u7279\u6b8a\u7b26\u53f7\u3002\u5982\u6b27\u62c9\u51fd\u6570\u8bf7\u4f7f\u7528 $\\varphi$ \uff0c\u5706\u7684\u76f4\u5f84\u8bf7\u4f7f\u7528 $\\Phi$ \uff0c\u9ec4\u91d1\u5206\u5272\u8bf7\u4f7f\u7528 $\\phi$ \u3002\u8fd9\u4e9b\u7b26\u53f7\u867d\u7136\u540c\u6837\u8868\u793a\u5e0c\u814a\u5b57\u6bcd Phi\uff0c\u4f46\u662f\u5728\u4e0d\u540c\u7684\u73af\u5883\u4e0b\u6709\u4e0d\u540c\u7684\u542b\u4e49\u3002\u5207\u8bb0 \u4e0d\u8981\u4f7f\u7528\u8f93\u5165\u6cd5\u7684\u63d2\u5165\u7279\u6b8a\u7b26\u53f7 \u6765\u63d2\u5165\u8fd9\u79cd\u7b26\u53f7\u3002 \u53e6\u5916\uff0c\u7531\u4e8e LaTeX \u5386\u53f2\u539f\u56e0\uff0c\u7a7a\u96c6\u7684\u7b26\u53f7\u5e94\u4e3a $\\varnothing$ \u800c\u4e0d\u662f $\\emptyset$ \uff1b\u5176\u4ed6\u7684\u7b26\u53f7\u5e94\u53c2\u7167 \u6570\u5b66\u7b26\u53f7\u8868 \u4e66\u5199\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u8868\u683c\u6765\u603b\u7ed3\u4e00\u4e0b\u4e0a\u8ff0\u5185\u5bb9\u3002\u6ce8\u610f\u672c\u8868\u683c\u6ca1\u6709\u4e3e\u51fa\u6240\u6709\u7b26\u53f7\u7684\u7528\u6cd5\uff0c\u53ea\u7ed9\u51fa\u5e38\u89c1\u7684\u9519\u8bef\u3002\u7c7b\u4f3c\u7684\u60c5\u51b5\u7c7b\u6bd4\u5373\u53ef\u3002 \u4e0d\u7b26\u5408\u89c4\u5b9a\u7684\u7528\u6cd5 \u6e32\u67d3\u6548\u679c \u7b26\u5408\u89c4\u5b9a\u7684\u7528\u6cd5 \u6e32\u67d3\u6548\u679c $log, ln, lg$ $log, ln, lg$ $\\log$, $\\ln$, $\\lg$ $\\log$ \uff0c $\\ln$ \uff0c $\\lg$ $sin, cos, tan$ $sin, cos, tan$ $\\sin$, $\\cos$, $\\tan$ $\\sin$ \uff0c $\\cos$ \uff0c $\\tan$ $gcd, lcm$ $gcd, lcm$ $\\gcd$, $\\operatorname{lcm}$ $\\gcd$ \uff0c $\\operatorname{lcm}$ $e$, $\\text{e}$, e \uff08\u81ea\u7136\u5bf9\u6570\u7684\u5e95\uff09 $e$ \uff0c $\\text{e}$ , e $\\mathrm{e}$ $\\mathrm{e}$ $i$, $\\text{i}$, i \uff08\u865a\u6570\u5355\u4f4d\uff09 $i$ \uff0c $\\text{i}$ , i $\\mathrm{i}$ $\\mathrm{i}$ $ \u5c0f\u4e8e a \u7684\u8d28\u6570 $ $\u5c0f\u4e8e a \u7684\u8d28\u6570$ \u5c0f\u4e8e $a$ \u7684\u8d28\u6570 \u5c0f\u4e8e $a$ \u7684\u8d28\u6570 $...$ $...$ $\\cdots$, $\\ldots$, $\\vdots$, $\\ddots$ $\\cdots$ \uff0c $\\ldots$ \uff0c $\\vdots$ \uff0c $\\ddots$ $a*b$ \uff08\u4e24\u4e2a\u6570\u76f8\u4e58\uff09 $a*b$ $a\\times b$, $a\\cdot b$ $a\\times b$ \uff0c $a\\cdot b$ $SPFA$ \uff08\u82f1\u6587\u540d\u79f0\uff09 $SPFA$ SPFA SPFA $a==b$ $a==b$ $a=b$ $a=b$ $f[i][j][k]$ $f[i][j][k]$ $f_{i,j,k}$, $f(i,j,k)$ $f_{i,j,k}$ \uff0c $f(i,j,k)$ $R,N^*$ \uff08\u96c6\u5408\uff09 $R,N^*$ $\\mathbf{R}$, $\\mathbf{N}^*$ $\\mathbf{R}$ \uff0c $\\mathbf{N}^*$ $\\emptyset$ $\\emptyset$ $\\varnothing$ $\\varnothing$ $size$ $size$ $\\textit{size}$ $\\textit{size}$ \u5bf9\u6570\u5b66\u516c\u5f0f\u7684\u9644\u52a0\u683c\u5f0f\u8981\u6c42 \u00b6 \u8bf7\u6ce8\u610f\uff0c\u5c3d\u7ba1\u4e0a\u8ff0\u8f93\u5165\u516c\u5f0f\u7684\u8bed\u6cd5\u548c\u771f\u6b63\u7684 LaTeX \u6392\u7248\u7cfb\u7edf\u975e\u5e38\u76f8\u4f3c\uff0c\u4f46 MathJax \u548c LaTeX \u662f\u4e24\u4e2a\u5b8c\u5168\u6ca1\u6709\u5173\u7cfb\u7684\u4e1c\u897f \uff0cMathJax \u4ec5\u4ec5\u4f7f\u7528\u4e86\u4e00\u90e8\u5206\u4e0e LaTeX \u975e\u5e38\u76f8\u4f3c\u7684\u8bed\u6cd5\u800c\u5df2\u3002\u5b9e\u9645\u4e0a\uff0c\u4e8c\u8005\u4e4b\u95f4\u6709\u4e0d\u5c11\u7ec6\u8282\u5dee\u522b\uff0c\u800c\u8fd9\u4e9b\u5dee\u522b\u7ecf\u5e38\u5bfc\u81f4\u5199\u51fa\u6765\u7684\u516c\u5f0f\u5728\u4e8c\u8005\u4e4b\u95f4\u4e0d\u901a\u7528\u3002 \u7531\u4e8e OI Wiki \u4f7f\u7528 LaTeX \u6392\u7248\u5f15\u64ce\u5f00\u53d1\u4e86 PDF \u5bfc\u51fa\u5de5\u5177\uff0c\u56e0\u6b64\u6709\u5fc5\u8981\u5f3a\u8c03\u516c\u5f0f\u5728 MathJax \u548c LaTeX \u4e4b\u95f4\u7684\u517c\u5bb9\u6027\u3002 \u8bf7\u5404\u4f4d\u5728 Wiki \u4e2d\u4e66\u5199\u6570\u5b66\u516c\u5f0f\u65f6\u6ce8\u610f\u4ee5\u4e0b\u51e0\u70b9\u3002 \u8fd9\u4e9b\u89c4\u5219\u5df2\u7ecf\u5411 MathJax \u505a\u4e86\u5c3d\u53ef\u80fd\u591a\u7684\u59a5\u534f\u3002\u5bfc\u51fa\u5de5\u5177\u517c\u5bb9\u4e86\u4e00\u90e8\u5206\u539f\u672c\u4ec5\u80fd\u5728 MathJax \u4e2d\u6b63\u5e38\u8f93\u51fa\u7684\u5199\u6cd5\u3002 \u8bf7\u4f7f\u7528 \\begin{aligned} ... \\end{aligned} \u8868\u793a\u591a\u884c\u5bf9\u9f50\u7684\u516c\u5f0f\uff1b \u5982\u679c\u8fd9\u4e9b\u591a\u884c\u5bf9\u9f50\u7684\u516c\u5f0f\u9700\u8981 \u7f16\u53f7 \uff0c\u8bf7\u7528 align \u6216 equation \u73af\u5883\uff1b \u4e0d\u8981\u4f7f\u7528 split \u3001 eqnarray \u73af\u5883\uff1b \u4e0d\u8981\u4f7f\u7528 \\lt , \\gt \u6765\u8868\u793a\u5927\u4e8e\u53f7\u548c\u5c0f\u4e8e\u53f7\uff0c\u8bf7\u76f4\u63a5\u4f7f\u7528 < \uff0c > \uff1b \u4e0d\u8981\u76f4\u63a5\u7528 \\\\ \u6362\u884c\uff08\u9700\u8981\u6362\u884c\u7684\u516c\u5f0f\uff0c\u8bf7\u5957\u5728 aligned \u6216\u5176\u4ed6\u591a\u884c\u73af\u5883\u4e0b\uff09\uff1b \u82e5\u8981\u8f93\u51fa LaTeX \u7b26\u53f7 $\\rm{\\LaTeX}$ \uff0c\u8bf7\u7528 $\\rm{\\LaTeX}$ \uff0c\u800c\u4e0d\u662f mathrm \uff1b\uff08 \\LaTeX \u5728 TeX \u6392\u7248\u7cfb\u7edf\u4e2d\u662f\u4e00\u4e2a\u4e0d\u80fd\u7528\u4e8e\u6570\u5b66\u6a21\u5f0f\u4e0b\u7684\u547d\u4ee4\uff0c\u800c \\mathrm \u53c8\u4e0d\u80fd\u5728\u666e\u901a\u6a21\u5f0f\u4e0b\u4f7f\u7528\uff1b\u53e6\u5916\uff0c \\text \u547d\u4ee4\u867d\u7136\u5728 TeX \u4e0a\u6b63\u5e38\u8f93\u51fa\uff0c\u4f46\u662f\u5728 MathJax \u4e2d \\text \u547d\u4ee4\u7684\u53c2\u6570\u4f1a\u88ab\u539f\u6837\u8f93\u51fa\uff0c\u800c\u4e0d\u662f\u6309\u547d\u4ee4\u8f6c\u4e49\uff09\uff1b \u6570\u5b66\u516c\u5f0f\u4e2d\u7684\u4e2d\u6587\u6587\u5b57 \u5fc5\u987b\u7f6e\u4e8e \\text{} \u547d\u4ee4\u4e4b\u4e2d \uff0c\u800c\u53d8\u91cf\u3001\u6570\u5b57\u3001\u8fd0\u7b97\u7b26\u3001\u51fd\u6570\u540d\u79f0\u5219\u5fc5\u987b\u7f6e\u4e8e \\text{} \u547d\u4ee4\u4e4b\u5916\u3002 \u8bf7\u4e0d\u8981\u5728 \\text{} \u547d\u4ee4\u4e2d\u5d4c\u5957\u6570\u5b66\u516c\u5f0f \uff1b \u4f7f\u7528 array \u73af\u5883\u65f6\u8bf7\u6ce8\u610f \u5b9e\u9645\u5217\u6570\u4e0e\u5bf9\u9f50\u7b26\u53f7\u7684\u6570\u91cf\u4fdd\u6301\u4e00\u81f4 \u3002\u4f8b\u5982\u4e0b\u9762\u7684\u516c\u5f0f\u4e2d\uff0c\u6570\u636e\u5b9e\u9645\u6709 3 \u5217\uff08 & \u662f\u5217\u5206\u9694\u7b26\uff09\uff0c\u56e0\u6b64\u9700\u8981 3 \u4e2a\u5bf9\u9f50\u7b26\u53f7\uff08 l / r / c \u5206\u522b\u8868\u793a\u5de6\u3001\u53f3\u3001\u5c45\u4e2d\u5bf9\u9f50\uff09\u3002 $$ \\begin {array}{lll} F_ 1 = \\{\\frac { 0 }{ 1 },&& \\frac { 1 }{ 1 } \\}\\\\ F_ 2 = \\{\\frac { 0 }{ 1 },& \\frac { 1 }{ 2 },& \\frac { 1 }{ 1 } \\}\\\\ \\end {array} $$ \u4f2a\u4ee3\u7801\u683c\u5f0f \u00b6 \u4f2a\u7801\u5177\u4f53\u683c\u5f0f\u6ca1\u6709\u4e25\u683c\u8981\u6c42\uff0c\u8bf7\u53c2\u8003\u7b97\u6cd5\u5bfc\u8bba\u6216\u5b66\u672f\u8bba\u6587\u3002\u6ce8\u610f\u4e0d\u8981\u5199\u6210 Python\u3002 Wiki \u5185\u4f7f\u7528 LaTeX \u4e66\u5199\u4f2a\u7801\uff0c\u6574\u4f53\u5904\u4e8e array \u73af\u5883\u4e2d\uff0c\u7f29\u8fdb\u4f7f\u7528 $\\qquad$ \uff0c\u6587\u5b57\u63cf\u8ff0\u4f7f\u7528 $\\text$ \uff0c\u5173\u952e\u5b57\u4f7f\u7528 $\\textbf$ \uff0c\u8d4b\u503c\u4f7f\u7528 $\\gets$ \u3002 \u53c2\u8003\u793a\u4f8b\uff1a $$ \\begin{array}{ll} 1 & \\textbf{Input. } \\text{The edges of the graph } e , \\text{ where each element in } e \\text{ is } (u, v, w) \\\\ & \\text{ denoting that there is an edge between } u \\text{ and } v \\text{ weighted } w . \\\\ 2 & \\textbf{Output. } \\text{The edges of the MST of the input graph}.\\\\ 3 & \\textbf{Method. } \\\\ 4 & result \\gets \\varnothing \\\\ 5 & \\text{sort } e \\text{ into nondecreasing order by weight } w \\\\ 6 & \\textbf{for} \\text{ each } (u, v, w) \\text{ in the sorted } e \\\\ 7 & \\qquad \\textbf{if } u \\text{ and } v \\text{ are not connected in the union-find set } \\\\ 8 & \\qquad\\qquad \\text{connect } u \\text{ and } v \\text{ in the union-find set} \\\\ 9 & \\qquad\\qquad result \\gets result\\;\\bigcup\\ \\{(u, v, w)\\} \\\\ 10 & \\textbf{return } result \\end{array} $$ $$ \\begin {array}{ll} 1 & \\textbf {Input. } \\text {The edges of the graph } e , \\text { where each element in } e \\text { is } ( u, v, w ) \\\\ & \\text { denoting that there is an edge between } u \\text { and } v \\text { weighted } w . \\\\ 2 & \\textbf {Output. } \\text {The edges of the MST of the input graph}. \\\\ 3 & \\textbf {Method. } \\\\ 4 & result \\gets \\varnothing \\\\ 5 & \\text {sort } e \\text { into nondecreasing order by weight } w \\\\ 6 & \\textbf {for} \\text { each } ( u, v, w ) \\text { in the sorted } e \\\\ 7 & \\qquad \\textbf {if } u \\text { and } v \\text { are not connected in the union - find set } \\\\ 8 & \\qquad\\qquad \\text {connect } u \\text { and } v \\text { in the union - find set} \\\\ 9 & \\qquad\\qquad result \\gets result \\;\\bigcup\\ \\{ ( u, v, w ) \\} \\\\ 10 & \\textbf {return } result \\end {array} $$ \u4ee3\u7801\u5757\u7684\u683c\u5f0f\u8981\u6c42 \u00b6 \u4ee3\u7801\u5757\u76ee\u524d\u5206\u4e3a\u4e24\u79cd\uff1a\u7247\u6bb5\u548c\u4f8b\u9898\u3002 \u5173\u4e8e\u7247\u6bb5\u4ee3\u7801\uff1a \u7247\u6bb5\u7684\u4ee3\u7801\u5185\u5bb9\u8bf7\u76f4\u63a5\u5728 Markdown \u6587\u6863\u4e2d\u4fee\u6539\u3002 \u5173\u4e8e\u4f8b\u9898\u4ee3\u7801\uff1a \u4f8b\u9898\u4ee3\u7801\u7684\u8868\u793a\u5f62\u5f0f\u4e3a --8<-- \"path\" \uff0c\u4ee3\u7801\u5747\u5b58\u50a8\u5728 path \u4e2d\u3002\u8def\u5f84\u901a\u5e38\u4e3a docs/\u4e3b\u9898/code/\u5185\u5bb9/\u5185\u5bb9_\u7f16\u53f7.cpp \u3002 \u4fee\u6539\u4f8b\u9898\u4ee3\u7801\u65f6\uff0c\u8bf7\u4fdd\u8bc1\u4f60\u7684\u4ee3\u7801\u662f\u6b63\u786e\u7684\u3002\u4f8b\u9898\u4ee3\u7801\u5747\u62e5\u6709\u4e00\u7ec4\u6d4b\u8bd5\u6570\u636e\uff0c\u5b58\u50a8\u5728 /docs/\u4e3b\u9898/examples/\u5185\u5bb9/\u5185\u5bb9_\u7f16\u53f7.in/ans \u4e2d\u3002 \u5982\u679c\u4f60\u9700\u8981\u6dfb\u52a0\u4f8b\u9898\uff1a \u8bf7\u5728 docs/\u4e3b\u9898/code/\u5185\u5bb9 \u4e2d\u6dfb\u52a0\u4f60\u7684\u4f8b\u9898\u4ee3\u7801\uff0c\u5e76\u7f16\u53f7\u3002\u901a\u5e38\uff0c\u8be5 \u5185\u5bb9 \u6587\u4ef6\u5939\u4e2d\u5df2\u7ecf\u6709\u4e86\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u4ee3\u7801\u3002\u4f8b\u5b50\uff1a\u5982\u679c\u9700\u8981\u4fee\u6539 dag.md \u7684\u4ee3\u7801\uff0c\u90a3\u4e48\u8def\u5f84\u4e3a docs/dp/code/dag \uff0c\u5176\u4e2d dp \u4e3a\u4e3b\u9898\uff0c\u800c dag \u4e3a\u5185\u5bb9\u3002 \u5982\u679c\u9700\u8981\u5728\u6240\u6709\u4f8b\u9898\u7684\u6700\u540e\u6dfb\u52a0\u4e00\u4e2a\u4f8b\u9898\u4ee3\u7801\uff0c\u8bf7\u987a\u5ef6\u76ee\u524d\u7684\u7f16\u53f7\u3002\u6bd4\u5982\u5df2\u7ecf\u5b58\u5728\u4e86 code/prefix-sum/prefix-sum_3.cpp \uff0c\u5982\u679c\u9700\u8981\u5728\u6700\u540e\u4e00\u4e2a\u4f8b\u9898\u540e\u7ee7\u7eed\u6dfb\u52a0\u4e00\u4e2a\u4f8b\u9898\uff0c\u8bf7\u5c06\u4f60\u7684\u4ee3\u7801\u547d\u540d\u4e3a prefix-sum_4.cpp \u5e76\u6dfb\u52a0\u5230 docs/basic/code/prefix-sum \u4e2d\u3002 \u5982\u679c\u9700\u8981\u5728\u6587\u7ae0\u4e2d\u95f4\u6dfb\u52a0\u4e00\u4e2a\u4f8b\u9898\u4ee3\u7801\uff0c\u8bf7\u63d2\u5165\u5e76\u6539\u53d8\u539f\u5148\u7684\u7f16\u53f7\u3002\u6bd4\u5982\u5df2\u7ecf\u5b58\u5728\u4e86 prefix-sum_2.cpp \u548c prefix-sum_3.cpp \uff0c\u5982\u679c\u4f60\u9700\u8981\u5728\u7b2c\u4e8c\u4e2a\u4f8b\u9898\u548c\u7b2c\u4e09\u4e2a\u4f8b\u9898\u4e2d\u95f4\u518d\u6dfb\u52a0\u4e00\u4e2a\u4f8b\u9898\uff0c\u8bf7\u5c06\u4f60\u7684\u4ee3\u7801\u547d\u540d\u4e3a prefix-sum_3.cpp \u5e76\u5c06\u539f\u5148\u7684 prefix-sum_3.cpp \u6539\u540d\u4e3a prefix-sum_4.cpp \u540c\u65f6 \u5728 Markdown \u6587\u6863\u548c\u6d4b\u8bd5\u6570\u636e\u5b58\u653e\u7684\u6587\u4ef6\u5939\u4e2d\u540c\u6b65\u4fee\u6539\u7f16\u53f7 \u3002 \u522b\u5fd8\u8bb0\uff0c\u4f60\u8fd8\u8981\u5bf9\u4f60\u7684\u4ee3\u7801\u6dfb\u52a0\u4e00\u7ec4\u6d4b\u8bd5\u6570\u636e\uff0c\u4ee5\u4fdd\u8bc1\u8fd9\u4e2a\u4ee3\u7801\u662f\u53ef\u4ee5\u6210\u529f\u8fd0\u884c\u7684\u3002 \u4f60\u9700\u8981\u5728 docs/\u4e3b\u9898/examples/\u5185\u5bb9 \u6587\u4ef6\u5939\u4e2d\u6dfb\u52a0\u4e00\u7ec4\u6d4b\u8bd5\u6570\u636e\uff0c\u5c06\u8f93\u5165\u6570\u636e\u5b58\u50a8\u4e3a \u5185\u5bb9_\u7f16\u53f7.in \uff0c\u5c06\u6807\u51c6\u7b54\u6848\u5b58\u50a8\u4e3a \u5185\u5bb9_\u7f16\u53f7.ans \u3002 \u6700\u540e\uff0c\u53ef\u4ee5\u5c06\u4ee3\u7801\u6dfb\u52a0\u5230\u6587\u6863\u4e2d\u4e86\u3002\u8bf7\u76f4\u63a5\u5728\u6587\u6863\u4e2d\u7528\u6dfb\u52a0\u4ee3\u7801\u5757\u7684\u683c\u5f0f\uff0c\u5e76\u5c06\u4ee3\u7801\u5757\u5185\u90e8\u76f4\u63a5\u5199\u6210 --8<-- \"\u4f60\u7684\u4ee3\u7801\u8def\u5f84\" \u7684\u683c\u5f0f\u5c31\u53ef\u4ee5\u4e86\u3002 OI Wiki \u4f1a\u5bf9\u4f8b\u9898\u4ee3\u7801\u8fdb\u884c\u5168\u5e73\u53f0\u6d4b\u8bd5\uff0c\u4e3a\u4fdd\u8bc1\u60a8\u7684\u4ee3\u7801\u80fd\u591f\u987a\u5229\u901a\u8fc7\u6d4b\u8bd5\uff0c\u8bf7\u9075\u5b88\u5982\u4e0b\u89c4\u5219\uff1a \u60a8\u7684\u4ee3\u7801\u9700\u8981\u540c\u65f6\u652f\u6301\u5728 C++14\u3001C++17\u3001C++20 \u6807\u51c6\u4e0b\u7f16\u8bd1\u548c\u8fd0\u884c\u3002 \u4e0d\u8981\u4f7f\u7528 <bits/stdc++.h> \u3001 <bits/extc++.h> \u7b49\u975e\u6807\u51c6\u5934\u6587\u4ef6\u3002 \u6807\u51c6\u7b54\u6848\u6587\u4ef6\u4e0d\u8981\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u4e0d\u8981\u4f7f\u7528 \u4ee3\u7528\u8bb0\u53f7 \u3002 \u4f7f\u7528 \u805a\u5408\u521d\u59cb\u5316 \u65f6\uff0c object{args} \u4e0d\u53ef\u5199\u6210 (object){args} \u3002 \u4f7f\u7528 \u8fd0\u7b97\u7b26\u91cd\u8f7d \u65f6\u6ce8\u610f\u683c\u5f0f\uff0c\u5982\u91cd\u8f7d\u6bd4\u8f83\u8fd0\u7b97\u7b26\u65f6\uff0c\u82e5\u4f7f\u7528\u6210\u5458\u51fd\u6570\u5199\u6cd5\uff0c\u5219\u4e0d\u53ef\u7701\u7565 const \u9650\u5b9a\u7b26\u3002 \u4e0d\u8981\u4f7f\u7528\u7c7b\u4f3c #define int long long \u7684\u5b8f\u5b9a\u4e49\u3002 \u82e5\u60a8\u9700\u8981\u4f7f\u7528 C \u98ce\u683c\u7684 \u6709\u683c\u5f0f\u8f93\u5165/\u8f93\u51fa \uff0c\u8bf7\u7279\u522b\u7559\u610f\u683c\u5f0f\u6307\u793a\u7b26\u7684\u5199\u6cd5\uff1a\u5982 size_t \u5bf9\u5e94 %zu \uff0c ptrdiff_t \u5bf9\u5e94 %td \u3002\u4f8b\u5982\u8f93\u51fa\u67d0 STL \u5bb9\u5668\u7684\u5927\u5c0f\u65f6\uff0c\u4ee3\u7801\u5e94\u7c7b\u4f3c printf(\"%zu\", container.size()); \u3002 \u7531\u4e8e\u5f53\u524d\u6d4b\u8bd5\u73af\u5883 libstdc++ \u7684 <chrono> \u5e93\u6709 BUG \uff0c\u6240\u4ee5\u8bf7\u907f\u514d\u4f7f\u7528 <chrono> \u5e93\u3002 \u7531\u4e8e long \u4e0e unsigned long \u5728\u67d0\u4e9b\u6d4b\u8bd5\u73af\u5883\u4e0b\u4e3a 32 \u4f4d\uff0c\u800c\u5728\u53e6\u4e00\u4e9b\u6d4b\u8bd5\u73af\u5883\u4e0b\u4e3a 64 \u4f4d\uff0c\u4e3a\u786e\u4fdd\u5404\u5e73\u53f0\u4ee3\u7801\u884c\u4e3a\u4e00\u81f4\uff0c\u6545\u4e0d\u63a8\u8350\u4f7f\u7528\u8fd9\u4e24\u79cd\u7c7b\u578b\u3002\u63a8\u8350\u4f7f\u7528 \u5b9a\u5bbd\u6574\u6570\u7c7b\u578b \u3002 \u4e0d\u5efa\u8bae\u4f7f\u7528 __gcd \u3001 __int128 \u3001 __builtin_ \u7cfb\u5217\u51fd\u6570\u7b49\u975e\u6807\u51c6\u5185\u5bb9\u3002\u5982\u679c\u60a8\u9700\u8981\u4f7f\u7528\uff0c\u5219\u9700\u786e\u4fdd\u60a8\u7684\u4ee3\u7801\u80fd\u901a\u8fc7\u5168\u5e73\u53f0\u6d4b\u8bd5\uff0c\u5982 \u6b64\u4ee3\u7801 \u63d0\u4f9b\u4e86 libstdc++ \u4e2d std::bitset \u7279\u6709\u6210\u5458\u51fd\u6570 _Find_first() \u7684\u5168\u5e73\u53f0\u5b9e\u73b0\u3002 \u6b64\u5916\uff0c\u4e3a\u4e86\u63d0\u9ad8\u4ee3\u7801\u7684\u53ef\u8bfb\u6027\uff0c\u5efa\u8bae\u9075\u5b88\u5982\u4e0b\u89c4\u5219\uff1a \u4ee3\u7801\u5e94\u5c3d\u53ef\u80fd\u7b80\u6d01\u6613\u61c2\uff0c\u4e0d\u8981\u8fc7\u5ea6\u538b\u884c\uff0c\u4e0d\u8981\u5f15\u5165\u8fc7\u591a\u65e0\u5173\u4ee3\u7801\uff08\u5982\u672a\u4f7f\u7528\u7684\u5b8f\u5b9a\u4e49\u7b49\uff09\u3002 \u4e0d\u63a8\u8350\u5bf9\u51fd\u6570\u4f7f\u7528 inline \u5173\u952e\u5b57\uff0c\u8be6\u89c1 \u7f16\u8bd1\u4f18\u5316 \u3002 \u4e0d\u8981\u7528 0 \u4ee3\u66ff false / NULL / nullptr \u7b49\uff0c\u4e0d\u8981\u7528 1 \u4ee3\u66ff true \u7b49\u3002 \u5728\u58f0\u660e \u7c7b\u578b\u522b\u540d \u65f6\uff0c\u4e0d\u63a8\u8350\u4f7f\u7528 typedef \uff0c\u63a8\u8350\u4f7f\u7528 using \u3002 \u4e0d\u63a8\u8350\u7528\u5b8f\u5b9a\u4e49\u5b9a\u4e49\u5e38\u91cf\uff0c\u63a8\u8350\u76f4\u63a5\u4f7f\u7528 constexpr / const \u7b49\u5173\u952e\u5b57\u5b9a\u4e49\u5e38\u91cf\u3002 \u56fe\u89e3 \u00b6 \u53ef\u80fd\u4e0a\u8ff0\u8981\u6c42\u628a\u63e1\u8d77\u6765\u6709\u4e9b\u56f0\u96be\uff0c\u63a5\u4e0b\u6765\u6211\u4eec\u7ed9\u51fa\u4e00\u4e9b\u56fe\u7247\u6765\u5177\u4f53\u5206\u6790\u54ea\u79cd\u683c\u5f0f\u5e94\u8be5\u4f7f\u7528\uff0c\u54ea\u79cd\u4e0d\u8be5\u4f7f\u7528\uff1a \u4f8b 1 \u00b6 \u5c06\u590d\u6742\u7684 LaTeX \u516c\u5f0f\u4f7f\u7528\u884c\u95f4\u683c\u5f0f\uff0c\u53ef\u4ee5\u4f7f\u5f97\u9875\u9762\u9519\u843d\u6709\u81f4\u3002\u4f46 OI Wiki \u4f5c\u4e3a\u4e00\u4e2a\u4ee5\u4e2d\u6587\u4e3a\u4e3b\u4f53\u7684\u7ad9\u70b9\uff0c\u6211\u4eec\u5e0c\u671b\u5927\u90e8\u5206\u7eb2\u9886\u6027\u7684\u4fe1\u606f\uff08\u5982\u6807\u9898\uff09\u5c3d\u91cf\u4f7f\u7528\u4e2d\u6587\uff08\u9664\u82f1\u6587\u4e13\u6709\u540d\u8bcd\uff09\u3002 \u4f8b 2 \u00b6 \u8f83\u590d\u6742\u5ea6\u7684 LaTeX \u516c\u5f0f\u8bf7\u6ce8\u610f\u7b49\u53f7\u7684\u5bf9\u9f50\uff0c\u540c\u65f6\u53ef\u4ee5\u9002\u5f53\u5f15\u7528 Wiki \u7684\u9875\u9762 \u94fe\u63a5 \u6765\u5b8c\u5584\u5185\u5bb9\u3002 \u4f8b 3 \u00b6 \u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5efa\u8bae\u5c06\u5f15\u7528\u7684\u8d44\u6599\u5217\u5728\u6587\u672b\u7684 ##\u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca \u4e00\u8282\uff0c\u5e76\u5728\u539f\u53e5\u540e\u9762\u52a0\u4e0a\u811a\u6ce8\uff0c\u800c\u4e0d\u662f\u76f4\u63a5\u7ed9\u51fa\u94fe\u63a5\u3002\u540c\u65f6\u4e00\u5b9a\u8981\u907f\u514d\u4f7f\u7528 LaTeX \u516c\u5f0f\u8868\u8fbe\u4ee3\u7801\uff0c\u4e0a\u56fe\u4e2d\u4e24\u4e2a\u4e2d\u62ec\u53f7\u5c31\u662f\u4e0d\u89c4\u8303\u7684\u5199\u6cd5\u3002\u6211\u4eec\u5efa\u8bae\u4f7f\u7528 dp(i,j) \u6216\u8005 dp_{i,j} \u3002 \u4f8b 4 \u00b6 \u6ce8\u610f\u6211\u4eec\u63cf\u8ff0 \u4e58\u6cd5 \u7684\u65f6\u4faf\u4e00\u822c\u4f7f\u7528 \\times \u6216\u8005 \\cdot \uff0c\u7279\u6b8a\u60c5\u51b5\uff08\u5982\u5377\u79ef\uff09\u4e0b\u4f1a\u4f7f\u7528 * \uff08\u4e5f\u53ef\u4ee5\u5199\u6210 \\ast \uff09\u3002\u6807\u9898\u662f\u7b80\u6d01\u7684\u8bcd\u7ec4\uff0c\u4f46\u6211\u4eec\u4e0d\u5e0c\u671b\u6b63\u6587\u90e8\u5206\u7531\u8bcd\u7ec4\u62fc\u51d1\u800c\u6210\u3002\u4e0a\u56fe\u4e2d\u300c\u4e24\u4e2a\u8981\u7d20\u300d\uff0c\u5efa\u8bae\u66f4\u6539\u4e3a\u300c\u52a8\u6001\u89c4\u5212\u7684\u539f\u7406\u5177\u6709\u4ee5\u4e0b\u4e24\u4e2a\u8981\u7d20\u300d\uff0c\u4e0a\u4e0b\u6587\u4fdd\u6301\u8fde\u8d2f\u3002\u53ef\u53d6\u7684\u5730\u65b9\u662f\uff0c\u9002\u5f53\u4f7f\u7528 \u6709\u5e8f \u5217\u8868\u53ef\u4ee5\u66f4\u6709\u6761\u7406\u5730\u8868\u8ff0\u5185\u5bb9\u3002\u518d\u6b21\u63d0\u9192\uff0c\u5728\u4f7f\u7528\u5217\u8868\u7684\u65f6\u4faf\uff0c\u6bcf\u4e00\u9879\u5982\u679c\u662f\u4e00\u53e5\u8bdd\uff0c\u9700\u8981\u5728\u672b\u4f4d\u6dfb\u52a0 \u6807\u70b9\u7b26\u53f7 \u3002\u6709\u5e8f\u5217\u8868\u901a\u5e38\u6dfb\u52a0\u5206\u53f7\uff0c\u5728\u6700\u540e\u4e00\u9879\u672b\u4f4d\u6dfb\u52a0\u53e5\u53f7\uff1b\u65e0\u5e8f\u5217\u8868\u7edf\u4e00\u6dfb\u52a0\u53e5\u53f7\u3002 \u4f8b 5 \u00b6 \u9002\u5f53\u5f15\u7528 \u56fe\u7247 \u53ef\u4ee5\u589e\u5f3a\u6587\u7ae0\u6613\u8bfb\u6027\u3002\u4f7f\u7528 \u4f2a\u4ee3\u7801 \u7684\u65b9\u5f0f\u8868\u8fbe\u7b97\u6cd5\u8fc7\u7a0b\u53ef\u4ee5\u65b9\u4fbf\u53c8\u7b80\u6d01\u5730\u63cf\u8ff0\u7b97\u6cd5\u8fc7\u7a0b\uff0c\u76f8\u6bd4\u4e8e\u76f4\u63a5\u8d34\u6a21\u677f\u4ee3\u7801\u66f4\u52a0\u597d\u61c2\u3002 \u4f8b 6 \u00b6 \u540c\u6837\u7684\u95ee\u9898\uff0c\u6807\u9898\u4f7f\u7528\u82f1\u6587\u3002\u5e76\u4e14\u5728\u4f7f\u7528\u5b8c\u62ec\u53f7\u540e\u6ca1\u6709\u53e5\u53f7\u3002\u53e6\u5916\uff0c\u4e0a\u56fe\u4e2d\u7684\u884c\u95f4\u516c\u5f0f\u867d\u7136\u6ca1\u6709\u4f7f\u7528\u827e\u5f17\u68ee\u62ec\u53f7\uff0c\u4f46\u662f\u7531\u4e8e\u4e0b\u6807\u5d4c\u5957\u8fc7\u591a\uff0c\u4f7f\u5f97\u6700\u5e95\u5c42\u7684\u4e0b\u6807\u5b57\u4f53\u5f88\u5c0f\uff0c\u6574\u4e2a\u516c\u5f0f\u4e5f\u5e76\u4e0d\u7f8e\u89c2\u3002\u5efa\u8bae\u5c06 son_{now,i} \u66f4\u6362\u4e3a son(now,i) \uff0c\u6216\u8005\u628a f_{now} \u66ff\u6362\u4e3a f(now) \u3002\u6211\u4eec\u5e0c\u671b\u5c3d\u91cf\u63a7\u5236\u4e0b\u6807\u5d4c\u5957\u5728\u4e24\u5c42\u4ee5\u5185\uff08\u4e0a\u6807\u7684\u8fd0\u7528\u4e3b\u8981\u662f\u6570\u5b66\u8868\u8fbe\u5f0f\uff0c\u56e0\u6b64\u53ef\u4ee5\u5141\u8bb8\u591a\u6b21\u5d4c\u5957\uff0c\u5982 $2^{2^{2^{2^{\\cdots}}}}$ \uff0c\u300a\u4e0a\u5e1d\u9020\u9898\u7684\u4e03\u5206\u949f\u300b\uff09\u3002 \u4f8b 7 \u00b6 \u4f7f\u7528 MkDocs \u6269\u5c55\u8bed\u6cd5\uff0c\u8ba9\u4f8b\u9898\u9898\u9762\u4e0e\u7b97\u6cd5\u63cf\u8ff0\u533a\u5206\u5f00\u3002\u5c06\u4ee3\u7801\u6298\u53e0\uff0c\u53ef\u4ee5\u8ba9\u6587\u7ae0\u66f4\u7d27\u51d1\u3002\uff08\u6bd5\u7adf\u770b Wiki \u7684\u5927\u591a\u6570\u662f\u4e86\u89e3\u601d\u8def\uff0c\u9664\u4e86\u6a21\u677f\u4ee3\u7801\u9700\u8981\u9605\u8bfb\u5916\uff0c\u4e60\u9898\u7684\u4ee3\u7801\u5927\u591a\u53ef\u4ee5\u6298\u53e0\u3002\uff09\u5728\u63cf\u8ff0\u51fd\u6570\u64cd\u4f5c\u65f6\uff0c\u4f7f\u7528\u884c\u5185\u4ee3\u7801\u548c LaTeX \u516c\u5f0f\u90fd\u662f\u4e0d\u9519\u7684\u9009\u62e9\u3002 \u4f8b 8 \u00b6 \u5728\u6587\u672b\u7f57\u5217\u51fa\u53c2\u8003\u6587\u732e\uff0c\u53ef\u4ee5\u4f7f\u9875\u9762\u7684\u5185\u5bb9\u66f4\u4e25\u8c28\uff0c\u771f\u5b9e\u53ef\u4fe1\u3002 \u5916\u90e8\u94fe\u63a5 \u00b6 \u6807\u70b9\u7b26\u53f7\u7528\u6cd5\uff08GB/T 15834\u20142011\uff09 \u7ef4\u57fa\u767e\u79d1\uff1a\u683c\u5f0f\u624b\u518c/\u6807\u70b9\u7b26\u53f7 \u4e2d\u6587\u6587\u6848\u6392\u7248\u6307\u5317\uff08\u7b80\u4f53\u4e2d\u6587\u7248\uff09 \u4e2d\u6587\u6587\u6848\u98ce\u683c\u6307\u5357 - PDFE GUIDELINE \u4e00\u4efd\uff08\u4e0d\u592a\uff09\u7b80\u77ed\u7684 LATEX2\u03b5 \u4ecb\u7ecd\u6216 106 \u5206\u949f\u4e86\u89e3 LATEX2\u03b5 \u4e2d\u6587\u51fa\u7248\u7269\u5939\u7528\u82f1\u6587\u7684\u7f16\u8f91\u89c4\u8303 \u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca \u00b6 [^ref1]: cstdio stdio.h namespace [^ref2]: CCF \u5173\u4e8e\u6062\u590d NOIP \u7ade\u8d5b\u7684\u516c\u544a - \u4e2d\u56fd\u8ba1\u7b97\u673a\u5b66\u4f1a [^webarchive]: Save Page in Internet Archive","title":"Format"},{"location":"intro/format.html#_1","text":"\u5f53\u4f60\u6253\u7b97\u8d21\u732e\u67d0\u90e8\u5206\u7684\u5185\u5bb9\u65f6\uff0c\u4f60\u5e94\u8be5\u5c3d\u91cf\u719f\u6089\u4ee5\u4e0b\u4e09\u90e8\u5206\uff1a \u6587\u6863\u5b58\u50a8\u7684\u683c\u5f0f \u6587\u6863\u7684\u5408\u7406\u6027 remark-lint \u548c $\\rm{\\LaTeX}$ \u516c\u5f0f\u7684\u683c\u5f0f\u8981\u6c42","title":"\u8d21\u732e\u6587\u6863\u8981\u6c42"},{"location":"intro/format.html#_2","text":"\u6587\u4ef6\u540d\u8bf7\u52a1\u5fc5\u90fd\u5c0f\u5199\uff0c\u4ee5 - \u5206\u5272\u3002 \u4f8b\u5982\uff1a file-name.md \u3002 \u8bf7\u52a1\u5fc5\u786e\u4fdd\u6587\u6863\u4e2d\u5f15\u7528\u7684 \u5916\u94fe \u56fe\u7247\u5df2\u7ecf\u5168\u90e8\u8f6c\u5b58\u5230\u4e86 \u672c\u5e93\u5185 \u5bf9\u5e94\u7684 images \u6587\u4ef6\u5939\u4e2d\uff08\u9632\u6b62\u89e6\u53d1\u67d0\u4e9b\u7f51\u7ad9\u7684\u9632\u76d7\u94fe\uff09\uff0c\u5efa\u8bae\u5904\u7406\u6210 MD \u6587\u6863\u540d\u79f0 + \u7f16\u53f7 \u7684\u5f62\u5f0f\uff08\u53ef\u53c2\u8003\u5df2\u6709\u6587\u6863\u4e2d\u56fe\u7247\u7684\u5904\u7406\u65b9\u5f0f\uff09\u3002\u4f8b\u5982\uff1a\u672c\u7bc7\u6587\u6863\u7684\u6587\u4ef6\u540d\u79f0\u4e3a format\uff0c\u5219\u6587\u6863\u4e2d\u5f15\u7528\u7684\u7b2c\u4e00\u5f20\u56fe\u7247\u7684\u540d\u5b57\u4e3a format1.png \u3002 \u63a8\u8350\u4f7f\u7528 SVG \u683c\u5f0f\u7684\u56fe\u7247 ^ref4 \uff0c\u4ee5\u83b7\u53d6\u8f83\u597d\u7684\u6e05\u6670\u5ea6\u548c\u7f29\u653e\u6548\u679c\u3002 \u52a8\u56fe\u5982\u679c\u65e0\u6cd5\u6216\u8005\u4e0d\u4f1a\u5236\u4f5c SVG \u683c\u5f0f\u7684\uff0c\u5219\u63a8\u8350\u4f7f\u7528 APNG \u683c\u5f0f ^apng \u7684\u6587\u4ef6\u3002Windows \u7528\u6237\u53ef\u4f7f\u7528 ScreenToGif \u5f55\u5236\uff0cLinux \u7528\u6237\u53ef\u4f7f\u7528 Peek \u5f55\u5236\uff0c\u6ce8\u610f\u9700\u8981\u5728\u8bbe\u7f6e\u91cc\u8c03\u6574\u4e3a\u5f55\u5236 APNG\u3002\u5176\u4ed6\u60c5\u51b5\u5219\u63a8\u8350\u5148\u5236\u4f5c\u4e3a MP4 \u7b49\u89c6\u9891\u6587\u4ef6\u518d\u8f6c\u6362\u4e3a APNG\uff0c\u5982\u679c\u4f7f\u7528 ffmpeg \u5219\u53ef\u4ee5\u4f7f\u7528 ffmpeg -i filename.mp4 -f apng filename.apng -plays 0 \u8f6c\u6362\u3002 ^intro-apng \u540c\u65f6\u5177\u6709\u6e90\u6587\u4ef6\u548c\u5bfc\u51fa\u56fe\u50cf\u7684\u56fe\u7247\uff08\u4f8b\u5982 JPG \u6587\u4ef6\u4e0e PSD \u6587\u4ef6\u6216\u8005 SVG \u56fe\u50cf\u4e0e TikZ TeX \u6e90\u4ee3\u7801\uff09\uff0c\u5efa\u8bae\u5c06\u6e90\u6587\u4ef6\u4ee5\u4e0e\u56fe\u7247\u76f8\u540c\u7684\u6587\u4ef6\u540d\u4fdd\u5b58\u4e8e\u540c\u4e00\u76ee\u5f55\u4e0b\u3002 \u8bf7\u786e\u4fdd\u60a8\u7684\u6587\u6863\u4e2d\u7684\u5f15\u7528\u94fe\u63a5\u7684\u7a33\u5b9a\u6027\u3002 \u4e0d\u63a8\u8350 \u5f15\u7528 \u81ea\u5efa \u670d\u52a1\u4e2d\u7684\u8d44\u6e90\uff08\u5982\u81ea\u5efa OJ \u91cc\u7684\u9898\u76ee\uff09\u3002\u5efa\u8bae\u5728\u6dfb\u52a0\u65f6\u540c\u65f6\u5c06\u8be5\u5916\u94fe\u5b58\u4e8e\u4e92\u8054\u7f51\u6863\u6848\u9986[^webarchive]\uff0c\u4ee5\u9632\u65e0\u6cd5\u66ff\u4ee3\u7684\u94fe\u63a5\u5931\u6548\u3002 \u7ad9\u5185\u94fe\u63a5\u8bf7\u53bb\u6389\u7f51\u7ad9\u57df\u540d\uff0c\u5e76\u4e14\u4f7f\u7528\u76f8\u5bf9\u8def\u5f84\u94fe\u63a5\u5bf9\u5e94 .md \u6587\u4ef6\u3002\u4f8b\u5982\uff0c\u5728\u672c\u9875\u9762\uff08 intro/format \uff09\u4e2d\u94fe\u63a5\u6742\u9879\u7b80\u4ecb\uff08 misc \uff09\uff0c\u5e94\u4f7f\u7528 [\u6742\u9879\u7b80\u4ecb](../misc/index.md) \u3002\u53ef\u4ee5\u5728\u94fe\u63a5\u4e2d\u6dfb\u52a0 hash \u6765\u94fe\u63a5\u5230\u67d0\u4e00\u8282\uff0c\u4f8b\u5982 [Pull Request \u4fe1\u606f\u683c\u5f0f\u89c4\u8303](./htc.md#pull-request-\u4fe1\u606f\u683c\u5f0f\u89c4\u8303) \uff0chash \u7684\u503c\u53ef\u4ee5\u901a\u8fc7\u4f4d\u4e8e\u6bcf\u4e2a\u6807\u9898\u53f3\u4fa7\u7684\u6309\u94ae\u6216\u8005\u4f4d\u4e8e\u7f51\u9875\u53f3\u4fa7\u7684\u76ee\u5f55\u4e2d\u7684\u94fe\u63a5\u5f97\u5230\u3002","title":"\u6587\u6863\u5f15\u7528\u4e0e\u5b58\u50a8\u7684\u683c\u5f0f"},{"location":"intro/format.html#_3","text":"\u5408\u7406\u6027 \uff0c\u6307\u6240\u7f16\u5199\u7684 \u5185\u5bb9 \u5fc5\u987b\u5177\u6709\u5982\u4e0b\u7684\u7279\u6027\uff1a \u7531\u6d45\u5165\u6df1\uff0c\u5185\u5bb9\u7684\u96be\u5ea6\u5e94\u8be5\u5177\u6709\u6e10\u8fdb\u6027\u3002 \u903b\u8f91\u6027\u3002 \u5bf9\u4e8e\u7b97\u6cd5\u6216\u6570\u5b66\u6982\u5ff5\u7c7b\u5185\u5bb9\u7684\u64b0\u5199\u5e94\u8be5\u5c3d\u91cf\u5305\u542b\u4ee5\u4e0b\u7684\u5185\u5bb9\uff1a \u539f\u7406\uff1a\u8bf4\u660e\u8be5\u5185\u5bb9\u5bf9\u5e94\u7684\u539f\u7406\uff1b \u4f8b\u5b50\uff1a\u7ed9\u51fa 1 \\~ 2 \u4e2a\u5178\u578b\u7684\u4f8b\u5b50\uff1b \u9898\u76ee\uff1a\u5728\u8be5\u6807\u9898\u4e0b\uff0c \u53ea\u9700\u8981\u7ed9\u51fa\u9898\u76ee\u540d\u5b57\u548c\u9898\u76ee\u94fe\u63a5 \u3002\u5bf9\u4e8e\u7b97\u6cd5\u7c7b\u9898\u76ee\uff0c\u9898\u76ee\u94fe\u63a5 OJ \u7684\u4f18\u5148\u7ea7\u4e3a\uff1a\u539f OJ\uff08\u56fd\u5916 OJ \u8981\u6c42\u56fd\u5185\u53ef\u6d41\u7545\u8bbf\u95ee\uff09> UOJ > LOJ > \u6d1b\u8c37\u3002 \u793a\u4f8b\u9875\u9762\uff1a IDA* \u5bf9\u4e8e\u5de5\u5177\u7c7b\u5185\u5bb9\u7684\u64b0\u5199\u5e94\u8be5\u5c3d\u91cf\u5305\u542b\u4ee5\u4e0b\u7684\u5185\u5bb9\uff1a \u7b80\u4ecb\uff1a\u9610\u660e\u8be5\u5de5\u5177\u7684\u80cc\u666f\u4e0e\u7528\u9014\u3002 \u914d\u7f6e\u65b9\u5f0f\uff1a\u8be6\u7ec6\u7ed9\u51fa\u914d\u7f6e\u73af\u5883\u4e0e\u4f7f\u7528\u7684\u8fc7\u7a0b\uff0c\u4e0b\u8f7d\u4e0e\u5b89\u88c5\u65b9\u6cd5\u5efa\u8bae\u5c3d\u91cf\u5f15\u7528\u5b98\u65b9\u6587\u6863\u3002 \u793a\u4f8b\u9875\u9762\uff1a WSL (Windows 10) \u9664\u73b0\u6709\u5185\u5bb9\u8d28\u91cf\u8f83\u4f4e\u7684\u60c5\u51b5\u5916\uff0c\u5efa\u8bae\u5c3d\u91cf\u4ece \u8865\u5145 \u7684\u89d2\u5ea6\u6765\u505a\u8d21\u732e\uff0c\u800c\u975e\u91c7\u53d6\u76f4\u63a5\u8986\u76d6\u7684\u65b9\u5f0f\u3002\u5982\u679c\u62ff\u4e0d\u51c6\u4e3b\u610f\uff0c\u53ef\u4ee5\u53c2\u8003 \u5173\u4e8e\u672c\u9879\u76ee\u7684\u4ea4\u6d41\u65b9\u5f0f \u4e00\u8282\uff0c\u4e0e OI Wiki \u9879\u76ee\u7ec4\u8054\u7cfb\u3002","title":"\u6587\u6863\u7684\u5408\u7406\u6027"},{"location":"intro/format.html#_4","text":"","title":"\u6587\u6863\u7684\u57fa\u672c\u683c\u5f0f\u8981\u6c42"},{"location":"intro/format.html#remark-lint","text":"remark-lint \u53ef\u4ee5\u81ea\u52a8\u7ed9\u9879\u76ee\u5185\u6587\u4ef6\u7edf\u4e00\u98ce\u683c\u3002 OI Wiki \u73b0\u5728\u542f\u7528\u7684\u914d\u7f6e\u6587\u4ef6\u6258\u7ba1\u5728 .remarkrc \u3002 \u5728\u914d\u7f6e\u8fc7\u7a0b\u4e2d OI Wiki \u9879\u76ee\u7ec4\u4e5f\u9047\u5230\u4e86\u4e00\u4e9b remark-lint \u4e0d\u80fd\u5f88\u597d\u5904\u7406\u7684\u95ee\u9898\uff0c\u6240\u4ee5\u8bf7\u4e25\u683c\u6309\u7167\u4e0b\u5217\u8981\u6c42\u7f16\u8f91\u6587\u6863\uff1a \u4e0d\u8981\u4f7f\u7528\u5982 <h1> \u6216\u8005 # \u6807\u9898 \u7684\u4e00\u7ea7\u6807\u9898\u3002 \u6807\u9898\u8981\u7a7a\u4e00\u4e2a\u82f1\u6587\u534a\u89d2\u7a7a\u683c\uff0c\u4f8b\u5982\uff1a ## \u7b80\u4ecb \u3002 \u7531\u4e8e remark-lint \u4e0d\u80fd\u5f88\u597d\u5730\u5904\u7406\u5220\u9664\u7ebf\uff0c\u56e0\u6b64\u8bf7\u4e0d\u8981\u4f7f\u7528\u5220\u9664\u7ebf\u8bed\u6cd5\uff08\u4e0d\u4f7f\u7528\u5220\u9664\u7ebf\u8bed\u6cd5\u7684\u53e6\u5916\u4e00\u4e2a\u539f\u56e0\u662f\uff0c\u5220\u9664\u7ebf\u5212\u53bb\u7684\u5185\u5bb9\u5927\u591a\u4e3a\u300c\u6296\u673a\u7075\u300d\u6027\u8d28\uff0c\u5bf9\u8bfb\u8005\u7406\u89e3\u5e2e\u52a9\u4e0d\u5927\uff0c\u4e0d\u7b26\u5408\u4e0b\u9762\u7684\u300c\u6587\u672c\u5185\u5bb9\u7684\u683c\u5f0f\u8981\u6c42\u300d\u4e2d\u5bf9\u5185\u5bb9\u8868\u8ff0\u7684\u8981\u6c42\uff09\u3002 \u5217\u8868\uff1a \u5217\u8868\u524d\u8981\u6709\u7a7a\u884c\uff0c\u65b0\u5f00\u4e00\u6bb5\u3002 \u4f7f\u7528\u6709\u5e8f\u5217\u8868\uff08\u5982 1. \u4f8b\u5b50 \uff09\u65f6\uff0c\u70b9\u53f7\u540e\u8981\u6709\u7a7a\u683c\u3002 \u884c\u95f4\u516c\u5f0f\u524d\u540e\u5404\u8981\u6709\u4e00\u884c\u7a7a\u884c\uff0c\u5426\u5219\u4f1a\u88ab\u5f53\u505a\u662f\u884c\u5185\u516c\u5f0f\u3002 \u4f7f\u7528 ??? \u6216 !!! \u5f00\u5934\u7684 Details \u8bed\u6cd5\u65f6\uff0c\u6bcf\u4e00\u884c\u8981\u5305\u62ec\u5728 Details \u8bed\u6cd5\u7684\u6587\u672c\u6846\u7684\u6587\u672c\uff0c\u5f00\u5934\u5fc5\u987b\u81f3\u5c11\u6709 4 \u4e2a\u7a7a\u683c\u3002 \u5373\u4f7f\u662f\u7a7a\u884c\uff0c\u4e5f\u5fc5\u987b\u4fdd\u6301\u4e0e\u5176\u4ed6\u884c\u4e00\u81f4\u7684\u7f29\u8fdb\u3002\u8bf7\u4e0d\u8981\u4f7f\u7528\u7f16\u8f91\u5668\u7684\u81ea\u52a8\u88c1\u526a\u884c\u672b\u7a7a\u683c\u529f\u80fd\u3002 \u793a\u4f8b ???+ warning \u8bf7\u8bb0\u5f97\u5728\u6587\u672c\u524d\u9762\u6dfb\u52a0 4 \u4e2a\u7a7a\u683c\u3002\u5176\u4ed6\u7684\u8bed\u6cd5\u8fd8\u662f\u4e0e Markdown \u8bed\u6cd5\u4e00\u81f4\u3002 \u4e0d\u6dfb\u52a0 4 \u4e2a\u7a7a\u683c\u7684\u8bdd\uff0c\u6587\u672c\u5c31\u4e0d\u4f1a\u51fa\u73b0\u5728 Details \u6587\u672c\u6846\u91cc\u4e86\u3002 \u8fd9\u4e2a`???`\u662f\u4ec0\u4e48\u7684\u95ee\u9898\u4f1a\u5728\u4e0b\u6587\u89e3\u7b54\u3002 Warning \u8bf7\u8bb0\u5f97\u5728\u6587\u672c\u524d\u9762\u6dfb\u52a0 4 \u4e2a\u7a7a\u683c\u3002\u5176\u4ed6\u7684\u8bed\u6cd5\u8fd8\u662f\u4e0e Markdown \u8bed\u6cd5\u4e00\u81f4\u3002 \u4e0d\u6dfb\u52a0 4 \u4e2a\u7a7a\u683c\u7684\u8bdd\uff0c\u6587\u672c\u5c31\u4e0d\u4f1a\u51fa\u73b0\u5728 Details \u6587\u672c\u6846\u91cc\u4e86\u3002 \u8fd9\u4e2a ??? \u662f\u4ec0\u4e48\u7684\u95ee\u9898\u4f1a\u5728\u4e0b\u6587\u89e3\u7b54\u3002 \u4ee3\u7801\u6837\u5f0f\u7684\u7eaf\u6587\u672c\u5757\u8bf7\u4f7f\u7528 ```text \u3002\u76f4\u63a5\u4f7f\u7528 ``` \u800c\u4e0d\u6307\u5b9a\u7eaf\u6587\u672c\u5757\u91cc\u7684\u8bed\u8a00\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u5185\u5bb9\u88ab\u9519\u8bef\u5730\u7f29\u8fdb\u3002","title":"Remark-lint \u7684\u683c\u5f0f\u8981\u6c42"},{"location":"intro/format.html#_5","text":"\u8bf7\u5728\u6bcf\u53e5\u8bdd\u7684\u672b\u5c3e\u6dfb\u52a0 \u53e5\u53f7 \u3002 \u8bf7\u6b63\u786e\u4f7f\u7528 \u5168\u89d2 \u6807\u70b9\u7b26\u53f7\u4e0e \u534a\u89d2 \u6807\u70b9\u7b26\u53f7\u3002\u6c49\u8bed\u8bf7\u4f7f\u7528\u5168\u89d2\u7b26\u53f7\uff0c\u82f1\u8bed\u8bf7\u4f7f\u7528\u534a\u89d2\u7b26\u53f7\u3002\u4e2d\u6587\u4e2d\u5939\u7528\u82f1\u6587\u65f6\uff0c\u8bf7\u53c2\u8003 \u4e2d\u6587\u51fa\u7248\u7269\u5939\u7528\u82f1\u6587\u7684\u7f16\u8f91\u89c4\u8303 \u3002 \u7531\u4e8e \u201c\u2026\u2026\u201d \u672a\u533a\u5206\u5168\u534a\u89d2\uff0c\u8bf7\u4f7f\u7528 \u300c\u2026\u2026\u300d \u4f5c\u4e3a\u5168\u89d2\u5f15\u53f7\uff0c \"...\" \u4f5c\u4e3a\u534a\u89d2\u5f15\u53f7\u3002 \u6ce8\u610f\u533a\u5206 \u987f\u53f7 \u4e0e \u9017\u53f7 \u7684\u4f7f\u7528\u3002 \u6ce8\u610f \u62ec\u53f7 \u7684\u4f4d\u7f6e\u3002\u53e5\u5185\u62ec\u53f7\u4e0e\u53e5\u5916\u62ec\u53f7\u7684\u4f4d\u7f6e\u4e0d\u540c\u3002 \u901a\u5e38\u4f7f\u7528 \u5206\u53f7 \u6765\u8868\u793a\u5217\u8868\u73af\u5883\u4e2d\u5404\u590d\u53e5\u4e4b\u95f4\u7684\u5173\u7cfb\u3002 \u5bf9\u4e8e\u6709\u5e8f\u5217\u8868\uff0c\u63a8\u8350\u5728\u6bcf\u4e00\u9879\u7684\u540e\u9762\u6dfb\u52a0 \u5206\u53f7 \uff0c\u5728\u5217\u8868\u6700\u540e\u4e00\u9879\u7684\u540e\u9762\u6dfb\u52a0 \u53e5\u53f7 \uff1b\u5bf9\u4e8e\u65e0\u5e8f\u5217\u8868\uff0c\u63a8\u8350\u5728\u6bcf\u4e00\u9879\u7684\u540e\u9762\u6dfb\u52a0 \u53e5\u53f7 \u3002 \u6ce8\u610f\u533a\u5206\u5404\u79cd\u4e0d\u540c\u7684\u8fde\u63a5\u53f7\uff0c\u5982 hyphen\uff08\u4e00\u822c\u4f7f\u7528 U+002D hyphen-minus\uff08-\uff09\uff0c\u5373\u952e\u76d8\u4e0a\u7684\u300c\u51cf\u53f7\u300d\u4ee3\u66ff\uff09\uff0cU+2013 en dash\uff08\u2013\uff09\u548c U+2014 em dash\uff08\u2014\uff09\u3002\uff08\u82f1\u6587\u4e2d\u8fde\u63a5\u591a\u4e2a\u4eba\u540d\u65f6\uff0c\u987b\u7528 en dash\uff0c\u4f46\u662f\u6781\u5e38\u8bef\u7528\u4e3a hyphen\u3002\u5176\u4ed6\u8bef\u7528\u8f83\u4e3a\u7f55\u89c1\uff0c\u57fa\u672c\u4e0a\u53ea\u9700\u8bb0\u4f4f\u8fd9\u4e00\u70b9\u5373\u53ef\u3002\uff09\u8be6\u89c1 \u8fde\u63a5\u53f7 - \u7ef4\u57fa\u767e\u79d1 \u3002 \u793a\u4f8b \u4e2d\u5b66\u751f\u5b66\u79d1\u7ade\u8d5b\u4e3b\u8981\u5305\u62ec\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\u3001\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\u3001\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\u3001\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\u548c\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\uff08\u8c01\u5199\u7684\u8fd9\u4e2a\u793a\u4f8b\uff0c\u5efa\u8bae\u62ac\u8d70\uff09\u3002 \u300c\u4f60\u5403\u4e86\u5417\uff1f\u300d\u674e\u56db\u95ee\u5f20\u4e09\u3002 \u6211\u60f3\u5bf9\u4f60\u8bf4\uff1a\u300c\u6211\u771f\u662f\u592a\u559c\u6b22\u4f60\u4e86\u3002\u300d \u300c\u82df\u5229\u56fd\u5bb6\u751f\u6b7b\u4ee5\uff0c\u5c82\u56e0\u7978\u798f\u907f\u8d8b\u4e4b\uff01\u300d \u5f20\u534e\u8003\u4e0a\u4e86\u5927\u5b66\uff1b\u674e\u840d\u8fdb\u4e86\u6280\u6821\uff1b\u6211\u5f53\u4e86\u5de5\u4eba\uff1a\u6211\u4eec\u90fd\u6709\u7f8e\u597d\u7684\u524d\u9014\u3002 ^note1 \u4ee5\u4e0b\u662f\u8fd9\u4e2a\u7b97\u6cd5\u7684\u57fa\u672c\u6d41\u7a0b\uff1a \u521d\u59cb\u5316\u5230\u5404\u70b9\u7684\u8ddd\u79bb\u4e3a\u65e0\u7a77\u5927\uff0c\u5c06\u6240\u6709\u70b9\u8bbe\u7f6e\u4e3a\u672a\u88ab\u8bbf\u95ee\u8fc7\uff0c\u521d\u59cb\u5316\u4e00\u4e2a\u961f\u5217\uff1b \u5c06\u8d77\u70b9\u653e\u5165\u961f\u5217\uff0c\u5c06\u8d77\u70b9\u8bbe\u7f6e\u4e3a\u5df2\u88ab\u8bbf\u95ee\u8fc7\uff0c\u66f4\u65b0\u5230\u8d77\u70b9\u7684\u8ddd\u79bb\u4e3a $0$ \uff1b \u53d6\u51fa\u961f\u9996\u5143\u7d20\uff0c\u5c06\u8be5\u5143\u7d20\u8bbe\u7f6e\u4e3a\u672a\u88ab\u8bbf\u95ee\u8fc7\uff1b \u904d\u5386\u6240\u6709\u4e0e\u6b64\u5143\u7d20\u76f8\u8fde\u7684\u8fb9\uff0c\u82e5\u5230\u8fd9\u4e2a\u70b9\u5b58\u5728\u66f4\u77ed\u7684\u8ddd\u79bb\uff0c\u5219\u8fdb\u884c\u677e\u5f1b\u64cd\u4f5c\uff1b \u82e5\u8fd9\u4e2a\u70b9\u672a\u88ab\u8bbf\u95ee\u8fc7\uff0c\u5219\u5c06\u8fd9\u4e2a\u70b9\u653e\u5165\u961f\u5217\uff0c\u4e14\u8bbe\u7f6e\u8fd9\u4e2a\u70b9\u4e3a\u5df2\u7ecf\u8bbf\u95ee\u8fc7\uff1b \u56de\u5230\u7b2c\u4e09\u6b65\uff0c\u76f4\u5230\u961f\u5217\u4e3a\u7a7a\u3002 KMP \u7b97\u6cd5\uff08Knuth\u2013Morris\u2013Pratt algorithm, KMP algorithm\uff09\u7531 Knuth\u3001Pratt \u548c Morris \u5728 1977 \u5e74\u5171\u540c\u53d1\u5e03\u3002 ^note2","title":"\u6807\u70b9\u7b26\u53f7\u7684\u4f7f\u7528"},{"location":"intro/format.html#markdown","text":"\u8868\u793a\u5f3a\u8c03\u65f6\u8bf7\u4f7f\u7528 **SOMETHING** \u548c \u300c\u300d \uff0c\u800c\u975e\u67d0\u7ea7\u6807\u9898\uff0c\u56e0\u4e3a\u4f7f\u7528\u6807\u9898\u4f1a\u5bfc\u81f4\u6587\u7ae0\u7ed3\u6784\u5c42\u6b21\u6df7\u4e71\u548c\uff08\u6216\uff09\u76ee\u5f55\u51fa\u73b0\u95ee\u9898\u3002 \u5f53\u9700\u8981\u5f15\u7528\u9898\u76ee\u94fe\u63a5\u65f6\uff0c\u5e94\u5c3d\u53ef\u80fd\u4f7f\u7528\u539f OJ \u9898\u5e93\u4e2d\u7684\u94fe\u63a5\u800c\u4e0d\u662f\u955c\u50cf\u94fe\u63a5\u3002 \u8bf7\u6b63\u786e\u4f7f\u7528 Markdown \u7684\u533a\u5757\u529f\u80fd\u3002\u63d2\u5165\u884c\u5185\u4ee3\u7801\u8bf7\u4f7f\u7528\u4e00\u5bf9\u53cd\u5f15\u53f7\u5305\u56f4\u4ee3\u7801\u533a\u5757\uff1b\u884c\u95f4\u4ee3\u7801\u8bf7\u4f7f\u7528\u4e00\u5bf9 ``` \u5305\u56f4\u4ee3\u7801\u533a\u5757\uff0c\u5176\u4e2d\u53cd\u5f15\u53f7\u5c31\u662f\u952e\u76d8\u5de6\u4e0a\u89d2\u6ce2\u6d6a\u7ebf\u4e0b\u9762\u90a3\u4e2a\u7b26\u53f7\uff0c\u884c\u95f4\u4ee3\u7801\u8bf7\u5728\u7b2c\u4e00\u4e2a ``` \u7684\u540e\u9762\u52a0\u4e0a\u8bed\u8a00\u540d\u79f0\uff08\u5982\uff1a ```cpp \uff09\u3002 \u793a\u4f8b ```cpp // #include<stdio.h> //\u4e0d\u597d\u7684\u5199\u6cd5 #include <cstdio> //\u597d\u7684\u5199\u6cd5 ``` // #include<stdio.h> //\u4e0d\u597d\u7684\u5199\u6cd5 #include <cstdio> //\u597d\u7684\u5199\u6cd5 \u300c\u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca\u300d\u4f7f\u7528 Markdown \u7684\u811a\u6ce8\u529f\u80fd\u8fdb\u884c\u7f16\u5199\u3002\u683c\u5f0f\u4e3a\uff1a \u6587\u672c\u5185\u5bb9\u3002[^\u811a\u6ce8\u540d] [ ^\u811a\u6ce8\u540d ]: \u53c2\u8003\u8d44\u6599\u5185\u5bb9\u3002\u6ce8\u610f\uff1a\u5192\u53f7\u662f\u82f1\u6587\u5192\u53f7\uff0c\u5192\u53f7\u540e\u9762\u8ddf\u7740\u4e00\u4e2a\u7a7a\u683c\u3002 \u811a\u6ce8\u540d\u65e2\u53ef\u4ee5\u4f7f\u7528\u6570\u5b57\u4e5f\u53ef\u4ee5\u4f7f\u7528\u6587\u672c\u3002\u811a\u6ce8\u540d\u6446\u653e\u7684\u4f4d\u7f6e\u4e0e\u62ec\u53f7\u7684\u7528\u6cd5\u4e00\u81f4\u3002\u4e3a\u7f8e\u89c2\u8d77\u89c1\uff0c\u5efa\u8bae\u540c\u4e00\u4e2a\u9875\u9762\u5185\u7684\u811a\u6ce8\u540d\u9075\u5faa\u7edf\u4e00\u7684\u547d\u540d\u89c4\u5f8b\uff0c\u5982\uff1aref1\u3001ref2\u3001note1\u2026\u2026 \u811a\u6ce8\u7684\u5185\u5bb9\u7edf\u4e00\u653e\u5728 ## \u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca \u4e8c\u7ea7\u6807\u9898\u4e0b\u3002 \u793a\u4f8b \u5f53 `#include <cxxxx>` \u53ef\u4ee5\u66ff\u4ee3 `#include <xxxx.h>` \u65f6\uff0c\u5e94\u4f7f\u7528\u524d\u8005\u3002[^ref1] 2020\u5e741\u670821\u65e5\uff0cCCF\u5ba3\u5e03\u6062\u590dNOIP\u3002[^ref2] ## \u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca [ ^ref1 ]: [cstdio stdio.h namespace](https://stackoverflow.com/questions/10460250/cstdio-stdio-h-namespace) [ ^ref2 ]: [CCF\u5173\u4e8e\u6062\u590dNOIP\u7ade\u8d5b\u7684\u516c\u544a-\u4e2d\u56fd\u8ba1\u7b97\u673a\u5b66\u4f1a](https://www.ccf.org.cn/c/2020-01-21/694716.shtml) \u5f53 #include <cxxxx> \u53ef\u4ee5\u66ff\u4ee3 #include <xxxx.h> \u65f6\uff0c\u5e94\u4f7f\u7528\u524d\u8005\u3002[^ref1] 2020 \u5e74 1 \u6708 21 \u65e5\uff0cCCF \u5ba3\u5e03\u6062\u590d NOIP\u3002[^ref2] \u5efa\u8bae\u4f7f\u7528\u4e3b\u9898\u6269\u5c55\u7684 ???+note \u683c\u5f0f\uff08\u5373 Collapsible Blocks \uff09\u6765\u63cf\u8ff0\u9898\u9762\u548c\u53c2\u8003\u4ee3\u7801\u3002\u4e5f\u53ef\u4ee5\u7528\u8fd9\u79cd\u683c\u5f0f\u6765\u5c55\u793a\u5176\u4ed6\u9700\u8981\u8865\u5145\u4ecb\u7ecd\u7684\u5185\u5bb9\u3002 \u793a\u4f8b\u4ee3\u7801\uff1a ??? note \"\u6807\u9898\" \u8fd9\u4e2a\u6587\u672c\u6846\u4f1a\u88ab\u9ed8\u8ba4\u6298\u53e0\u3002 \u63a8\u8350\u5c06 **\u89e3\u9898\u4ee3\u7801** \u653e\u5728\u6298\u53e0\u6587\u672c\u6846\u5185\u3002 ???+note \"[HDOJ \u7684\u300cA + B Problem\u300d](https://acm.hdu.edu.cn/showproblem.php?pid=1000)\" \u6807\u9898\u4e5f\u53ef\u4ee5\u4f7f\u7528 Markdown \u7684\u8d85\u94fe\u63a5\u3002\u8fd9\u91cc\u7684\u8d85\u94fe\u63a5\u662f HDOJ \u7684\u300cA + B Problem\u300d\u3002 \u800c\u4e14\u63a8\u8350\u4ee5\u8fd9\u79cd\u65b9\u5f0f**\u6807\u6ce8\u539f\u9898\u94fe\u63a5**\u3002 \u6ce8\u610f\u53cc\u5f15\u53f7\u7684\u4f4d\u7f6e\u3002 \u6548\u679c\uff1a \u6807\u9898 \u8fd9\u4e2a\u6587\u672c\u6846\u4f1a\u88ab\u9ed8\u8ba4\u6298\u53e0\u3002 \u63a8\u8350\u5c06 \u89e3\u9898\u4ee3\u7801 \u653e\u5728\u6298\u53e0\u6587\u672c\u6846\u5185\u3002 HDOJ \u7684\u300cA + B Problem\u300d \u6807\u9898\u4e5f\u53ef\u4ee5\u4f7f\u7528 Markdown \u7684\u8d85\u94fe\u63a5\u3002\u8fd9\u91cc\u7684\u8d85\u94fe\u63a5\u662f HDOJ \u7684\u300cA + B Problem\u300d\u3002 \u800c\u4e14\u63a8\u8350\u4ee5\u8fd9\u79cd\u65b9\u5f0f \u6807\u6ce8\u539f\u9898\u94fe\u63a5 \u3002 \u6ce8\u610f\u53cc\u5f15\u53f7\u7684\u4f4d\u7f6e\u3002 \u4e24\u79cd\u683c\u5f0f\u7684\u533a\u522b\u662f\uff0c\u5e26 + \u7684\u4f1a\u9ed8\u8ba4\u4fdd\u6301\u5c55\u5f00\uff0c\u800c\u4e0d\u5e26 + \u7684\u4f1a\u9ed8\u8ba4\u4fdd\u6301\u6298\u53e0\u3002 \u6298\u53e0\u6846\u7684\u6807\u9898\uff0c\u5373 ???+note \u4e2d note \u540e\u7684\u5185\u5bb9\u5e94\u4ee5 \" \u5305\u88f9\u8d77\u6765\u3002\u5176\u4e2d\u7684\u5185\u5bb9\u652f\u6301 Markdown \u8bed\u6cd5\u3002\u8be6\u89c1 Admonition - Changing the title \u3002\uff08\u4e0d\u5177\u5907\u6298\u53e0\u529f\u80fd\u7684\u4e3a\u4e00\u822c\u7684 Admonitions\uff0c\u53c2\u8003 Admonitions - Material for MkDocs \uff09 \u5f53\u9700\u8981\u6dfb\u52a0\u4e0d\u540c\u8bed\u8a00\u7684\u4ee3\u7801\u65f6\uff0c\u63a8\u8350\u4f7f\u7528 Content tabs\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4e0d\u540c\u8bed\u8a00\u4ee3\u7801\u7684\u5207\u6362\u3002Content tabs \u8fd8\u6709\u5176\u4ed6\u7684\u7528\u6cd5\uff0c\u8be6\u89c1 Content tabs \u3002\u5176\u4f7f\u7528\u65b9\u6cd5\u548c\u6548\u679c\u5982\u4e0b\u3002 \u793a\u4f8b \u6ce8\u610f\u9700\u8981\u5728\u6587\u672c\u524d\u9762\u6dfb\u52a0 4 \u4e2a\u7a7a\u683c\u3002\u5176\u4ed6\u7684\u8bed\u6cd5\u8fd8\u662f\u4e0e Markdown \u8bed\u6cd5\u4e00\u81f4\u3002 === \"C\" ``` c #include <stdio.h> int main(void) { printf(\"Hello world!\\n\"); return 0; } ``` === \"C++\" ``` c++ #include <iostream> int main(void) { std::cout << \"Hello world!\" << std::endl; return 0; } ``` C C++ #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } #include <iostream> int main ( void ) { std :: cout << \"Hello world!\" << std :: endl ; return 0 ; } \u5982\u679c\u5bf9 mkdocs-material\uff08\u6211\u4eec\u4f7f\u7528\u7684\u8fd9\u4e2a\u4e3b\u9898\uff09\u8fd8\u6709\u4ec0\u4e48\u95ee\u9898\uff0c\u8fd8\u53ef\u4ee5\u67e5\u9605 MkDocs \u4f7f\u7528\u8bf4\u660e \uff0c\u5176\u4ecb\u7ecd\u4e86 mkdocs-material \u4e3b\u9898\u7684\u63d2\u4ef6\u4f7f\u7528\u65b9\u5f0f\u3002","title":"Markdown \u683c\u5f0f\u4e0e\u4e3b\u9898\u6269\u5c55\u683c\u5f0f\u8981\u6c42"},{"location":"intro/format.html#_6","text":"\u6240\u6709\u7684 OI Wiki \u6587\u672c\u90fd\u5e94\u4f7f\u7528\u7c97\u4f53\u6807\u8bb0\u3002 \u5728\u9875\u9762\u7684\u5f00\u5934\u5e94\u6709\u4e00\u6bb5\u7b80\u77ed\u7684\u6587\u5b57\uff08\u5982\u300c\u672c\u9875\u9762\u5c06\u4ecb\u7ecd\u2026\u2026\u300d\uff09\uff0c\u7528\u4e8e\u6982\u8ff0\u9875\u9762\u5185\u5bb9\u3002 \u793a\u4f8b \u672c\u9875\u9762\u5c06\u5217\u51fa\u5728 OI Wiki \u7f16\u5199\u8fc7\u7a0b\u65f6\u63a8\u8350\u4f7f\u7528\u7684\u683c\u5f0f\u89c4\u8303\u4e0e\u7f16\u8f91\u65b9\u9488\u3002 \u6d89\u53ca\u5230\u300c\u524d\u7f6e\u77e5\u8bc6\u300d\u7684\u9875\u9762\uff0c\u8bf7\u5728\u5f00\u5934\u6dfb\u52a0\u4e00\u884c \u524d\u7f6e\u77e5\u8bc6\uff1a\u2026\u2026 \uff0c\u653e\u5728\u9875\u9762\u6982\u8ff0\u524d\u3002\u683c\u5f0f\u5982\u4e0b\uff1a \u524d\u7f6e\u77e5\u8bc6\uff1a[\u7ad9\u5185\u9875\u97621](url1)\u3001[\u7ad9\u5185\u9875\u97622](url2)\u548c[\u7ad9\u5185\u9875\u97623](url3) \u793a\u4f8b \u524d\u7f6e\u77e5\u8bc6\uff1a \u65f6\u95f4\u590d\u6742\u5ea6 \u672c\u9875\u9762\u5c06\u4ecb\u7ecd\u57fa\u7840\u7684\u8ba1\u7b97\u7406\u8bba\u7684\u77e5\u8bc6\u3002 \u8bf7\u6ce8\u610f\u6587\u6863\u7ed3\u6784\u3002\u6587\u6863\u7ed3\u6784\u5e94\u5f53\u5341\u5206\u6761\u7406\uff0c\u5c42\u6b21\u6e05\u6670\u3002\u8bf7\u4e0d\u8981\u8ba9\u8bf8\u5982\u300c\u4e94\u7ea7\u6807\u9898\u300d\u8fd9\u79cd\u4e8b\u60c5\u518d\u6b21\u53d1\u751f\u4e86\uff0c\u4e00\u7bc7\u6b63\u5e38\u7684\u6587\u7ae0\u662f\u7528\u4e0d\u5230\u5982\u6b64\u590d\u6742\u7684\u7ed3\u6784\u5c42\u6b21\u7684\u3002 \u8bf7\u6ce8\u610f\u5185\u5bb9\u7684\u8868\u8ff0\u3002\u4f5c\u4e3a\u4e00\u4e2a\u767e\u79d1\u7f51\u7ad9\uff0c OI Wiki \u4f7f\u7528\u7684\u8bed\u8a00\u5e94\u8be5\u662f\u4e66\u9762\u7684\uff0c\u5ba2\u89c2\u7684\u3002\u8bf8\u5982\u300c\u6296\u673a\u7075\u300d\u6027\u8d28\u7684\uff0c\u5bf9\u8bfb\u8005\u7406\u89e3\u5e2e\u52a9\u4e0d\u5927\u7684\u5185\u5bb9\uff0c\u4e0d\u5e94\u8be5\u51fa\u73b0\u5728 OI Wiki \u5f53\u4e2d\u3002 \u8bf7\u5c3d\u91cf\u4e3a\u94fe\u63a5\u63d0\u4f9b\u5b8c\u6574\u7684\u6807\u9898\u3001\u6216\u8005\u53ef\u88ab\u8bc6\u522b\u7684\u63d0\u793a\uff0c\u907f\u514d\u4f7f\u7528\u88f8\u5730\u5740\u548c\u300c\u8fd9\u300d\u3001\u300c\u6b64\u300d\u4e4b\u7c7b\u7684\u6a21\u7cca\u4e0d\u6e05\u7684\u63cf\u8ff0\u3002\u6bcf\u4e00\u4e2a\u8d85\u94fe\u63a5\u90fd\u5e94\u5c3d\u91cf\u5bf9\u5176\u52a0\u4ee5\u6e05\u695a\u660e\u786e\u7684\u63cf\u8ff0\uff0c\u65b9\u4fbf\u8bfb\u8005\u660e\u767d\u8be5\u8d85\u94fe\u63a5\u5c06\u6307\u5411\u4f55\u5904\u3002 \u5efa\u8bae\u4f7f\u7528\u6e90\u6587\u7ae0\u6216\u8005\u6807\u7b7e\u9875\u7684\u6807\u9898\u3002 \u4e0d\u63a8\u8350\u7684\u5199\u6cd5 \u8bf7\u53c2\u8003[\u8fd9\u4e2a\u9875\u9762](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) \u8bf7\u53c2\u8003 <https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork> \u8bf7\u53c2\u8003 \u8fd9\u4e2a\u9875\u9762 \u8bf7\u53c2\u8003 https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork \u63a8\u8350\u7684\u5199\u6cd5 \u8bf7\u53c2\u8003 GitHub \u5b98\u65b9\u7684\u5e2e\u52a9\u9875\u9762 [ Syncing a fork - GitHub Docs ]( https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork ) \u8bf7\u53c2\u8003 GitHub \u5b98\u65b9\u7684\u5e2e\u52a9\u9875\u9762 Syncing a fork - GitHub Docs \u53d7 Markdown \u683c\u5f0f\u9650\u5236\uff0c ## \u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca \u4e8c\u7ea7\u6807\u9898\u5fc5\u987b\u653e\u5728\u6587\u672b\u3002 \u6240\u6709\u7528\u4f5c\u5e8f\u53f7\u7684\u6570\u5b57\u5efa\u8bae\u4f7f\u7528\u4e2d\u6587\u3002\u793a\u4f8b\uff1a \u6570\u5217\u7684\u7b2c\u4e00\u9879\u3002 \u8f93\u5165\u6587\u4ef6\u7684\u7b2c\u4e00\u884c\u3002 \u8bf7\u5c3d\u91cf\u907f\u514d\u5728\u6807\u9898\u4e2d\u4f7f\u7528 MathJax \u516c\u5f0f\uff0c\u65e0\u8bba\u662f\u51e0\u7ea7\u6807\u9898\u3002\u5728\u6807\u9898\u4e2d\u4f7f\u7528\u516c\u5f0f\u6709\u53ef\u80fd\u4f1a\u5bfc\u81f4\u76ee\u5f55\u663e\u793a\u9519\u8bef\u3002 ^ref3 \u8bf7\u6ce8\u610f\u4ee3\u7801\u7684\u53ef\u8bfb\u6027\u3002 \u4ee3\u7801\u5e94\u62e5\u6709\u6e05\u6670\u7684\u903b\u8f91\u3002 \u5efa\u8bae\u5728\u53c2\u8003\u4ee3\u7801\u4e2d\u6dfb\u52a0\u9002\u5f53\u6ce8\u91ca\u4ee5\u65b9\u4fbf\u8bfb\u8005\u7406\u89e3\u3002 \u5c3d\u91cf\u907f\u514d\u51fa\u73b0\u5f71\u54cd\u9605\u8bfb\u7684\u9884\u7f16\u8bd1\u6307\u4ee4\u548c\u5b8f\u5b9a\u4e49\u3002","title":"\u6587\u672c\u5185\u5bb9\u7684\u683c\u5f0f\u8981\u6c42"},{"location":"intro/format.html#latex","text":"LaTeX \u4f5c\u4e3a\u516c\u5f0f\u6392\u7248\u7684\u9996\u9009\uff0c\u6211\u4eec\u5e94\u5f53\u6b63\u786e\u5730\u4f7f\u7528\u5b83\u3002\u56e0\u6b64\u5bf9\u4e8e LaTeX \u7684\u4f7f\u7528\u6211\u4eec\u6709\u4e25\u683c\u7684\u8981\u6c42\u3002\u5982\u679c\u60a8\u60f3\u8981\u5feb\u901f\u4e0a\u624b\uff0c\u53ef\u4ee5\u9605\u8bfb\u672c\u7ae0\u8282\u672b\u7ed9\u51fa\u7684\u8868\u683c\u3002 \u60a8\u4f7f\u7528\u7684\u7b26\u53f7\u4e0d\u5e94\u4e0e \u6570\u5b66\u7b26\u53f7\u8868 \u89c4\u5b9a\u7684\u7b26\u53f7\u51b2\u7a81\u3002 \u4f7f\u7528 Roman \u4f53\u8868\u793a\u6570\u5b57\u3001\u5e38\u91cf\u3001\u7b97\u5b50\u548c\u51fd\u6570\u3002\u4f7f\u7528 Italic \u4f53\u8868\u793a\u53d8\u91cf\u3001\u4e0b\u6807\u3002LaTeX \u5df2\u7ecf\u9884\u5148\u5b9a\u4e49\u597d\u4e86\u4e00\u4e9b\u5e38\u89c1\u7684\u5e38\u91cf\u3001\u51fd\u6570\u3001\u8fd0\u7b97\u7b26\u7b49\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\uff1a \\log , \\ln , \\lg , \\sin , \\cos , \\tan , \\sec , \\csc , \\cot , \\gcd , \\min , \\max , \\exp , \\inf , \\mod , \\bmod , \\pmod \u6240\u4ee5\u5728\u8f93\u5165\u5e38\u91cf\u3001\u51fd\u6570\u540d\u3001\u8fd0\u7b97\u7b26\u7b49\u65f6\uff0c\u8bf7\u5148\u68c0\u67e5\u4e00\u4e0b\u662f\u5426\u5e94\u8be5\u4f7f\u7528 Roman \u4f53\u6216\u5176\u5b83\u5b57\u4f53\u3002LaTeX \u7b26\u53f7\u7684\u4e66\u5199\u53ef\u53c2\u8003 KaTeX \u7684 Supported Functions \u9875\u9762 \uff08\u4e0d\u662f\u5168\u90e8\uff09\uff0c\u4e5f\u53ef\u4ee5\u641c\u7d22\u6c42\u89e3\u3002 \u7531\u4e8e LaTeX \u4e66\u5199 Roman \u4f53\u5c0f\u5199\u5e0c\u814a\u5b57\u6bcd\u8f83\u4e3a\u56f0\u96be\uff0c\u6545\u5c0f\u5199\u5e0c\u814a\u5b57\u6bcd\u5e38\u91cf\u3001\u7b97\u5b50\u548c\u51fd\u6570\u53ef\u4ee5\u4f7f\u7528 Italic \u4f53\uff0c\u5982 $\\pi$ \u4ee5\u53ca $\\delta x$ \u4e2d\u7684 $\\delta$ . \u5982\u679c\u9047\u5230\u6ca1\u6709\u9884\u5148\u5b9a\u4e49\u597d\u7684\u9700\u8981\u4f7f\u7528 Roman \u4f53\u7684 \u51fd\u6570\u540d \uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 $\\operatorname{something}$ \u6765\u4ea7\u751f\uff0c\u5982\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 $\\operatorname{lcm}$ \u4ea7\u751f\u6b63\u4f53\u7684\u6700\u5c0f\u516c\u500d\u6570\uff08\u51fd\u6570\uff09\u7b26\u53f7\u3002\u540c\u7406\uff0c\u4ea7\u751f Roman \u4f53\u7684 \u5e38\u91cf \u5e94\u7528 $\\mathrm{}$ \uff1b\u4ea7\u751f Roman \u4f53\u7c97\u4f53\u7b26\u53f7\u5e94\u7528 $\\mathbf{}$ \uff1b\u4ea7\u751f Italic \u4f53\u7c97\u4f53\u7b26\u53f7\u5e94\u7528 $\\boldsymbol{}$ \uff08\u5982\u5411\u91cf $\\boldsymbol{a}$ \uff09\u3002\u5bf9\u4e8e\u591a\u5b57\u6bcd\u7684\u53d8\u91cf\uff0c\u5e94\u5f53\u4f7f\u7528 $\\textit{}$ \u3002\u5176\u4ed6\u975e\u6570\u5b66\u5185\u5bb9\uff0c\u5305\u62ec\u82f1\u6587\u3001\u7279\u6b8a\u7b26\u53f7\u7b49\uff0c\u4e00\u5f8b\u4f7f\u7528 $\\text{}$ \u3002\u4e2d\u6587\u6211\u4eec\u5219\u5efa\u8bae\u4e0d\u653e\u5728 LaTeX \u516c\u5f0f\u4e2d\u3002 \u5982\u679c\u8868\u8fbe\u5f0f\u987b\u6298\u884c\uff08\u5e38\u89c1\u4e8e\u8f83\u957f\u7684\u884c\u95f4\u516c\u5f0f\u4e2d\uff09\uff0c\u5219\u5e94\u9075\u5faa\u5982\u4e0b\u6362\u884c\u89c4\u5219\uff1a \u5c06\u6362\u884c\u7b26\u653e\u5728 $=$ \uff0c $+$ \uff0c $-$ \uff0c $\\pm$ \uff0c $\\mp$ \u4e4b\u524d\uff0c\u5982\u679c\u6709\u5fc5\u8981\uff0c\u4e5f\u53ef\u653e\u5728 $\\times$ \uff0c $\\cdot$ \uff0c $/$ \u4e4b\u524d\uff0c\u5982\uff1a $$ \\begin{aligned} \\mathrm{e}^x &= \\sum\\limits_{n=0}^{\\infty} \\frac{x^n}{n!} \\\\ &= \\phantom{+} 1 + x + \\frac{x^2}{2} \\\\ & \\phantom{=} + \\frac{x^3}{6} + \\frac{x^4}{24} + \\dots \\\\ \\end{aligned} $$ \u540c\u4e00\u8fd0\u7b97\u7b26\u4e0d\u5e94\u5728\u6362\u884c\u7b26\u524d\u540e\u540c\u65f6\u51fa\u73b0\uff0c \u6362\u884c\u7b26\u5c3d\u91cf\u4e0d\u8981\u51fa\u73b0\u5728\u62ec\u53f7\u5185\u7684\u8868\u8fbe\u5f0f\u4e2d\u3002 \u5728\u884c\u5185\u4f7f\u7528\u5206\u6570\u7684\u65f6\u5019\uff0c\u8bf7\u4f7f\u7528 $\\dfrac{}{}$ \u3002\u6bd4\u5982 $\\dfrac{1}{2}$ \uff0c\u6548\u679c $\\dfrac{1}{2}$ \uff0c\u800c\u4e0d\u662f $\\frac{1}{2}$ \uff0c\u6548\u679c $\\frac{1}{2}$ \u3002 \u7ec4\u5408\u6570\u8bf7\u4f7f\u7528 \\dbinom{n}{m} \uff0c\u6548\u679c $\\dbinom{n}{m}$ \uff0c\u800c\u4e0d\u662f {n \\choose m} \uff08\u5728 LaTeX \u4e2d\u8fd9\u79cd\u5199\u6cd5\u5df2\u4e0d\u63a8\u8350\uff09\uff1b\u4e0e\u4e0a\u4e00\u6761\u5173\u4e8e\u5206\u6570\u7684\u7ea6\u5b9a\u76f8\u4f3c\uff0c\u8bf7\u4e0d\u8981\u4f7f\u7528 \\binom{n}{m} \uff0c\u6548\u679c $\\binom{n}{m}$ \u3002 \u5c3d\u53ef\u80fd\u907f\u514d\u5728\u884c\u5185\u4f7f\u7528\u5de8\u8fd0\u7b97\u7b26\uff08\u5982 $\\sum$ \uff0c $\\prod$ \uff0c $\\int$ \u7b49\uff09\u3002 \u5728\u4e0d\u4f1a\u5f15\u8d77\u6b67\u4e49\u7684\u60c5\u51b5\u4e0b\uff0c\u8bf7\u7528 $\\times$ \u4ee3\u66ff\u661f\u53f7\uff0c\u53c9\u4e58\u8bf7\u4f7f\u7528 $\\times$ \uff0c\u70b9\u4e58\u8bf7\u4f7f\u7528 $\\cdot$ \u3002\u5982 $a\\times b$ \uff0c $a\\cdot b$ \uff0c\u800c\u4e0d\u662f $a\\ast b$ \u3002 \u8bf7\u7528 $\\cdots$ \uff08\u5c45\u4e8e\u6392\u7248\u57fa\u7ebf\u4e0e\u9876\u7ebf\u4e2d\u95f4\uff09\uff0c $\\ldots$ \uff08\u5c45\u4e8e\u6392\u7248\u57fa\u7ebf\u7684\u4f4d\u7f6e\uff09\uff0c $\\vdots$ \uff08\u7ad6\u7740\u7684\u7701\u7565\u53f7\uff09\u4ee3\u66ff $...$ \u3002\u5982 $a_1,a_2,\\cdots a_n$ \uff0c\u800c\u4e0d\u662f $a_1,a_2,... a_n$ \u3002 \u8bf7\u6ce8\u610f\uff0c\u4e0d\u8981\u5728\u975e\u4ee3\u7801\u533a\u57df\u4f7f\u7528\u4efb\u4f55\u7a0b\u5e8f\u8bbe\u8ba1\u8bed\u8a00\u7684\u8868\u793a\u65b9\u5f0f\uff0c\u800c\u662f\u4f7f\u7528 LaTeX \u516c\u5f0f\u3002\u4f8b\u5982\uff0c\u4f7f\u7528 $=$ \u800c\u4e0d\u662f $==$ \uff08\u5982 $a=b$ \uff0c\u800c\u4e0d\u662f $a==b$ \uff09\u3001\u4f7f\u7528 `a<<1` \u6216\u8005 $a\\times 2$ \u800c\u4e0d\u662f $a<<1$ \u3001\u4f7f\u7528 $a\\bmod b$ \u4ee3\u66ff $a\\%b$ \uff08\u5982 $a\\bmod b$ \uff0c\u800c\u4e0d\u662f $a\\%b$ \uff09\u7b49\u3002 \u516c\u5f0f\u4e2d\u4e0d\u8981\u4f7f\u7528\u4e2d\u62ec\u53f7\u8fde\u7f00\uff08\u5373 C++ \u9ad8\u7ef4\u6570\u7ec4\u7684\u8868\u793a\u65b9\u5f0f\uff09\u800c\u591a\u4f7f\u7528\u4e0b\u6807\u3002\u5373 $a_{i,j,k}$ \u800c\u4e0d\u662f $a[i][j][k]$ \u3002\u5728\u516c\u5f0f\u4e2d\u4e0b\u6807\u8f83\u590d\u6742\u7684\u60c5\u51b5\u4e0b\u5efa\u8bae\u6539\u7528\u591a\u5143\u51fd\u6570\uff08 $f(i,j,k)$ \uff09\u6216\u5185\u8054\u4ee3\u7801\u683c\u5f0f\u3002\u5bf9\u4e8e\u4e00\u5143\u7b80\u5355\u51fd\u6570\u4f7f\u7528 $f_i$ \u3001 $f(i)$ \u6216 $f[i]$ \u5747\u53ef\u3002 \u4e3a\u4e86\u7edf\u4e00\u4e14\u4e66\u5199\u65b9\u4fbf\uff0c\u590d\u6742\u5ea6\u5206\u6790\u65f6\u5927 $O$ \u8bb0\u53f7\u8bf7\u76f4\u63a5\u4f7f\u7528 $O()$ \u800c\u4e0d\u662f $\\mathcal O()$ \u3002 \u5728\u8868\u793a\u7b49\u4ef7\u5173\u7cfb\u65f6\uff0c\u8bf7\u4f7f\u7528 $\\iff$ \uff0c\u6548\u679c $\\iff$ \uff0c\u800c\u4e0d\u662f $\\Leftrightarrow$ \uff0c\u6548\u679c $\\Leftrightarrow$ \u3002 \u5206\u6bb5\u51fd\u6570\u73af\u5883 cases \u53ea\u80fd\u6709\u4e24\u5217 \uff08\u5373\u4e00\u4e2a & \u5206\u9694\u7b26\uff09\u3002 \u8bf7\u4e0d\u8981\u6ee5\u7528 LaTeX \u516c\u5f0f\u3002\u8fd9\u4e0d\u4ec5\u4f1a\u9020\u6210\u9875\u9762\u52a0\u8f7d\u7f13\u6162\uff08\u56e0\u4e3a MathJax \u7684\u6548\u7387\u4f4e\u662f\u51fa\u4e86\u540d\u7684\uff09\uff0c\u540c\u65f6\u4e5f\u4f1a\u5bfc\u81f4\u9875\u9762\u7684\u6392\u7248\u6df7\u4e71\u3002\u6211\u4eec\u901a\u5e38\u4f7f\u7528 LaTeX \u516c\u5f0f\u5b57\u4f53\u8868\u793a\u53d8\u91cf\u540d\u79f0\u3002\u6211\u4eec\u7684\u5efa\u8bae\u662f\uff0c\u5982\u975e\u5fc5\u8981\uff0c\u5c3d\u91cf\u51cf\u5c11\u516c\u5f0f\u4e0e\u666e\u901a\u6b63\u6587\u5b57\u4f53\u7684 \u5927\u91cf \u6df7\u5408\u4f7f\u7528\uff0c\u5982\u975e\u5fc5\u8981\uff0c\u5c3d\u91cf\u4e0d\u8981\u4f7f\u7528\u516c\u5f0f\uff0c\u5982\uff1a \u6211\u4eec\u5c06\u8981\u5b66\u4e60 $ Network - flow $ \u4e2d\u7684 $ SPFA $ \u6700\u5c0f\u8d39\u7528\u6d41\uff0c\u9700\u8981\u4f7f\u7528 $ Edmonds\u2013Karp $ \u7b97\u6cd5\u8fdb\u884c\u589e\u5e7f\u3002 \u5c31\u662f\u4e00\u4e2a\u5178\u578b\u7684 \u6ee5\u7528\u516c\u5f0f\u5b57\u4f53 \u7684\u4f8b\u5b50\u3002\uff08\u5728\u9875\u9762\u4e2d\u4f7f\u7528\u659c\u4f53\u8bf7\u7528 *\u6587\u672c* \u8868\u793a\u3002\uff09 \u8bf7\u6b63\u786e\u4f7f\u7528\u5bf9\u5e94\u7684 LaTeX \u7b26\u53f7\uff0c\u5c24\u5176\u662f\u516c\u5f0f\u4e2d\u7684\u5e0c\u814a\u5b57\u6bcd\u7b49\u7279\u6b8a\u7b26\u53f7\u3002\u5982\u6b27\u62c9\u51fd\u6570\u8bf7\u4f7f\u7528 $\\varphi$ \uff0c\u5706\u7684\u76f4\u5f84\u8bf7\u4f7f\u7528 $\\Phi$ \uff0c\u9ec4\u91d1\u5206\u5272\u8bf7\u4f7f\u7528 $\\phi$ \u3002\u8fd9\u4e9b\u7b26\u53f7\u867d\u7136\u540c\u6837\u8868\u793a\u5e0c\u814a\u5b57\u6bcd Phi\uff0c\u4f46\u662f\u5728\u4e0d\u540c\u7684\u73af\u5883\u4e0b\u6709\u4e0d\u540c\u7684\u542b\u4e49\u3002\u5207\u8bb0 \u4e0d\u8981\u4f7f\u7528\u8f93\u5165\u6cd5\u7684\u63d2\u5165\u7279\u6b8a\u7b26\u53f7 \u6765\u63d2\u5165\u8fd9\u79cd\u7b26\u53f7\u3002 \u53e6\u5916\uff0c\u7531\u4e8e LaTeX \u5386\u53f2\u539f\u56e0\uff0c\u7a7a\u96c6\u7684\u7b26\u53f7\u5e94\u4e3a $\\varnothing$ \u800c\u4e0d\u662f $\\emptyset$ \uff1b\u5176\u4ed6\u7684\u7b26\u53f7\u5e94\u53c2\u7167 \u6570\u5b66\u7b26\u53f7\u8868 \u4e66\u5199\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u8868\u683c\u6765\u603b\u7ed3\u4e00\u4e0b\u4e0a\u8ff0\u5185\u5bb9\u3002\u6ce8\u610f\u672c\u8868\u683c\u6ca1\u6709\u4e3e\u51fa\u6240\u6709\u7b26\u53f7\u7684\u7528\u6cd5\uff0c\u53ea\u7ed9\u51fa\u5e38\u89c1\u7684\u9519\u8bef\u3002\u7c7b\u4f3c\u7684\u60c5\u51b5\u7c7b\u6bd4\u5373\u53ef\u3002 \u4e0d\u7b26\u5408\u89c4\u5b9a\u7684\u7528\u6cd5 \u6e32\u67d3\u6548\u679c \u7b26\u5408\u89c4\u5b9a\u7684\u7528\u6cd5 \u6e32\u67d3\u6548\u679c $log, ln, lg$ $log, ln, lg$ $\\log$, $\\ln$, $\\lg$ $\\log$ \uff0c $\\ln$ \uff0c $\\lg$ $sin, cos, tan$ $sin, cos, tan$ $\\sin$, $\\cos$, $\\tan$ $\\sin$ \uff0c $\\cos$ \uff0c $\\tan$ $gcd, lcm$ $gcd, lcm$ $\\gcd$, $\\operatorname{lcm}$ $\\gcd$ \uff0c $\\operatorname{lcm}$ $e$, $\\text{e}$, e \uff08\u81ea\u7136\u5bf9\u6570\u7684\u5e95\uff09 $e$ \uff0c $\\text{e}$ , e $\\mathrm{e}$ $\\mathrm{e}$ $i$, $\\text{i}$, i \uff08\u865a\u6570\u5355\u4f4d\uff09 $i$ \uff0c $\\text{i}$ , i $\\mathrm{i}$ $\\mathrm{i}$ $ \u5c0f\u4e8e a \u7684\u8d28\u6570 $ $\u5c0f\u4e8e a \u7684\u8d28\u6570$ \u5c0f\u4e8e $a$ \u7684\u8d28\u6570 \u5c0f\u4e8e $a$ \u7684\u8d28\u6570 $...$ $...$ $\\cdots$, $\\ldots$, $\\vdots$, $\\ddots$ $\\cdots$ \uff0c $\\ldots$ \uff0c $\\vdots$ \uff0c $\\ddots$ $a*b$ \uff08\u4e24\u4e2a\u6570\u76f8\u4e58\uff09 $a*b$ $a\\times b$, $a\\cdot b$ $a\\times b$ \uff0c $a\\cdot b$ $SPFA$ \uff08\u82f1\u6587\u540d\u79f0\uff09 $SPFA$ SPFA SPFA $a==b$ $a==b$ $a=b$ $a=b$ $f[i][j][k]$ $f[i][j][k]$ $f_{i,j,k}$, $f(i,j,k)$ $f_{i,j,k}$ \uff0c $f(i,j,k)$ $R,N^*$ \uff08\u96c6\u5408\uff09 $R,N^*$ $\\mathbf{R}$, $\\mathbf{N}^*$ $\\mathbf{R}$ \uff0c $\\mathbf{N}^*$ $\\emptyset$ $\\emptyset$ $\\varnothing$ $\\varnothing$ $size$ $size$ $\\textit{size}$ $\\textit{size}$","title":"LaTeX \u516c\u5f0f\u7684\u683c\u5f0f\u8981\u6c42"},{"location":"intro/format.html#_7","text":"\u8bf7\u6ce8\u610f\uff0c\u5c3d\u7ba1\u4e0a\u8ff0\u8f93\u5165\u516c\u5f0f\u7684\u8bed\u6cd5\u548c\u771f\u6b63\u7684 LaTeX \u6392\u7248\u7cfb\u7edf\u975e\u5e38\u76f8\u4f3c\uff0c\u4f46 MathJax \u548c LaTeX \u662f\u4e24\u4e2a\u5b8c\u5168\u6ca1\u6709\u5173\u7cfb\u7684\u4e1c\u897f \uff0cMathJax \u4ec5\u4ec5\u4f7f\u7528\u4e86\u4e00\u90e8\u5206\u4e0e LaTeX \u975e\u5e38\u76f8\u4f3c\u7684\u8bed\u6cd5\u800c\u5df2\u3002\u5b9e\u9645\u4e0a\uff0c\u4e8c\u8005\u4e4b\u95f4\u6709\u4e0d\u5c11\u7ec6\u8282\u5dee\u522b\uff0c\u800c\u8fd9\u4e9b\u5dee\u522b\u7ecf\u5e38\u5bfc\u81f4\u5199\u51fa\u6765\u7684\u516c\u5f0f\u5728\u4e8c\u8005\u4e4b\u95f4\u4e0d\u901a\u7528\u3002 \u7531\u4e8e OI Wiki \u4f7f\u7528 LaTeX \u6392\u7248\u5f15\u64ce\u5f00\u53d1\u4e86 PDF \u5bfc\u51fa\u5de5\u5177\uff0c\u56e0\u6b64\u6709\u5fc5\u8981\u5f3a\u8c03\u516c\u5f0f\u5728 MathJax \u548c LaTeX \u4e4b\u95f4\u7684\u517c\u5bb9\u6027\u3002 \u8bf7\u5404\u4f4d\u5728 Wiki \u4e2d\u4e66\u5199\u6570\u5b66\u516c\u5f0f\u65f6\u6ce8\u610f\u4ee5\u4e0b\u51e0\u70b9\u3002 \u8fd9\u4e9b\u89c4\u5219\u5df2\u7ecf\u5411 MathJax \u505a\u4e86\u5c3d\u53ef\u80fd\u591a\u7684\u59a5\u534f\u3002\u5bfc\u51fa\u5de5\u5177\u517c\u5bb9\u4e86\u4e00\u90e8\u5206\u539f\u672c\u4ec5\u80fd\u5728 MathJax \u4e2d\u6b63\u5e38\u8f93\u51fa\u7684\u5199\u6cd5\u3002 \u8bf7\u4f7f\u7528 \\begin{aligned} ... \\end{aligned} \u8868\u793a\u591a\u884c\u5bf9\u9f50\u7684\u516c\u5f0f\uff1b \u5982\u679c\u8fd9\u4e9b\u591a\u884c\u5bf9\u9f50\u7684\u516c\u5f0f\u9700\u8981 \u7f16\u53f7 \uff0c\u8bf7\u7528 align \u6216 equation \u73af\u5883\uff1b \u4e0d\u8981\u4f7f\u7528 split \u3001 eqnarray \u73af\u5883\uff1b \u4e0d\u8981\u4f7f\u7528 \\lt , \\gt \u6765\u8868\u793a\u5927\u4e8e\u53f7\u548c\u5c0f\u4e8e\u53f7\uff0c\u8bf7\u76f4\u63a5\u4f7f\u7528 < \uff0c > \uff1b \u4e0d\u8981\u76f4\u63a5\u7528 \\\\ \u6362\u884c\uff08\u9700\u8981\u6362\u884c\u7684\u516c\u5f0f\uff0c\u8bf7\u5957\u5728 aligned \u6216\u5176\u4ed6\u591a\u884c\u73af\u5883\u4e0b\uff09\uff1b \u82e5\u8981\u8f93\u51fa LaTeX \u7b26\u53f7 $\\rm{\\LaTeX}$ \uff0c\u8bf7\u7528 $\\rm{\\LaTeX}$ \uff0c\u800c\u4e0d\u662f mathrm \uff1b\uff08 \\LaTeX \u5728 TeX \u6392\u7248\u7cfb\u7edf\u4e2d\u662f\u4e00\u4e2a\u4e0d\u80fd\u7528\u4e8e\u6570\u5b66\u6a21\u5f0f\u4e0b\u7684\u547d\u4ee4\uff0c\u800c \\mathrm \u53c8\u4e0d\u80fd\u5728\u666e\u901a\u6a21\u5f0f\u4e0b\u4f7f\u7528\uff1b\u53e6\u5916\uff0c \\text \u547d\u4ee4\u867d\u7136\u5728 TeX \u4e0a\u6b63\u5e38\u8f93\u51fa\uff0c\u4f46\u662f\u5728 MathJax \u4e2d \\text \u547d\u4ee4\u7684\u53c2\u6570\u4f1a\u88ab\u539f\u6837\u8f93\u51fa\uff0c\u800c\u4e0d\u662f\u6309\u547d\u4ee4\u8f6c\u4e49\uff09\uff1b \u6570\u5b66\u516c\u5f0f\u4e2d\u7684\u4e2d\u6587\u6587\u5b57 \u5fc5\u987b\u7f6e\u4e8e \\text{} \u547d\u4ee4\u4e4b\u4e2d \uff0c\u800c\u53d8\u91cf\u3001\u6570\u5b57\u3001\u8fd0\u7b97\u7b26\u3001\u51fd\u6570\u540d\u79f0\u5219\u5fc5\u987b\u7f6e\u4e8e \\text{} \u547d\u4ee4\u4e4b\u5916\u3002 \u8bf7\u4e0d\u8981\u5728 \\text{} \u547d\u4ee4\u4e2d\u5d4c\u5957\u6570\u5b66\u516c\u5f0f \uff1b \u4f7f\u7528 array \u73af\u5883\u65f6\u8bf7\u6ce8\u610f \u5b9e\u9645\u5217\u6570\u4e0e\u5bf9\u9f50\u7b26\u53f7\u7684\u6570\u91cf\u4fdd\u6301\u4e00\u81f4 \u3002\u4f8b\u5982\u4e0b\u9762\u7684\u516c\u5f0f\u4e2d\uff0c\u6570\u636e\u5b9e\u9645\u6709 3 \u5217\uff08 & \u662f\u5217\u5206\u9694\u7b26\uff09\uff0c\u56e0\u6b64\u9700\u8981 3 \u4e2a\u5bf9\u9f50\u7b26\u53f7\uff08 l / r / c \u5206\u522b\u8868\u793a\u5de6\u3001\u53f3\u3001\u5c45\u4e2d\u5bf9\u9f50\uff09\u3002 $$ \\begin {array}{lll} F_ 1 = \\{\\frac { 0 }{ 1 },&& \\frac { 1 }{ 1 } \\}\\\\ F_ 2 = \\{\\frac { 0 }{ 1 },& \\frac { 1 }{ 2 },& \\frac { 1 }{ 1 } \\}\\\\ \\end {array} $$","title":"\u5bf9\u6570\u5b66\u516c\u5f0f\u7684\u9644\u52a0\u683c\u5f0f\u8981\u6c42"},{"location":"intro/format.html#_8","text":"\u4f2a\u7801\u5177\u4f53\u683c\u5f0f\u6ca1\u6709\u4e25\u683c\u8981\u6c42\uff0c\u8bf7\u53c2\u8003\u7b97\u6cd5\u5bfc\u8bba\u6216\u5b66\u672f\u8bba\u6587\u3002\u6ce8\u610f\u4e0d\u8981\u5199\u6210 Python\u3002 Wiki \u5185\u4f7f\u7528 LaTeX \u4e66\u5199\u4f2a\u7801\uff0c\u6574\u4f53\u5904\u4e8e array \u73af\u5883\u4e2d\uff0c\u7f29\u8fdb\u4f7f\u7528 $\\qquad$ \uff0c\u6587\u5b57\u63cf\u8ff0\u4f7f\u7528 $\\text$ \uff0c\u5173\u952e\u5b57\u4f7f\u7528 $\\textbf$ \uff0c\u8d4b\u503c\u4f7f\u7528 $\\gets$ \u3002 \u53c2\u8003\u793a\u4f8b\uff1a $$ \\begin{array}{ll} 1 & \\textbf{Input. } \\text{The edges of the graph } e , \\text{ where each element in } e \\text{ is } (u, v, w) \\\\ & \\text{ denoting that there is an edge between } u \\text{ and } v \\text{ weighted } w . \\\\ 2 & \\textbf{Output. } \\text{The edges of the MST of the input graph}.\\\\ 3 & \\textbf{Method. } \\\\ 4 & result \\gets \\varnothing \\\\ 5 & \\text{sort } e \\text{ into nondecreasing order by weight } w \\\\ 6 & \\textbf{for} \\text{ each } (u, v, w) \\text{ in the sorted } e \\\\ 7 & \\qquad \\textbf{if } u \\text{ and } v \\text{ are not connected in the union-find set } \\\\ 8 & \\qquad\\qquad \\text{connect } u \\text{ and } v \\text{ in the union-find set} \\\\ 9 & \\qquad\\qquad result \\gets result\\;\\bigcup\\ \\{(u, v, w)\\} \\\\ 10 & \\textbf{return } result \\end{array} $$ $$ \\begin {array}{ll} 1 & \\textbf {Input. } \\text {The edges of the graph } e , \\text { where each element in } e \\text { is } ( u, v, w ) \\\\ & \\text { denoting that there is an edge between } u \\text { and } v \\text { weighted } w . \\\\ 2 & \\textbf {Output. } \\text {The edges of the MST of the input graph}. \\\\ 3 & \\textbf {Method. } \\\\ 4 & result \\gets \\varnothing \\\\ 5 & \\text {sort } e \\text { into nondecreasing order by weight } w \\\\ 6 & \\textbf {for} \\text { each } ( u, v, w ) \\text { in the sorted } e \\\\ 7 & \\qquad \\textbf {if } u \\text { and } v \\text { are not connected in the union - find set } \\\\ 8 & \\qquad\\qquad \\text {connect } u \\text { and } v \\text { in the union - find set} \\\\ 9 & \\qquad\\qquad result \\gets result \\;\\bigcup\\ \\{ ( u, v, w ) \\} \\\\ 10 & \\textbf {return } result \\end {array} $$","title":"\u4f2a\u4ee3\u7801\u683c\u5f0f"},{"location":"intro/format.html#_9","text":"\u4ee3\u7801\u5757\u76ee\u524d\u5206\u4e3a\u4e24\u79cd\uff1a\u7247\u6bb5\u548c\u4f8b\u9898\u3002 \u5173\u4e8e\u7247\u6bb5\u4ee3\u7801\uff1a \u7247\u6bb5\u7684\u4ee3\u7801\u5185\u5bb9\u8bf7\u76f4\u63a5\u5728 Markdown \u6587\u6863\u4e2d\u4fee\u6539\u3002 \u5173\u4e8e\u4f8b\u9898\u4ee3\u7801\uff1a \u4f8b\u9898\u4ee3\u7801\u7684\u8868\u793a\u5f62\u5f0f\u4e3a --8<-- \"path\" \uff0c\u4ee3\u7801\u5747\u5b58\u50a8\u5728 path \u4e2d\u3002\u8def\u5f84\u901a\u5e38\u4e3a docs/\u4e3b\u9898/code/\u5185\u5bb9/\u5185\u5bb9_\u7f16\u53f7.cpp \u3002 \u4fee\u6539\u4f8b\u9898\u4ee3\u7801\u65f6\uff0c\u8bf7\u4fdd\u8bc1\u4f60\u7684\u4ee3\u7801\u662f\u6b63\u786e\u7684\u3002\u4f8b\u9898\u4ee3\u7801\u5747\u62e5\u6709\u4e00\u7ec4\u6d4b\u8bd5\u6570\u636e\uff0c\u5b58\u50a8\u5728 /docs/\u4e3b\u9898/examples/\u5185\u5bb9/\u5185\u5bb9_\u7f16\u53f7.in/ans \u4e2d\u3002 \u5982\u679c\u4f60\u9700\u8981\u6dfb\u52a0\u4f8b\u9898\uff1a \u8bf7\u5728 docs/\u4e3b\u9898/code/\u5185\u5bb9 \u4e2d\u6dfb\u52a0\u4f60\u7684\u4f8b\u9898\u4ee3\u7801\uff0c\u5e76\u7f16\u53f7\u3002\u901a\u5e38\uff0c\u8be5 \u5185\u5bb9 \u6587\u4ef6\u5939\u4e2d\u5df2\u7ecf\u6709\u4e86\u4e00\u4e2a\u6216\u8005\u591a\u4e2a\u4ee3\u7801\u3002\u4f8b\u5b50\uff1a\u5982\u679c\u9700\u8981\u4fee\u6539 dag.md \u7684\u4ee3\u7801\uff0c\u90a3\u4e48\u8def\u5f84\u4e3a docs/dp/code/dag \uff0c\u5176\u4e2d dp \u4e3a\u4e3b\u9898\uff0c\u800c dag \u4e3a\u5185\u5bb9\u3002 \u5982\u679c\u9700\u8981\u5728\u6240\u6709\u4f8b\u9898\u7684\u6700\u540e\u6dfb\u52a0\u4e00\u4e2a\u4f8b\u9898\u4ee3\u7801\uff0c\u8bf7\u987a\u5ef6\u76ee\u524d\u7684\u7f16\u53f7\u3002\u6bd4\u5982\u5df2\u7ecf\u5b58\u5728\u4e86 code/prefix-sum/prefix-sum_3.cpp \uff0c\u5982\u679c\u9700\u8981\u5728\u6700\u540e\u4e00\u4e2a\u4f8b\u9898\u540e\u7ee7\u7eed\u6dfb\u52a0\u4e00\u4e2a\u4f8b\u9898\uff0c\u8bf7\u5c06\u4f60\u7684\u4ee3\u7801\u547d\u540d\u4e3a prefix-sum_4.cpp \u5e76\u6dfb\u52a0\u5230 docs/basic/code/prefix-sum \u4e2d\u3002 \u5982\u679c\u9700\u8981\u5728\u6587\u7ae0\u4e2d\u95f4\u6dfb\u52a0\u4e00\u4e2a\u4f8b\u9898\u4ee3\u7801\uff0c\u8bf7\u63d2\u5165\u5e76\u6539\u53d8\u539f\u5148\u7684\u7f16\u53f7\u3002\u6bd4\u5982\u5df2\u7ecf\u5b58\u5728\u4e86 prefix-sum_2.cpp \u548c prefix-sum_3.cpp \uff0c\u5982\u679c\u4f60\u9700\u8981\u5728\u7b2c\u4e8c\u4e2a\u4f8b\u9898\u548c\u7b2c\u4e09\u4e2a\u4f8b\u9898\u4e2d\u95f4\u518d\u6dfb\u52a0\u4e00\u4e2a\u4f8b\u9898\uff0c\u8bf7\u5c06\u4f60\u7684\u4ee3\u7801\u547d\u540d\u4e3a prefix-sum_3.cpp \u5e76\u5c06\u539f\u5148\u7684 prefix-sum_3.cpp \u6539\u540d\u4e3a prefix-sum_4.cpp \u540c\u65f6 \u5728 Markdown \u6587\u6863\u548c\u6d4b\u8bd5\u6570\u636e\u5b58\u653e\u7684\u6587\u4ef6\u5939\u4e2d\u540c\u6b65\u4fee\u6539\u7f16\u53f7 \u3002 \u522b\u5fd8\u8bb0\uff0c\u4f60\u8fd8\u8981\u5bf9\u4f60\u7684\u4ee3\u7801\u6dfb\u52a0\u4e00\u7ec4\u6d4b\u8bd5\u6570\u636e\uff0c\u4ee5\u4fdd\u8bc1\u8fd9\u4e2a\u4ee3\u7801\u662f\u53ef\u4ee5\u6210\u529f\u8fd0\u884c\u7684\u3002 \u4f60\u9700\u8981\u5728 docs/\u4e3b\u9898/examples/\u5185\u5bb9 \u6587\u4ef6\u5939\u4e2d\u6dfb\u52a0\u4e00\u7ec4\u6d4b\u8bd5\u6570\u636e\uff0c\u5c06\u8f93\u5165\u6570\u636e\u5b58\u50a8\u4e3a \u5185\u5bb9_\u7f16\u53f7.in \uff0c\u5c06\u6807\u51c6\u7b54\u6848\u5b58\u50a8\u4e3a \u5185\u5bb9_\u7f16\u53f7.ans \u3002 \u6700\u540e\uff0c\u53ef\u4ee5\u5c06\u4ee3\u7801\u6dfb\u52a0\u5230\u6587\u6863\u4e2d\u4e86\u3002\u8bf7\u76f4\u63a5\u5728\u6587\u6863\u4e2d\u7528\u6dfb\u52a0\u4ee3\u7801\u5757\u7684\u683c\u5f0f\uff0c\u5e76\u5c06\u4ee3\u7801\u5757\u5185\u90e8\u76f4\u63a5\u5199\u6210 --8<-- \"\u4f60\u7684\u4ee3\u7801\u8def\u5f84\" \u7684\u683c\u5f0f\u5c31\u53ef\u4ee5\u4e86\u3002 OI Wiki \u4f1a\u5bf9\u4f8b\u9898\u4ee3\u7801\u8fdb\u884c\u5168\u5e73\u53f0\u6d4b\u8bd5\uff0c\u4e3a\u4fdd\u8bc1\u60a8\u7684\u4ee3\u7801\u80fd\u591f\u987a\u5229\u901a\u8fc7\u6d4b\u8bd5\uff0c\u8bf7\u9075\u5b88\u5982\u4e0b\u89c4\u5219\uff1a \u60a8\u7684\u4ee3\u7801\u9700\u8981\u540c\u65f6\u652f\u6301\u5728 C++14\u3001C++17\u3001C++20 \u6807\u51c6\u4e0b\u7f16\u8bd1\u548c\u8fd0\u884c\u3002 \u4e0d\u8981\u4f7f\u7528 <bits/stdc++.h> \u3001 <bits/extc++.h> \u7b49\u975e\u6807\u51c6\u5934\u6587\u4ef6\u3002 \u6807\u51c6\u7b54\u6848\u6587\u4ef6\u4e0d\u8981\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u4e0d\u8981\u4f7f\u7528 \u4ee3\u7528\u8bb0\u53f7 \u3002 \u4f7f\u7528 \u805a\u5408\u521d\u59cb\u5316 \u65f6\uff0c object{args} \u4e0d\u53ef\u5199\u6210 (object){args} \u3002 \u4f7f\u7528 \u8fd0\u7b97\u7b26\u91cd\u8f7d \u65f6\u6ce8\u610f\u683c\u5f0f\uff0c\u5982\u91cd\u8f7d\u6bd4\u8f83\u8fd0\u7b97\u7b26\u65f6\uff0c\u82e5\u4f7f\u7528\u6210\u5458\u51fd\u6570\u5199\u6cd5\uff0c\u5219\u4e0d\u53ef\u7701\u7565 const \u9650\u5b9a\u7b26\u3002 \u4e0d\u8981\u4f7f\u7528\u7c7b\u4f3c #define int long long \u7684\u5b8f\u5b9a\u4e49\u3002 \u82e5\u60a8\u9700\u8981\u4f7f\u7528 C \u98ce\u683c\u7684 \u6709\u683c\u5f0f\u8f93\u5165/\u8f93\u51fa \uff0c\u8bf7\u7279\u522b\u7559\u610f\u683c\u5f0f\u6307\u793a\u7b26\u7684\u5199\u6cd5\uff1a\u5982 size_t \u5bf9\u5e94 %zu \uff0c ptrdiff_t \u5bf9\u5e94 %td \u3002\u4f8b\u5982\u8f93\u51fa\u67d0 STL \u5bb9\u5668\u7684\u5927\u5c0f\u65f6\uff0c\u4ee3\u7801\u5e94\u7c7b\u4f3c printf(\"%zu\", container.size()); \u3002 \u7531\u4e8e\u5f53\u524d\u6d4b\u8bd5\u73af\u5883 libstdc++ \u7684 <chrono> \u5e93\u6709 BUG \uff0c\u6240\u4ee5\u8bf7\u907f\u514d\u4f7f\u7528 <chrono> \u5e93\u3002 \u7531\u4e8e long \u4e0e unsigned long \u5728\u67d0\u4e9b\u6d4b\u8bd5\u73af\u5883\u4e0b\u4e3a 32 \u4f4d\uff0c\u800c\u5728\u53e6\u4e00\u4e9b\u6d4b\u8bd5\u73af\u5883\u4e0b\u4e3a 64 \u4f4d\uff0c\u4e3a\u786e\u4fdd\u5404\u5e73\u53f0\u4ee3\u7801\u884c\u4e3a\u4e00\u81f4\uff0c\u6545\u4e0d\u63a8\u8350\u4f7f\u7528\u8fd9\u4e24\u79cd\u7c7b\u578b\u3002\u63a8\u8350\u4f7f\u7528 \u5b9a\u5bbd\u6574\u6570\u7c7b\u578b \u3002 \u4e0d\u5efa\u8bae\u4f7f\u7528 __gcd \u3001 __int128 \u3001 __builtin_ \u7cfb\u5217\u51fd\u6570\u7b49\u975e\u6807\u51c6\u5185\u5bb9\u3002\u5982\u679c\u60a8\u9700\u8981\u4f7f\u7528\uff0c\u5219\u9700\u786e\u4fdd\u60a8\u7684\u4ee3\u7801\u80fd\u901a\u8fc7\u5168\u5e73\u53f0\u6d4b\u8bd5\uff0c\u5982 \u6b64\u4ee3\u7801 \u63d0\u4f9b\u4e86 libstdc++ \u4e2d std::bitset \u7279\u6709\u6210\u5458\u51fd\u6570 _Find_first() \u7684\u5168\u5e73\u53f0\u5b9e\u73b0\u3002 \u6b64\u5916\uff0c\u4e3a\u4e86\u63d0\u9ad8\u4ee3\u7801\u7684\u53ef\u8bfb\u6027\uff0c\u5efa\u8bae\u9075\u5b88\u5982\u4e0b\u89c4\u5219\uff1a \u4ee3\u7801\u5e94\u5c3d\u53ef\u80fd\u7b80\u6d01\u6613\u61c2\uff0c\u4e0d\u8981\u8fc7\u5ea6\u538b\u884c\uff0c\u4e0d\u8981\u5f15\u5165\u8fc7\u591a\u65e0\u5173\u4ee3\u7801\uff08\u5982\u672a\u4f7f\u7528\u7684\u5b8f\u5b9a\u4e49\u7b49\uff09\u3002 \u4e0d\u63a8\u8350\u5bf9\u51fd\u6570\u4f7f\u7528 inline \u5173\u952e\u5b57\uff0c\u8be6\u89c1 \u7f16\u8bd1\u4f18\u5316 \u3002 \u4e0d\u8981\u7528 0 \u4ee3\u66ff false / NULL / nullptr \u7b49\uff0c\u4e0d\u8981\u7528 1 \u4ee3\u66ff true \u7b49\u3002 \u5728\u58f0\u660e \u7c7b\u578b\u522b\u540d \u65f6\uff0c\u4e0d\u63a8\u8350\u4f7f\u7528 typedef \uff0c\u63a8\u8350\u4f7f\u7528 using \u3002 \u4e0d\u63a8\u8350\u7528\u5b8f\u5b9a\u4e49\u5b9a\u4e49\u5e38\u91cf\uff0c\u63a8\u8350\u76f4\u63a5\u4f7f\u7528 constexpr / const \u7b49\u5173\u952e\u5b57\u5b9a\u4e49\u5e38\u91cf\u3002","title":"\u4ee3\u7801\u5757\u7684\u683c\u5f0f\u8981\u6c42"},{"location":"intro/format.html#_10","text":"\u53ef\u80fd\u4e0a\u8ff0\u8981\u6c42\u628a\u63e1\u8d77\u6765\u6709\u4e9b\u56f0\u96be\uff0c\u63a5\u4e0b\u6765\u6211\u4eec\u7ed9\u51fa\u4e00\u4e9b\u56fe\u7247\u6765\u5177\u4f53\u5206\u6790\u54ea\u79cd\u683c\u5f0f\u5e94\u8be5\u4f7f\u7528\uff0c\u54ea\u79cd\u4e0d\u8be5\u4f7f\u7528\uff1a","title":"\u56fe\u89e3"},{"location":"intro/format.html#1","text":"\u5c06\u590d\u6742\u7684 LaTeX \u516c\u5f0f\u4f7f\u7528\u884c\u95f4\u683c\u5f0f\uff0c\u53ef\u4ee5\u4f7f\u5f97\u9875\u9762\u9519\u843d\u6709\u81f4\u3002\u4f46 OI Wiki \u4f5c\u4e3a\u4e00\u4e2a\u4ee5\u4e2d\u6587\u4e3a\u4e3b\u4f53\u7684\u7ad9\u70b9\uff0c\u6211\u4eec\u5e0c\u671b\u5927\u90e8\u5206\u7eb2\u9886\u6027\u7684\u4fe1\u606f\uff08\u5982\u6807\u9898\uff09\u5c3d\u91cf\u4f7f\u7528\u4e2d\u6587\uff08\u9664\u82f1\u6587\u4e13\u6709\u540d\u8bcd\uff09\u3002","title":"\u4f8b 1"},{"location":"intro/format.html#2","text":"\u8f83\u590d\u6742\u5ea6\u7684 LaTeX \u516c\u5f0f\u8bf7\u6ce8\u610f\u7b49\u53f7\u7684\u5bf9\u9f50\uff0c\u540c\u65f6\u53ef\u4ee5\u9002\u5f53\u5f15\u7528 Wiki \u7684\u9875\u9762 \u94fe\u63a5 \u6765\u5b8c\u5584\u5185\u5bb9\u3002","title":"\u4f8b 2"},{"location":"intro/format.html#3","text":"\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5efa\u8bae\u5c06\u5f15\u7528\u7684\u8d44\u6599\u5217\u5728\u6587\u672b\u7684 ##\u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca \u4e00\u8282\uff0c\u5e76\u5728\u539f\u53e5\u540e\u9762\u52a0\u4e0a\u811a\u6ce8\uff0c\u800c\u4e0d\u662f\u76f4\u63a5\u7ed9\u51fa\u94fe\u63a5\u3002\u540c\u65f6\u4e00\u5b9a\u8981\u907f\u514d\u4f7f\u7528 LaTeX \u516c\u5f0f\u8868\u8fbe\u4ee3\u7801\uff0c\u4e0a\u56fe\u4e2d\u4e24\u4e2a\u4e2d\u62ec\u53f7\u5c31\u662f\u4e0d\u89c4\u8303\u7684\u5199\u6cd5\u3002\u6211\u4eec\u5efa\u8bae\u4f7f\u7528 dp(i,j) \u6216\u8005 dp_{i,j} \u3002","title":"\u4f8b 3"},{"location":"intro/format.html#4","text":"\u6ce8\u610f\u6211\u4eec\u63cf\u8ff0 \u4e58\u6cd5 \u7684\u65f6\u4faf\u4e00\u822c\u4f7f\u7528 \\times \u6216\u8005 \\cdot \uff0c\u7279\u6b8a\u60c5\u51b5\uff08\u5982\u5377\u79ef\uff09\u4e0b\u4f1a\u4f7f\u7528 * \uff08\u4e5f\u53ef\u4ee5\u5199\u6210 \\ast \uff09\u3002\u6807\u9898\u662f\u7b80\u6d01\u7684\u8bcd\u7ec4\uff0c\u4f46\u6211\u4eec\u4e0d\u5e0c\u671b\u6b63\u6587\u90e8\u5206\u7531\u8bcd\u7ec4\u62fc\u51d1\u800c\u6210\u3002\u4e0a\u56fe\u4e2d\u300c\u4e24\u4e2a\u8981\u7d20\u300d\uff0c\u5efa\u8bae\u66f4\u6539\u4e3a\u300c\u52a8\u6001\u89c4\u5212\u7684\u539f\u7406\u5177\u6709\u4ee5\u4e0b\u4e24\u4e2a\u8981\u7d20\u300d\uff0c\u4e0a\u4e0b\u6587\u4fdd\u6301\u8fde\u8d2f\u3002\u53ef\u53d6\u7684\u5730\u65b9\u662f\uff0c\u9002\u5f53\u4f7f\u7528 \u6709\u5e8f \u5217\u8868\u53ef\u4ee5\u66f4\u6709\u6761\u7406\u5730\u8868\u8ff0\u5185\u5bb9\u3002\u518d\u6b21\u63d0\u9192\uff0c\u5728\u4f7f\u7528\u5217\u8868\u7684\u65f6\u4faf\uff0c\u6bcf\u4e00\u9879\u5982\u679c\u662f\u4e00\u53e5\u8bdd\uff0c\u9700\u8981\u5728\u672b\u4f4d\u6dfb\u52a0 \u6807\u70b9\u7b26\u53f7 \u3002\u6709\u5e8f\u5217\u8868\u901a\u5e38\u6dfb\u52a0\u5206\u53f7\uff0c\u5728\u6700\u540e\u4e00\u9879\u672b\u4f4d\u6dfb\u52a0\u53e5\u53f7\uff1b\u65e0\u5e8f\u5217\u8868\u7edf\u4e00\u6dfb\u52a0\u53e5\u53f7\u3002","title":"\u4f8b 4"},{"location":"intro/format.html#5","text":"\u9002\u5f53\u5f15\u7528 \u56fe\u7247 \u53ef\u4ee5\u589e\u5f3a\u6587\u7ae0\u6613\u8bfb\u6027\u3002\u4f7f\u7528 \u4f2a\u4ee3\u7801 \u7684\u65b9\u5f0f\u8868\u8fbe\u7b97\u6cd5\u8fc7\u7a0b\u53ef\u4ee5\u65b9\u4fbf\u53c8\u7b80\u6d01\u5730\u63cf\u8ff0\u7b97\u6cd5\u8fc7\u7a0b\uff0c\u76f8\u6bd4\u4e8e\u76f4\u63a5\u8d34\u6a21\u677f\u4ee3\u7801\u66f4\u52a0\u597d\u61c2\u3002","title":"\u4f8b 5"},{"location":"intro/format.html#6","text":"\u540c\u6837\u7684\u95ee\u9898\uff0c\u6807\u9898\u4f7f\u7528\u82f1\u6587\u3002\u5e76\u4e14\u5728\u4f7f\u7528\u5b8c\u62ec\u53f7\u540e\u6ca1\u6709\u53e5\u53f7\u3002\u53e6\u5916\uff0c\u4e0a\u56fe\u4e2d\u7684\u884c\u95f4\u516c\u5f0f\u867d\u7136\u6ca1\u6709\u4f7f\u7528\u827e\u5f17\u68ee\u62ec\u53f7\uff0c\u4f46\u662f\u7531\u4e8e\u4e0b\u6807\u5d4c\u5957\u8fc7\u591a\uff0c\u4f7f\u5f97\u6700\u5e95\u5c42\u7684\u4e0b\u6807\u5b57\u4f53\u5f88\u5c0f\uff0c\u6574\u4e2a\u516c\u5f0f\u4e5f\u5e76\u4e0d\u7f8e\u89c2\u3002\u5efa\u8bae\u5c06 son_{now,i} \u66f4\u6362\u4e3a son(now,i) \uff0c\u6216\u8005\u628a f_{now} \u66ff\u6362\u4e3a f(now) \u3002\u6211\u4eec\u5e0c\u671b\u5c3d\u91cf\u63a7\u5236\u4e0b\u6807\u5d4c\u5957\u5728\u4e24\u5c42\u4ee5\u5185\uff08\u4e0a\u6807\u7684\u8fd0\u7528\u4e3b\u8981\u662f\u6570\u5b66\u8868\u8fbe\u5f0f\uff0c\u56e0\u6b64\u53ef\u4ee5\u5141\u8bb8\u591a\u6b21\u5d4c\u5957\uff0c\u5982 $2^{2^{2^{2^{\\cdots}}}}$ \uff0c\u300a\u4e0a\u5e1d\u9020\u9898\u7684\u4e03\u5206\u949f\u300b\uff09\u3002","title":"\u4f8b 6"},{"location":"intro/format.html#7","text":"\u4f7f\u7528 MkDocs \u6269\u5c55\u8bed\u6cd5\uff0c\u8ba9\u4f8b\u9898\u9898\u9762\u4e0e\u7b97\u6cd5\u63cf\u8ff0\u533a\u5206\u5f00\u3002\u5c06\u4ee3\u7801\u6298\u53e0\uff0c\u53ef\u4ee5\u8ba9\u6587\u7ae0\u66f4\u7d27\u51d1\u3002\uff08\u6bd5\u7adf\u770b Wiki \u7684\u5927\u591a\u6570\u662f\u4e86\u89e3\u601d\u8def\uff0c\u9664\u4e86\u6a21\u677f\u4ee3\u7801\u9700\u8981\u9605\u8bfb\u5916\uff0c\u4e60\u9898\u7684\u4ee3\u7801\u5927\u591a\u53ef\u4ee5\u6298\u53e0\u3002\uff09\u5728\u63cf\u8ff0\u51fd\u6570\u64cd\u4f5c\u65f6\uff0c\u4f7f\u7528\u884c\u5185\u4ee3\u7801\u548c LaTeX \u516c\u5f0f\u90fd\u662f\u4e0d\u9519\u7684\u9009\u62e9\u3002","title":"\u4f8b 7"},{"location":"intro/format.html#8","text":"\u5728\u6587\u672b\u7f57\u5217\u51fa\u53c2\u8003\u6587\u732e\uff0c\u53ef\u4ee5\u4f7f\u9875\u9762\u7684\u5185\u5bb9\u66f4\u4e25\u8c28\uff0c\u771f\u5b9e\u53ef\u4fe1\u3002","title":"\u4f8b 8"},{"location":"intro/format.html#_11","text":"\u6807\u70b9\u7b26\u53f7\u7528\u6cd5\uff08GB/T 15834\u20142011\uff09 \u7ef4\u57fa\u767e\u79d1\uff1a\u683c\u5f0f\u624b\u518c/\u6807\u70b9\u7b26\u53f7 \u4e2d\u6587\u6587\u6848\u6392\u7248\u6307\u5317\uff08\u7b80\u4f53\u4e2d\u6587\u7248\uff09 \u4e2d\u6587\u6587\u6848\u98ce\u683c\u6307\u5357 - PDFE GUIDELINE \u4e00\u4efd\uff08\u4e0d\u592a\uff09\u7b80\u77ed\u7684 LATEX2\u03b5 \u4ecb\u7ecd\u6216 106 \u5206\u949f\u4e86\u89e3 LATEX2\u03b5 \u4e2d\u6587\u51fa\u7248\u7269\u5939\u7528\u82f1\u6587\u7684\u7f16\u8f91\u89c4\u8303","title":"\u5916\u90e8\u94fe\u63a5"},{"location":"intro/format.html#_12","text":"[^ref1]: cstdio stdio.h namespace [^ref2]: CCF \u5173\u4e8e\u6062\u590d NOIP \u7ade\u8d5b\u7684\u516c\u544a - \u4e2d\u56fd\u8ba1\u7b97\u673a\u5b66\u4f1a [^webarchive]: Save Page in Internet Archive","title":"\u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca"},{"location":"intro/htc.html","text":"\u5728\u6587\u7ae0\u5f00\u59cb\u4e4b\u524d\uff0c OI Wiki \u9879\u76ee\u7ec4\u5168\u4f53\u6210\u5458\u5341\u5206\u6b22\u8fce\u60a8\u4e3a\u672c\u9879\u76ee\u8d21\u732e\u9875\u9762\u3002\u6b63\u56e0\u4e3a\u6709\u4e86\u4e0a\u767e\u4f4d\u50cf\u60a8\u4e00\u6837\u7684\u4eba\uff0c\u624d\u6709\u4e86 OI Wiki \u7684\u4eca\u5929\uff01 \u8fd9\u7bc7\u6587\u7ae0\u5c06\u4e3b\u8981\u53d9\u8ff0\u53c2\u4e0e OI Wiki \u7f16\u5199\u7684\u5199\u4f5c\u8fc7\u7a0b\u3002\u8bf7\u60a8\u5728\u64b0\u7a3f\u6216\u8005\u4fee\u6b63 Wiki \u9875\u9762\u4ee5\u524d\uff0c\u4ed4\u7ec6\u9605\u8bfb\u4ee5\u4e0b\u5185\u5bb9\uff0c\u4ee5\u5e2e\u52a9\u60a8\u5b8c\u6210\u66f4\u9ad8\u8d28\u91cf\u7684\u5185\u5bb9\u3002 \u8d21\u732e\u6307\u5357 \u00b6 \u8bf7\u60a8\u5728\u7f16\u8f91\u524d\u67e5\u770b OI Wiki \u8d21\u732e\u6307\u5357 \u548c \u9879\u76ee\u65b9\u9488 \uff0c\u4ee5\u66f4\u597d\u5730\u548c\u793e\u533a\u8d21\u732e\u8005\u8fdb\u884c\u5408\u4f5c\u3001\u4ea4\u6d41\u3002 \u53c2\u4e0e\u534f\u4f5c \u00b6 Warning \u5728\u5f00\u59cb\u7f16\u5199\u4e00\u6bb5\u5185\u5bb9\u4e4b\u524d\uff0c\u8bf7\u67e5\u9605 Issues \uff0c\u786e\u8ba4\u6ca1\u6709\u522b\u4eba\u5728\u505a\u76f8\u540c\u7684\u5de5\u4f5c\u4e4b\u540e\uff0c\u5f00\u4e2a \u65b0 issue \u8bb0\u5f55\u5f85\u7f16\u5199\u7684\u5185\u5bb9\u3002 Tip \u5728 Issues \u4e2d\u4e5f\u6709\u5f88\u591a\u5f85\u4fee\u590d/\u89e3\u51b3\u7684\u95ee\u9898\uff0c\u5c24\u5176\u662f\u6211\u4eec\u7684\u8fed\u4ee3\u8ba1\u5212\uff08Iteration Plan\uff09\u3002\u4ece\u8fd9\u91cc\u83b7\u53d6\u4efb\u52a1\u662f\u4e00\u4e2a\u5f88\u597d\u7684\u5f00\u59cb\uff01 \u4e3a\u4e86\u4fdd\u8bc1\u6761\u76ee\u5185\u5bb9\u7684\u4e13\u4e1a\u6027\u548c\u51c6\u786e\u6027\uff0c\u6211\u4eec\u5efa\u8bae\u60a8\u5728\u7f16\u8f91\u524d\u5148\u8003\u8651\u4ee5\u4e0b\u51e0\u70b9\uff1a \u9009\u62e9\u60a8\u719f\u6089\u7684\u9886\u57df \uff1a\u8bf7\u4f18\u5148\u7f16\u8f91\u90a3\u4e9b\u4e0e\u60a8\u7684\u4e13\u4e1a\u77e5\u8bc6\u3001\u5b66\u4e60\u80cc\u666f\u6216\u5174\u8da3\u7231\u597d\u76f8\u5173\u7684\u6761\u76ee\u3002\u8fd9\u6709\u52a9\u4e8e\u60a8\u521b\u4f5c\u51fa\u9ad8\u8d28\u91cf\u7684\u5185\u5bb9\u3002 \u8c28\u614e\u5bf9\u5f85\u65b0\u9886\u57df \uff1a\u5982\u679c\u60a8\u5bf9\u67d0\u4e2a\u4e3b\u9898\u8fd8\u5904\u4e8e\u521d\u5b66\u9636\u6bb5\u6216\u4e0d\u592a\u4e86\u89e3\uff0c\u5efa\u8bae\u60a8\u5148\u901a\u8fc7\u9605\u8bfb\u3001\u5b66\u4e60\u52a0\u6df1\u7406\u89e3\uff0c\u5f85\u6709\u4e00\u5b9a\u628a\u63e1\u540e\u518d\u52a8\u624b\u7f16\u8f91\u3002 \u67e5\u9605\u76f8\u5173\u8d44\u6599 \uff1a\u4e3a\u6761\u76ee\u6dfb\u52a0\u5185\u5bb9\u6216\u8fdb\u884c\u4fee\u8ba2\u65f6\uff0c\u5efa\u8bae\u60a8\u5148\u67e5\u9605\u6743\u5a01\u6587\u732e\u548c\u8d44\u6599\uff0c\u786e\u4fdd\u4fe1\u606f\u51c6\u786e\u65e0\u8bef\u3002\u4e5f\u6b22\u8fce\u60a8\u5728\u9875\u9762\u8bc4\u8bba\u533a\u6216\u6211\u4eec\u7684\u793e\u533a\u63d0\u51fa\u95ee\u9898\uff0c\u4e0e\u5176\u4ed6\u7f16\u8005\u4ea4\u6d41\u8ba8\u8bba\u3002 \u6211\u4eec\u73cd\u60dc\u6bcf\u4f4d\u8d21\u732e\u8005\u7684\u70ed\u60c5\u548c\u4ed8\u51fa\uff0c\u4e5f\u7406\u89e3\u5927\u5bb6\u7684\u4e13\u4e1a\u6c34\u5e73\u4e0d\u5c3d\u76f8\u540c\u3002\u8ba9\u6211\u4eec\u643a\u624b\u5408\u4f5c\uff0c\u5171\u540c\u5475\u62a4\u8fd9\u4e2a\u77e5\u8bc6\u7684\u4e50\u56ed\uff0c\u7528\u51c6\u786e\u3001\u4e13\u4e1a\u7684\u5185\u5bb9\u53bb\u5e2e\u52a9\u66f4\u591a\u8bfb\u8005\u3002\u671f\u5f85\u60a8\u7684\u8d21\u732e\uff01\u5728\u8fd9\u91cc\u5f15\u7528\u7ef4\u57fa\u767e\u79d1\u7684\u4e00\u53e5\u8bdd\uff1a \u4e0d\u8981\u5bb3\u6015\u7f16\u8f91\uff0c\u52c7\u4e8e\u66f4\u65b0\u9875\u9762\uff01 ^ref1 \u5728 GitHub \u4e0a\u7f16\u8f91 \u00b6 \u53c2\u4e0e OI Wiki \u7684\u7f16\u5199 \u9700\u8981 \u4e00\u4e2a GitHub \u8d26\u53f7\uff08\u53ef\u4ee5\u524d\u5f80 GitHub \u7684\u8d26\u53f7\u6ce8\u518c\u9875\u9762 \u9875\u9762\u6ce8\u518c\uff09\uff0c\u4f46 \u4e0d\u9700\u8981 \u9ad8\u8d85\u7684 GitHub \u6280\u5de7\uff0c\u5373\u4f7f\u4f60\u662f\u4e00\u540d\u65b0\u624b\uff0c\u53ea\u8981\u6309\u7167\u4e0b\u9762\u6240\u8ff0\u7684\u6b65\u9aa4\u64cd\u4f5c\uff0c\u4e5f\u80fd\u591f \u975e\u5e38\u51fa\u8272 \u5730\u5b8c\u6210\u7f16\u8f91\u3002 Tip \u5728\u4f60\u7684\u66f4\u6539\u88ab\u5408\u5e76\u5230 OI Wiki \u7684\u4e3b\u4ed3\u5e93\u4e4b\u524d\uff0c\u4f60\u5bf9 OI Wiki \u7684\u5185\u5bb9\u6240\u4f5c\u51fa\u7684\u4fee\u6539\u5747\u4e0d\u4f1a\u51fa\u73b0\u5728 OI Wiki \u7684\u4e3b\u7ad9\u4e0a\uff0c\u6240\u4ee5\u65e0\u9700\u62c5\u5fc3\u4f60\u7684\u4fee\u6539\u4f1a\u7834\u574f OI Wiki \u4e0a\u6b63\u5728\u663e\u793a\u7684\u5185\u5bb9\u3002 \u5982\u679c\u8fd8\u662f\u4e0d\u653e\u5fc3\uff0c\u53ef\u4ee5\u67e5\u770b GitHub \u7684\u5b98\u65b9\u6559\u7a0b \u3002 \u7f16\u8f91\u5355\u4e2a\u9875\u9762\u5185\u7684\u5185\u5bb9 \u00b6 \u5728 OI Wiki \u4e0a\u627e\u5230\u5bf9\u5e94\u9875\u9762\uff1b \u70b9\u51fb\u6b63\u6587\u53f3\u4e0a\u65b9\uff08\u76ee\u5f55\u5de6\u4fa7\uff09\u7684 \u300c\u7f16\u8f91\u6b64\u9875\u300d \uff08 edit \uff09\u6309\u94ae\uff0c\u5728\u786e\u8ba4\u60a8\u5df2\u7ecf\u9605\u8bfb\u4e86\u672c\u9875\u9762\u548c \u683c\u5f0f\u624b\u518c \u540e\u70b9\u51fb\u6309\u94ae\u6839\u636e\u63d0\u793a\u8df3\u8f6c\u5230 GitHub \u8fdb\u884c\u7f16\u8f91\uff1b \u5728\u7f16\u8f91\u6846\u5185\u7f16\u5199\u4f60\u60f3\u4fee\u6539\u7684\u5185\u5bb9\u3002\u8bf7\u6ce8\u610f\uff0c\u5728\u4fee\u6539\u548c\u63a5\u4e0b\u6765\u7684\u63d0\u4ea4\u8fc7\u7a0b\u4e2d\uff0c\u8bf7 \u5173\u95ed\u60a8\u7684\u81ea\u52a8\u7ffb\u8bd1\u8f6f\u4ef6 \uff0c\u56e0\u4e3a\u5b83\u53ef\u80fd\u4ea7\u751f\u4e0d\u5fc5\u8981\u7684\u9ebb\u70e6\uff08\u4f8b\u5982\u60a8\u4fee\u6539\u7684\u6587\u4ef6\u6709\u65f6\u4f1a\u88ab\u5176\u9519\u8bef\u6539\u540d\uff0c\u4ece\u800c\u5f71\u54cd\u76ee\u5f55\u7ed3\u6784\uff09\uff1b \u7f16\u5199\u5b8c\u6210\u540e\u6eda\u52a8\u5230\u9875\u9762\u4e0b\u65b9\uff0c\u6309\u7167\u672c\u6587\u4e2d commit \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u586b\u5199 commit \u4fe1\u606f\uff0c\u4e4b\u540e\u70b9\u51fb Propose changes \u6309\u94ae\u63d0\u4ea4\u4fee\u6539\u3002\u70b9\u51fb\u6309\u94ae\u540e\uff0cGitHub \u4f1a\u81ea\u52a8\u5e2e\u4f60\u521b\u5efa\u4e00\u4efd OI Wiki \u4ed3\u5e93\u7684\u5206\u652f\uff0c\u5e76\u5c06\u4f60\u7684\u63d0\u4ea4\u6dfb\u52a0\u5230\u8fd9\u4e2a\u5206\u652f\u4ed3\u5e93\u3002 GitHub \u4f1a\u81ea\u52a8\u8df3\u8f6c\u5230\u4f60\u7684\u5206\u652f\u4ed3\u5e93\u7684\u9875\u9762\uff0c\u6b64\u65f6\u9875\u9762\u4e0a\u65b9\u4f1a\u663e\u793a\u4e00\u4e2a\u7eff\u8272\u7684 Create pull request \u6309\u94ae\uff0c\u70b9\u51fb\u540e GitHub \u4f1a\u8df3\u8f6c\u5230\u4e00\u4e2a\u521b\u5efa Pull Request \u9875\u9762\u3002\u5411\u4e0b\u6eda\u52a8\u68c0\u67e5\u81ea\u5df1\u6240\u4f5c\u51fa\u7684\u4fee\u6539\u6ca1\u6709\u9519\u8bef\u540e\uff0c\u6309\u7167\u672c\u6587\u4e2d Pull Request \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u4e00\u8282\u4e2d\u7684\u89c4\u8303\u4e66\u5199 Pull Request \u4fe1\u606f\uff0c\u7136\u540e\u70b9\u51fb\u9875\u9762\u4e0a\u7684\u7eff\u8272\u7684 Create pull request \u6309\u94ae\u521b\u5efa Pull Request\u3002 \u4e0d\u51fa\u610f\u5916\u7684\u8bdd\uff0c\u4f60\u7684 Pull Request \u5c31\u987a\u5229\u63d0\u4ea4\u5230\u4ed3\u5e93\uff0c\u7b49\u5f85\u7ba1\u7406\u5458\u5ba1\u6838\u5e76\u5408\u5e76\u5230\u4e3b\u4ed3\u5e93\u4e2d\u5373\u53ef\u3002 \u5728\u7b49\u5f85\u5408\u5e76\u7684\u65f6\u95f4\u91cc\uff0c\u4f60\u53ef\u4ee5\u7ed9\u4ed6\u4eba\u7684 Pull Request \u63d0\u610f\u89c1\u3001\u70b9\u8d5e\u6216\u8005\u70b9\u8e29\u3002\u5982\u679c\u6709\u65b0\u6d88\u606f\uff0c\u4f1a\u5728\u7f51\u9875\u53f3\u4e0a\u89d2\u51fa\u73b0\u63d0\u793a\uff0c\u5e76\u9644\u6709\u90ae\u4ef6\u63d0\u9192\uff08\u53d6\u51b3\u4e8e\u4e2a\u4eba\u8bbe\u7f6e\u4e2d\u914d\u7f6e\u7684\u901a\u77e5\u65b9\u5f0f\uff09\u3002 \u7f16\u8f91\u591a\u4e2a\u9875\u9762\u5185\u7684\u5185\u5bb9 \u00b6 \u5982\u679c\u4f60\u9700\u8981\u540c\u65f6\u7f16\u8f91\u4e92\u76f8\u65e0\u5173\u8054\u7684\u591a\u4e2a\u9875\u9762\u7684\u5185\u5bb9\uff0c\u8bf7\u6309\u7167\u4e0a\u65b9\u7684 \u7f16\u8f91\u5355\u4e2a\u9875\u9762\u5185\u7684\u5185\u5bb9 \u4e00\u8282\u4e00\u6b21\u4fee\u6539\u6240\u6709\u9875\u9762\u3002 \u6253\u5f00 OI-Wiki/OI-Wiki \u4ed3\u5e93\uff0c\u70b9\u51fb\u952e\u76d8\u4e0a\u7684 . \u6309\u94ae\uff08\u6216\u8005\u5c06 URL \u4e2d\u7684 github.com \u66f4\u6539\u4e3a github.dev \uff09[^ref2]\uff0c\u8fdb\u5165 GitHub \u7684\u7f51\u9875\u7248 VS Code \u7f16\u8f91\u5668\uff1b \u5728\u7f16\u8f91\u5668\u4e2d\u4f5c\u51fa\u5bf9\u9875\u9762\u6e90\u6587\u4ef6\u7684\u66f4\u6539\uff0c\u53ef\u4ee5\u4f7f\u7528\u9875\u9762\u53f3\u4e0a\u65b9\u7684\u9884\u89c8\u6309\u94ae\uff08\u6216\u6309\u4e0b Ctrl+K V \u5feb\u6377\u952e\uff09\u5728\u53f3\u4fa7\u6253\u5f00\u9884\u89c8\u754c\u9762\uff1b \u4fee\u6539\u5b8c\u6210\u540e\u4f7f\u7528\u5de6\u4fa7\u7684 Source Control \u9009\u9879\u5361\uff0c\u5e76\u6309\u7167\u672c\u6587\u4e2d commit \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u586b\u5199 commit \u4fe1\u606f\u5e76\u63d0\u4ea4\uff0c\u63d0\u4ea4\u65f6\u4f1a\u63d0\u793a\u662f\u5426\u521b\u5efa\u6b64\u4ed3\u5e93\u7684\u5206\u652f\uff0c\u70b9\u51fb\u7eff\u8272\u7684 Fork Repository \u6309\u94ae\u5373\u53ef\u3002 \u63d0\u4ea4\u540e\u4f1a\u5728\u7f51\u9875\u4e0a\u65b9\u7684\u4e2d\u592e\u5f39\u51fa\u4e00\u4e2a\u63d0\u793a\u6846\uff0c\u5728\u7b2c\u4e00\u6b21\u7684\u63d0\u793a\u6846\u5185\u586b\u5199\u6807\u9898\uff0c\u7b2c\u4e8c\u6b21\u7684\u63d0\u793a\u6846\u5185\u586b\u5199\u6b64\u63d0\u4ea4\u8981\u63d0\u4ea4\u5230\u7684\u4ed3\u5e93\u5185\u5206\u652f\u540d\u79f0\uff0c\u4e4b\u540e\u53f3\u4e0b\u89d2\u4f1a\u5f39\u51fa\u4e00\u4e2a\u63d0\u793a\u6846\uff0c\u5185\u5bb9\u7c7b\u4f3c\u4e8e Created Pull Request #1 for OI-Wiki/OI-Wiki. \uff0c\u70b9\u51fb\u84dd\u5b57\u94fe\u63a5\u5373\u53ef\u67e5\u770b\u8be5 Pull Request\u3002 \u5411 Pull Request \u8ffd\u52a0\u66f4\u6539 \u00b6 \u6253\u5f00 OI-Wiki \u7684 Pull Request \u5217\u8868 \uff0c\u627e\u5230\u60a8\u63d0\u4ea4\u7684 Pull Request \u5e76\u70b9\u51fb\u3002 Pull Request \u9875\u9762\u7684\u6807\u9898\u4e0b\u65b9\u5c06\u4f1a\u6709\u4e00\u6bb5\u4f8b\u5982 <\u60a8\u7684ID> wants to merge x commits into OI-wiki:master from <\u60a8\u7684ID>:patch-1 \u7684\u6587\u5b57\uff0c\u70b9\u51fb <\u60a8\u7684ID>:patch-1 \u90e8\u5206\u3002 \u60a8\u5e94\u8be5\u4f1a\u88ab\u91cd\u5b9a\u5411\u5230\u60a8\u7684\u5206\u652f\u4ed3\u5e93\u4e2d\uff0c\u800c\u4e14\u6587\u4ef6\u5217\u8868\u5de6\u4e0a\u89d2\u7684\u5206\u652f\u540d\u79f0\u662f\u4f60\u63d0\u4ea4 Pull Request \u7684\u5206\u652f\u540d\u79f0\uff08\u5728\u672c\u793a\u4f8b\u4e2d\u5e94\u4e3a patch-1 \uff09\u3002 \u8fdb\u884c\u60a8\u9700\u8981\u7684\u66f4\u6539\u3002 \u5982\u679c\u60a8\u9700\u8981\u7f16\u8f91\u5355\u4e2a\u6587\u4ef6\u6216\u591a\u4e2a\u4e92\u76f8\u65e0\u5173\u8054\u7684\u9875\u9762\u7684\u5185\u5bb9\uff0c\u8bf7\u76f4\u63a5\u627e\u5230\u4f60\u8981\u7684\u6587\u4ef6\u5e76\u8fdb\u884c\u66f4\u6539\uff0c\u66f4\u6539\u5b8c\u6210\u540e\u6eda\u52a8\u5230\u9875\u9762\u4e0b\u65b9\uff0c\u6309\u7167\u672c\u6587\u4e2d commit \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u586b\u5199 commit \u4fe1\u606f\uff0c\u4e4b\u540e\u70b9\u51fb Commit changes \u6309\u94ae\u63d0\u4ea4\u4fee\u6539\u3002 \u5982\u679c\u60a8\u9700\u8981\u7f16\u8f91\u591a\u4e2a\u6587\u4ef6\uff0c\u70b9\u51fb\u952e\u76d8\u4e0a\u7684 . \u6309\u94ae\uff08\u6216\u8005\u5c06 URL \u4e2d\u7684 github.com \u66f4\u6539\u4e3a github.dev \uff09[^ref2]\uff0c\u8fdb\u5165 GitHub \u7684\u7f51\u9875\u7248 VS Code \u7f16\u8f91\u5668\u5e76\u4f5c\u51fa\u66f4\u6539\u3002\u7136\u540e\u4f7f\u7528\u5de6\u4fa7\u7684 Source Control \u9009\u9879\u5361\uff0c\u5e76\u6309\u7167\u672c\u6587\u4e2d commit \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u586b\u5199 commit \u4fe1\u606f\u5e76\u63d0\u4ea4\u4fee\u6539\u3002 \u8fd9\u65f6\u4f60\u7684\u66f4\u6539\u4f1a\u88ab\u81ea\u52a8\u8ffd\u52a0\u5728\u60a8\u7684 Pull Request \u4e2d\u3002 \u4f7f\u7528 Git \u5728\u672c\u5730\u8fdb\u884c\u7f16\u8f91 \u00b6 Warning \u5bf9\u4e8e\u4e00\u822c\u7528\u6237\uff0c\u6211\u4eec\u66f4\u63a8\u8350\u4f7f\u7528\u4e0a\u65b9\u6240\u8ff0\u7684 GitHub \u7684 Web \u7f16\u8f91\u5668\u8fdb\u884c\u7f16\u8f91\u3002 \u867d\u7136\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u60a8\u53ef\u4ee5\u76f4\u63a5\u5728 GitHub \u4e0a\u8fdb\u884c\u7f16\u8f91\uff0c\u4f46\u5bf9\u4e8e\u4e00\u4e9b\u8f83\u4e3a\u7279\u6b8a\u7684\u60c5\u51b5\uff08\u5982\u9700\u8981\u4f7f\u7528 GPG \u7b7e\u540d\uff09\uff0c\u6211\u4eec\u66f4\u63a8\u8350\u4f7f\u7528 Git \u5728\u672c\u5730\u8fdb\u884c\u7f16\u8f91\u3002 \u5927\u81f4\u6d41\u7a0b\u5982\u4e0b\uff1a \u5c06\u4e3b\u4ed3\u5e93 Fork \u5230\u81ea\u5df1\u7684\u4ed3\u5e93\u4e2d\uff1b \u5c06 Fork \u540e\u7684\u5206\u652f\u4ed3\u5e93\u514b\u9686\uff08clone\uff09\u5230\u672c\u5730\uff1b \u5728\u672c\u5730\u8fdb\u884c\u4fee\u6539\u540e\u63d0\u4ea4\uff08commit\uff09\u8fd9\u4e9b\u66f4\u6539\uff1b \u5c06\u8fd9\u4e9b\u66f4\u6539\u63a8\u9001\uff08push\uff09\u5230\u4f60\u514b\u9686\u7684\u5206\u652f\u4ed3\u5e93\uff1b \u63d0\u4ea4 Pull Request \u81f3\u4e3b\u4ed3\u5e93\u3002 \u8be6\u7ec6\u7684\u64cd\u4f5c\u65b9\u5f0f\u53ef\u4ee5\u53c2\u8003 Git \u9875\u9762\u3002 \u5411 Pull Request \u8ffd\u52a0\u66f4\u6539 \u00b6 \u5728 clone \u4e0b\u6765\u7684\u672c\u5730\u5206\u652f\u4ed3\u5e93\u4e2d\u7ee7\u7eed\u8fdb\u884c\u4fee\u6539\uff0c\u5e76\u63d0\u4ea4\uff08commit\uff09\u4ee5\u53ca\u63a8\u9001\uff08push\uff09\u8fd9\u4e9b\u66f4\u6539\u5373\u53ef\u3002\u4f60\u7684\u66f4\u6539\u4f1a\u88ab\u81ea\u52a8\u8ffd\u52a0\u5728 Pull Request \u4e2d\u3002 \u5728\u6784\u5efa\u7684\u7f51\u9875\u4e2d\u9884\u89c8\u53d8\u66f4 \u00b6 \u5728 Pull Request \u9875\u9762\u4e0b\u65b9\u53ef\u4ee5\u627e\u5230\u6d4b\u8bd5\u9875\u9762\uff0c\u70b9\u51fb netlify/oi-wiki/deploy-preview \u4e00\u9879\u7684 Details \u94fe\u63a5\uff08\u5982\u4e0b\u56fe\uff09\uff0c\u53ef\u4ee5\u8fdb\u5165\u81ea\u52a8\u6784\u5efa\u7684\uff0c\u7531\u60a8\u53d8\u66f4\u540e\u7684\u9875\u9762\u4f9b\u60a8\u9884\u89c8\u3002 \u5bf9\u4e8e\u76ee\u5f55\u548c\u5f15\u7528\u7684\u53d8\u66f4 \u00b6 \u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u60a8\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u65b0\u9875\u9762\uff0c\u6216\u8005\u4fee\u6539\u5df2\u6709\u9875\u9762\u5728\u76ee\u5f55\u4e2d\u7684\u94fe\u63a5\uff0c\u60a8\u5c31\u9700\u8981\u5bf9 mkdocs.yml \u6587\u4ef6\u4f5c\u51fa\u6539\u52a8\u3002 \u6dfb\u52a0\u65b0\u9875\u9762\u53ef\u4ee5\u53c2\u8003\u65e2\u6709\u7684\u683c\u5f0f\u3002\u4f46\u9664\u975e\u662f\u8fdb\u884c\u91cd\u6784\u6216\u4fee\u6b63\u540d\u8bcd\uff0c\u5426\u5219 \u6211\u4eec\u4e0d\u5efa\u8bae\u5bf9\u65e2\u6709\u9875\u9762\u7684\u5f15\u7528\u94fe\u63a5\u8fdb\u884c\u4fee\u6539 \uff0cPull Requests \u4e2d\u4e0d\u5fc5\u8981\u7684\u4fee\u6539\u4e5f\u5c06\u88ab\u9a73\u56de\u3002 \u5982\u679c\u60a8\u575a\u6301\u8981\u4fee\u6539\u94fe\u63a5\uff0c\u8bf7\u6ce8\u610f\u66f4\u65b0 author \u5b57\u6bb5\u548c\u91cd\u5b9a\u5411\u6587\u4ef6\u3002 author \u5b57\u6bb5 \u00b6 GitHub API \u5728\u6587\u4ef6\u76ee\u5f55\u53d8\u66f4\u540e\u4e0d\u80fd\u8ddf\u8e2a\u7edf\u8ba1\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u6587\u4ef6\u5934\u624b\u52a8\u7ef4\u62a4\u4e86\u4e00\u4e2a\u4f5c\u8005\u5217\u8868\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002author \u5b57\u6bb5\u4f4d\u4e8e\u6574\u4e2a Markdown \u6587\u4ef6\u7684\u5f00\u5934\uff0c\u5f62\u5982 author: Ir1d, cjsoft \uff0c\u76f8\u90bb\u4e24\u4e2a ID \u4e4b\u95f4\u7528\u9017\u53f7\u52a0\u7a7a\u683c\u9694\u5f00\u3002\u8fd9\u91cc\u7684 ID \u662f GitHub \u7684\u7528\u6237\u540d\uff0c\u5373 GitHub profile \u7684\u5730\u5740\uff08\u4f8b\u5982 https://github.com/Ir1d \u4e2d\u7684 Ir1d \uff09\u3002 \u4fee\u6539\u94fe\u63a5\u65f6\uff0c\u9700\u8981\u5c06\u5f53\u524d\u9875\u9762\u4e2d\u7684 contributors \u9010\u4e00\u586b\u5165 author \u5b57\u6bb5\u3002 \u91cd\u5b9a\u5411\u6587\u4ef6 \u00b6 \u5728\u4fee\u6539\u94fe\u63a5\u65f6\uff0c\u4e3a\u4e86\u907f\u514d\u5728\u7ad9\u5916\u5f15\u7528\u65f6\u51fa\u73b0\u6b7b\u94fe\uff0c\u9700\u8981\u4fee\u6539\u91cd\u5b9a\u5411\u6587\u4ef6\u3002 _redirects \u6587\u4ef6\u7528\u4e8e\u751f\u6210 netlify \u7684\u914d\u7f6e \u548c \u7528\u4e8e\u8df3\u8f6c\u7684\u6587\u4ef6 \u3002 \u6bcf\u4e00\u884c\u8868\u793a\u4e00\u4e2a\u91cd\u5b9a\u5411\u89c4\u5219\uff0c\u5206\u522b\u5199\u8df3\u8f6c\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\u7684 url\uff08\u4e0d\u5305\u542b\u57df\u540d\uff09\uff1a /path/to/src /path/to/desc \u6ce8\uff1a\u6240\u6709\u8df3\u8f6c\u5747\u4e3a 301 \u8df3\u8f6c\uff0c\u53ea\u6709\u5728\u4fee\u6539\u76ee\u5f55\u4e2d url \u9020\u6210\u6b7b\u94fe\u7684\u65f6\u5019\u9700\u8981\u4fee\u6539\u3002 Commit \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u00b6 \u5bf9\u4e8e\u63d0\u4ea4\u65f6\u9700\u8981\u586b\u5199\u7684 commit \u4fe1\u606f\uff0c\u8bf7\u9075\u5b88\u4ee5\u4e0b\u51e0\u70b9\u57fa\u672c\u8981\u6c42\uff1a commit \u6458\u8981\u8bf7\u7b80\u8981\u63cf\u8ff0\u8fd9\u4e00\u6b21 commit \u6539\u52a8\u7684\u5185\u5bb9\u3002\u6ce8\u610f commit \u6458\u8981\u7684\u957f\u5ea6\u4e0d\u8981\u8d85\u8fc7 50 \u5b57\u7b26\uff0c\u8d85\u51fa\u7684\u90e8\u5206\u4f1a\u81ea\u52a8\u7f6e\u4e8e\u6b63\u6587\u4e2d\u3002 \u5982\u679c\u9700\u8981\u8fdb\u4e00\u6b65\u63cf\u8ff0\u672c\u6b21 commit \u5185\u5bb9\uff0c\u8bf7\u5728\u6b63\u6587\u4e2d\u8be6\u7ec6\u8bf4\u660e\u3002 \u5bf9\u4e8e commit \u6458\u8981\uff0c\u63a8\u8350\u6309\u7167\u5982\u4e0b\u683c\u5f0f\u4e66\u5199\uff1a <\u4fee\u6539\u7c7b\u578b>(<\u6587\u4ef6\u540d>): <\u4fee\u6539\u7684\u5185\u5bb9> \u4fee\u6539\u7c7b\u578b\u5206\u4e3a\u5982\u4e0b\u51e0\u7c7b\uff1a feat \uff1a\u7528\u4e8e\u6dfb\u52a0\u5185\u5bb9\u7684\u60c5\u51b5\u3002 fix \uff1a\u7528\u4e8e\u4fee\u6b63\u73b0\u6709\u5185\u5bb9\u9519\u8bef\u7684\u60c5\u51b5\u3002 refactor \uff1a\u7528\u4e8e\u5bf9\u4e00\u4e2a\u9875\u9762\u8fdb\u884c\u91cd\u6784\uff08\u8f83\u5927\u89c4\u6a21\u7684\u66f4\u6539\uff09\u7684\u60c5\u51b5\u3002 revert \uff1a\u7528\u4e8e\u56de\u9000\u4e4b\u524d\u66f4\u6539\u7684\u60c5\u51b5\u3002 Pull Request \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u00b6 \u5bf9\u4e8e Pull Request\uff0c\u8bf7\u9075\u5b88\u4ee5\u4e0b\u51e0\u70b9\u8981\u6c42\uff1a \u6807\u9898\u8bf7\u5199\u660e\u672c\u6b21 PR \u7684\u76ee\u7684\uff08\u505a\u4e86 \u4ec0\u4e48 \u5de5\u4f5c\uff0c\u4fee\u590d\u4e86 \u4ec0\u4e48 \u95ee\u9898\uff09\u3002 \u5185\u5bb9\u8bf7\u7b80\u8981\u53d9\u8ff0\u4fee\u6539\u7684\u5185\u5bb9\u3002\u5982\u679c\u4fee\u590d\u4e86\u4e00\u4e2a issue \u7684\u95ee\u9898\uff0c\u8bf7\u5728\u5185\u5bb9\u4e2d\u6dfb\u52a0 fix #xxxx \u5b57\u6bb5\uff0c\u5176\u4e2d xxxx \u4ee3\u8868 issue \u7684\u7f16\u53f7\u3002 \u8bf7\u60a8\u4ed4\u7ec6\u9605\u8bfb \u8d21\u732e\u6307\u5357 \u548c \u793e\u533a\u516c\u7ea6 \uff0c\u5e76\u5728\u540c\u610f\u540e\u52fe\u9009 PR \u6a21\u677f\u4e2d\u7684\u6846\uff0c\u8868\u793a\u60a8\u540c\u610f\u4e86\u4ee5\u4e0a\u6307\u5357\u548c\u516c\u7ea6\u3002 \u5bf9\u4e8e Pull Request \u7684\u6807\u9898\uff0c\u63a8\u8350\u4f7f\u7528\u5982\u4e0b\u683c\u5f0f\u4e66\u5199\uff1a <\u4fee\u6539\u7c7b\u578b>(<\u6587\u4ef6\u540d>): <\u4fee\u6539\u7684\u5185\u5bb9> (<\u5bf9\u5e94 issue \u7684\u7f16\u53f7>) \u4fee\u6539\u7c7b\u578b\u5206\u4e3a\u5982\u4e0b\u51e0\u7c7b\uff1a feat \uff1a\u7528\u4e8e\u6dfb\u52a0\u5185\u5bb9\u7684\u60c5\u51b5\u3002 fix \uff1a\u7528\u4e8e\u4fee\u6b63\u73b0\u6709\u5185\u5bb9\u9519\u8bef\u7684\u60c5\u51b5\u3002 refactor \uff1a\u7528\u4e8e\u5bf9\u4e00\u4e2a\u9875\u9762\u8fdb\u884c\u91cd\u6784\uff08\u8f83\u5927\u89c4\u6a21\u7684\u66f4\u6539\uff09\u7684\u60c5\u51b5\u3002 revert \uff1a\u7528\u4e8e\u56de\u9000\u4e4b\u524d\u66f4\u6539\u7684\u60c5\u51b5\u3002 \u793a\u4f8b\uff1a fix(ds/persistent-seg): \u4fee\u6539\u4ee3\u7801\u6ce8\u91ca\u4f7f\u63cf\u8ff0\u66f4\u6e05\u6670 fix: tools/judger/index \u4e0d\u5728\u76ee\u5f55\u4e2d (#3709) feat(math/poly/fft): better proof refactor(ds/stack): \u6574\u7406\u9875\u9762\u5185\u5bb9 \u534f\u4f5c\u6d41\u7a0b \u00b6 \u5728\u6536\u5230\u4e00\u4e2a\u65b0\u7684 Pull Request \u4e4b\u540e\uff0cGitHub \u4f1a\u7ed9 reviewer \u53d1\u9001\u90ae\u4ef6\uff1b \u4e0e\u6b64\u540c\u65f6\uff0c\u5728 GitHub Actions \u548c Netlify \u4e0a\u4f1a\u8fd0\u884c\u4e24\u7ec4\u6d4b\u8bd5\uff0c\u5b83\u4eec\u4f1a\u628a\u8fdb\u5ea6\u540c\u6b65\u5728 PR \u9875\u9762\u7684\u4e0b\u65b9\u3002GitHub Actions \u4e3b\u8981\u7528\u6765\u786e\u8ba4 PR \u4e2d\u5185\u5bb9\u7684\u4fee\u6539\u4e0d\u4f1a\u5f71\u54cd\u5230\u7f51\u7ad9\u6784\u5efa\u7684\u8fdb\u7a0b\uff1bNetlify \u7528\u6765\u628a PR \u4e2d\u7684\u66f4\u65b0\u6784\u5efa\u51fa\u6765\uff0c\u65b9\u4fbf reviewer \u5ba1\u6838\uff08\u5728\u6d4b\u8bd5\u5b8c\u6210\u540e\u70b9\u51fb Details \u53ef\u4ee5\u4e86\u89e3\u66f4\u591a\uff09\uff1b reviewer \u53ef\u80fd\u4f1a\u53d1\u73b0\u95ee\u9898\uff0c\u5e76\u63d0\u51fa review \u6216 suggested changes \uff08\u5efa\u8bae\u66f4\u6539\uff0c\u663e\u793a\u4e3a\u7070\u8272\u56fe\u6807\uff09/ requested changes \uff08\u5f3a\u5236\u66f4\u6539\uff0c\u663e\u793a\u4e3a\u7ea2\u8272\u56fe\u6807\uff0c\u53ea\u4f1a\u5728 reviewer \u62e5\u6709 repo \u5199\u6743\u9650\u65f6\u51fa\u73b0\uff09\u3002\u4e00\u822c\u6765\u8bf4\uff0creviewer \u4e5f\u4f1a\u9644\u4e0a\u5efa\u8bae\u548c\u9700\u8981\u8fdb\u884c\u7684\u66f4\u6539\uff0c\u5728\u8fd9\u65f6\uff0c\u60a8\u5c06\u4f1a\u9700\u8981\u7ee7\u7eed\u5411 Pull Request \u8ffd\u52a0\u5176\u4ed6\u66f4\u6539\u3002\u66f4\u6539\u7684\u65b9\u6cd5\u53ef\u4ee5\u53c2\u8003 \u5728 GitHub \u4e0a\u7f16\u8f91 \u6216\u8005 \u4f7f\u7528 Git \u5728\u672c\u5730\u8fdb\u884c\u7f16\u8f91 \u90e8\u5206\u7684 \u5411 Pull Request \u8ffd\u52a0\u66f4\u6539 \u90e8\u5206\u3002 \u5728\u8db3\u591f\u591a reviewer \u6295\u7968\u901a\u8fc7\u4e00\u4e2a PR \u4e4b\u540e\uff0c\u8fd9\u4e2a PR \u624d\u53ef\u4ee5\u5408\u5e76\u5230 master \u5206\u652f\u4e2d\uff1b \u5728\u5408\u5e76\u5230 master \u5206\u652f\u4e4b\u540e\uff0cGitHub Actions \u4f1a\u91cd\u65b0\u6784\u5efa\u4e00\u904d\u7f51\u7ad9\u5185\u5bb9\uff0c\u5e76\u66f4\u65b0\u5230 gh-pages \u5206\u652f\uff1b \u8fd9\u65f6\u670d\u52a1\u5668\u624d\u4f1a\u62c9\u53d6 gh-pages \u5206\u652f\u7684\u66f4\u65b0\uff0c\u5e76\u91cd\u65b0\u90e8\u7f72\u6700\u65b0\u7248\u672c\u7684\u5185\u5bb9\u3002 \u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca \u00b6 [^ref2]: Web-based editor - GitHub Codespaces - GitHub Docs","title":"Htc"},{"location":"intro/htc.html#_1","text":"\u8bf7\u60a8\u5728\u7f16\u8f91\u524d\u67e5\u770b OI Wiki \u8d21\u732e\u6307\u5357 \u548c \u9879\u76ee\u65b9\u9488 \uff0c\u4ee5\u66f4\u597d\u5730\u548c\u793e\u533a\u8d21\u732e\u8005\u8fdb\u884c\u5408\u4f5c\u3001\u4ea4\u6d41\u3002","title":"\u8d21\u732e\u6307\u5357"},{"location":"intro/htc.html#_2","text":"Warning \u5728\u5f00\u59cb\u7f16\u5199\u4e00\u6bb5\u5185\u5bb9\u4e4b\u524d\uff0c\u8bf7\u67e5\u9605 Issues \uff0c\u786e\u8ba4\u6ca1\u6709\u522b\u4eba\u5728\u505a\u76f8\u540c\u7684\u5de5\u4f5c\u4e4b\u540e\uff0c\u5f00\u4e2a \u65b0 issue \u8bb0\u5f55\u5f85\u7f16\u5199\u7684\u5185\u5bb9\u3002 Tip \u5728 Issues \u4e2d\u4e5f\u6709\u5f88\u591a\u5f85\u4fee\u590d/\u89e3\u51b3\u7684\u95ee\u9898\uff0c\u5c24\u5176\u662f\u6211\u4eec\u7684\u8fed\u4ee3\u8ba1\u5212\uff08Iteration Plan\uff09\u3002\u4ece\u8fd9\u91cc\u83b7\u53d6\u4efb\u52a1\u662f\u4e00\u4e2a\u5f88\u597d\u7684\u5f00\u59cb\uff01 \u4e3a\u4e86\u4fdd\u8bc1\u6761\u76ee\u5185\u5bb9\u7684\u4e13\u4e1a\u6027\u548c\u51c6\u786e\u6027\uff0c\u6211\u4eec\u5efa\u8bae\u60a8\u5728\u7f16\u8f91\u524d\u5148\u8003\u8651\u4ee5\u4e0b\u51e0\u70b9\uff1a \u9009\u62e9\u60a8\u719f\u6089\u7684\u9886\u57df \uff1a\u8bf7\u4f18\u5148\u7f16\u8f91\u90a3\u4e9b\u4e0e\u60a8\u7684\u4e13\u4e1a\u77e5\u8bc6\u3001\u5b66\u4e60\u80cc\u666f\u6216\u5174\u8da3\u7231\u597d\u76f8\u5173\u7684\u6761\u76ee\u3002\u8fd9\u6709\u52a9\u4e8e\u60a8\u521b\u4f5c\u51fa\u9ad8\u8d28\u91cf\u7684\u5185\u5bb9\u3002 \u8c28\u614e\u5bf9\u5f85\u65b0\u9886\u57df \uff1a\u5982\u679c\u60a8\u5bf9\u67d0\u4e2a\u4e3b\u9898\u8fd8\u5904\u4e8e\u521d\u5b66\u9636\u6bb5\u6216\u4e0d\u592a\u4e86\u89e3\uff0c\u5efa\u8bae\u60a8\u5148\u901a\u8fc7\u9605\u8bfb\u3001\u5b66\u4e60\u52a0\u6df1\u7406\u89e3\uff0c\u5f85\u6709\u4e00\u5b9a\u628a\u63e1\u540e\u518d\u52a8\u624b\u7f16\u8f91\u3002 \u67e5\u9605\u76f8\u5173\u8d44\u6599 \uff1a\u4e3a\u6761\u76ee\u6dfb\u52a0\u5185\u5bb9\u6216\u8fdb\u884c\u4fee\u8ba2\u65f6\uff0c\u5efa\u8bae\u60a8\u5148\u67e5\u9605\u6743\u5a01\u6587\u732e\u548c\u8d44\u6599\uff0c\u786e\u4fdd\u4fe1\u606f\u51c6\u786e\u65e0\u8bef\u3002\u4e5f\u6b22\u8fce\u60a8\u5728\u9875\u9762\u8bc4\u8bba\u533a\u6216\u6211\u4eec\u7684\u793e\u533a\u63d0\u51fa\u95ee\u9898\uff0c\u4e0e\u5176\u4ed6\u7f16\u8005\u4ea4\u6d41\u8ba8\u8bba\u3002 \u6211\u4eec\u73cd\u60dc\u6bcf\u4f4d\u8d21\u732e\u8005\u7684\u70ed\u60c5\u548c\u4ed8\u51fa\uff0c\u4e5f\u7406\u89e3\u5927\u5bb6\u7684\u4e13\u4e1a\u6c34\u5e73\u4e0d\u5c3d\u76f8\u540c\u3002\u8ba9\u6211\u4eec\u643a\u624b\u5408\u4f5c\uff0c\u5171\u540c\u5475\u62a4\u8fd9\u4e2a\u77e5\u8bc6\u7684\u4e50\u56ed\uff0c\u7528\u51c6\u786e\u3001\u4e13\u4e1a\u7684\u5185\u5bb9\u53bb\u5e2e\u52a9\u66f4\u591a\u8bfb\u8005\u3002\u671f\u5f85\u60a8\u7684\u8d21\u732e\uff01\u5728\u8fd9\u91cc\u5f15\u7528\u7ef4\u57fa\u767e\u79d1\u7684\u4e00\u53e5\u8bdd\uff1a \u4e0d\u8981\u5bb3\u6015\u7f16\u8f91\uff0c\u52c7\u4e8e\u66f4\u65b0\u9875\u9762\uff01 ^ref1","title":"\u53c2\u4e0e\u534f\u4f5c"},{"location":"intro/htc.html#github","text":"\u53c2\u4e0e OI Wiki \u7684\u7f16\u5199 \u9700\u8981 \u4e00\u4e2a GitHub \u8d26\u53f7\uff08\u53ef\u4ee5\u524d\u5f80 GitHub \u7684\u8d26\u53f7\u6ce8\u518c\u9875\u9762 \u9875\u9762\u6ce8\u518c\uff09\uff0c\u4f46 \u4e0d\u9700\u8981 \u9ad8\u8d85\u7684 GitHub \u6280\u5de7\uff0c\u5373\u4f7f\u4f60\u662f\u4e00\u540d\u65b0\u624b\uff0c\u53ea\u8981\u6309\u7167\u4e0b\u9762\u6240\u8ff0\u7684\u6b65\u9aa4\u64cd\u4f5c\uff0c\u4e5f\u80fd\u591f \u975e\u5e38\u51fa\u8272 \u5730\u5b8c\u6210\u7f16\u8f91\u3002 Tip \u5728\u4f60\u7684\u66f4\u6539\u88ab\u5408\u5e76\u5230 OI Wiki \u7684\u4e3b\u4ed3\u5e93\u4e4b\u524d\uff0c\u4f60\u5bf9 OI Wiki \u7684\u5185\u5bb9\u6240\u4f5c\u51fa\u7684\u4fee\u6539\u5747\u4e0d\u4f1a\u51fa\u73b0\u5728 OI Wiki \u7684\u4e3b\u7ad9\u4e0a\uff0c\u6240\u4ee5\u65e0\u9700\u62c5\u5fc3\u4f60\u7684\u4fee\u6539\u4f1a\u7834\u574f OI Wiki \u4e0a\u6b63\u5728\u663e\u793a\u7684\u5185\u5bb9\u3002 \u5982\u679c\u8fd8\u662f\u4e0d\u653e\u5fc3\uff0c\u53ef\u4ee5\u67e5\u770b GitHub \u7684\u5b98\u65b9\u6559\u7a0b \u3002","title":"\u5728 GitHub \u4e0a\u7f16\u8f91"},{"location":"intro/htc.html#_3","text":"\u5728 OI Wiki \u4e0a\u627e\u5230\u5bf9\u5e94\u9875\u9762\uff1b \u70b9\u51fb\u6b63\u6587\u53f3\u4e0a\u65b9\uff08\u76ee\u5f55\u5de6\u4fa7\uff09\u7684 \u300c\u7f16\u8f91\u6b64\u9875\u300d \uff08 edit \uff09\u6309\u94ae\uff0c\u5728\u786e\u8ba4\u60a8\u5df2\u7ecf\u9605\u8bfb\u4e86\u672c\u9875\u9762\u548c \u683c\u5f0f\u624b\u518c \u540e\u70b9\u51fb\u6309\u94ae\u6839\u636e\u63d0\u793a\u8df3\u8f6c\u5230 GitHub \u8fdb\u884c\u7f16\u8f91\uff1b \u5728\u7f16\u8f91\u6846\u5185\u7f16\u5199\u4f60\u60f3\u4fee\u6539\u7684\u5185\u5bb9\u3002\u8bf7\u6ce8\u610f\uff0c\u5728\u4fee\u6539\u548c\u63a5\u4e0b\u6765\u7684\u63d0\u4ea4\u8fc7\u7a0b\u4e2d\uff0c\u8bf7 \u5173\u95ed\u60a8\u7684\u81ea\u52a8\u7ffb\u8bd1\u8f6f\u4ef6 \uff0c\u56e0\u4e3a\u5b83\u53ef\u80fd\u4ea7\u751f\u4e0d\u5fc5\u8981\u7684\u9ebb\u70e6\uff08\u4f8b\u5982\u60a8\u4fee\u6539\u7684\u6587\u4ef6\u6709\u65f6\u4f1a\u88ab\u5176\u9519\u8bef\u6539\u540d\uff0c\u4ece\u800c\u5f71\u54cd\u76ee\u5f55\u7ed3\u6784\uff09\uff1b \u7f16\u5199\u5b8c\u6210\u540e\u6eda\u52a8\u5230\u9875\u9762\u4e0b\u65b9\uff0c\u6309\u7167\u672c\u6587\u4e2d commit \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u586b\u5199 commit \u4fe1\u606f\uff0c\u4e4b\u540e\u70b9\u51fb Propose changes \u6309\u94ae\u63d0\u4ea4\u4fee\u6539\u3002\u70b9\u51fb\u6309\u94ae\u540e\uff0cGitHub \u4f1a\u81ea\u52a8\u5e2e\u4f60\u521b\u5efa\u4e00\u4efd OI Wiki \u4ed3\u5e93\u7684\u5206\u652f\uff0c\u5e76\u5c06\u4f60\u7684\u63d0\u4ea4\u6dfb\u52a0\u5230\u8fd9\u4e2a\u5206\u652f\u4ed3\u5e93\u3002 GitHub \u4f1a\u81ea\u52a8\u8df3\u8f6c\u5230\u4f60\u7684\u5206\u652f\u4ed3\u5e93\u7684\u9875\u9762\uff0c\u6b64\u65f6\u9875\u9762\u4e0a\u65b9\u4f1a\u663e\u793a\u4e00\u4e2a\u7eff\u8272\u7684 Create pull request \u6309\u94ae\uff0c\u70b9\u51fb\u540e GitHub \u4f1a\u8df3\u8f6c\u5230\u4e00\u4e2a\u521b\u5efa Pull Request \u9875\u9762\u3002\u5411\u4e0b\u6eda\u52a8\u68c0\u67e5\u81ea\u5df1\u6240\u4f5c\u51fa\u7684\u4fee\u6539\u6ca1\u6709\u9519\u8bef\u540e\uff0c\u6309\u7167\u672c\u6587\u4e2d Pull Request \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u4e00\u8282\u4e2d\u7684\u89c4\u8303\u4e66\u5199 Pull Request \u4fe1\u606f\uff0c\u7136\u540e\u70b9\u51fb\u9875\u9762\u4e0a\u7684\u7eff\u8272\u7684 Create pull request \u6309\u94ae\u521b\u5efa Pull Request\u3002 \u4e0d\u51fa\u610f\u5916\u7684\u8bdd\uff0c\u4f60\u7684 Pull Request \u5c31\u987a\u5229\u63d0\u4ea4\u5230\u4ed3\u5e93\uff0c\u7b49\u5f85\u7ba1\u7406\u5458\u5ba1\u6838\u5e76\u5408\u5e76\u5230\u4e3b\u4ed3\u5e93\u4e2d\u5373\u53ef\u3002 \u5728\u7b49\u5f85\u5408\u5e76\u7684\u65f6\u95f4\u91cc\uff0c\u4f60\u53ef\u4ee5\u7ed9\u4ed6\u4eba\u7684 Pull Request \u63d0\u610f\u89c1\u3001\u70b9\u8d5e\u6216\u8005\u70b9\u8e29\u3002\u5982\u679c\u6709\u65b0\u6d88\u606f\uff0c\u4f1a\u5728\u7f51\u9875\u53f3\u4e0a\u89d2\u51fa\u73b0\u63d0\u793a\uff0c\u5e76\u9644\u6709\u90ae\u4ef6\u63d0\u9192\uff08\u53d6\u51b3\u4e8e\u4e2a\u4eba\u8bbe\u7f6e\u4e2d\u914d\u7f6e\u7684\u901a\u77e5\u65b9\u5f0f\uff09\u3002","title":"\u7f16\u8f91\u5355\u4e2a\u9875\u9762\u5185\u7684\u5185\u5bb9"},{"location":"intro/htc.html#_4","text":"\u5982\u679c\u4f60\u9700\u8981\u540c\u65f6\u7f16\u8f91\u4e92\u76f8\u65e0\u5173\u8054\u7684\u591a\u4e2a\u9875\u9762\u7684\u5185\u5bb9\uff0c\u8bf7\u6309\u7167\u4e0a\u65b9\u7684 \u7f16\u8f91\u5355\u4e2a\u9875\u9762\u5185\u7684\u5185\u5bb9 \u4e00\u8282\u4e00\u6b21\u4fee\u6539\u6240\u6709\u9875\u9762\u3002 \u6253\u5f00 OI-Wiki/OI-Wiki \u4ed3\u5e93\uff0c\u70b9\u51fb\u952e\u76d8\u4e0a\u7684 . \u6309\u94ae\uff08\u6216\u8005\u5c06 URL \u4e2d\u7684 github.com \u66f4\u6539\u4e3a github.dev \uff09[^ref2]\uff0c\u8fdb\u5165 GitHub \u7684\u7f51\u9875\u7248 VS Code \u7f16\u8f91\u5668\uff1b \u5728\u7f16\u8f91\u5668\u4e2d\u4f5c\u51fa\u5bf9\u9875\u9762\u6e90\u6587\u4ef6\u7684\u66f4\u6539\uff0c\u53ef\u4ee5\u4f7f\u7528\u9875\u9762\u53f3\u4e0a\u65b9\u7684\u9884\u89c8\u6309\u94ae\uff08\u6216\u6309\u4e0b Ctrl+K V \u5feb\u6377\u952e\uff09\u5728\u53f3\u4fa7\u6253\u5f00\u9884\u89c8\u754c\u9762\uff1b \u4fee\u6539\u5b8c\u6210\u540e\u4f7f\u7528\u5de6\u4fa7\u7684 Source Control \u9009\u9879\u5361\uff0c\u5e76\u6309\u7167\u672c\u6587\u4e2d commit \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u586b\u5199 commit \u4fe1\u606f\u5e76\u63d0\u4ea4\uff0c\u63d0\u4ea4\u65f6\u4f1a\u63d0\u793a\u662f\u5426\u521b\u5efa\u6b64\u4ed3\u5e93\u7684\u5206\u652f\uff0c\u70b9\u51fb\u7eff\u8272\u7684 Fork Repository \u6309\u94ae\u5373\u53ef\u3002 \u63d0\u4ea4\u540e\u4f1a\u5728\u7f51\u9875\u4e0a\u65b9\u7684\u4e2d\u592e\u5f39\u51fa\u4e00\u4e2a\u63d0\u793a\u6846\uff0c\u5728\u7b2c\u4e00\u6b21\u7684\u63d0\u793a\u6846\u5185\u586b\u5199\u6807\u9898\uff0c\u7b2c\u4e8c\u6b21\u7684\u63d0\u793a\u6846\u5185\u586b\u5199\u6b64\u63d0\u4ea4\u8981\u63d0\u4ea4\u5230\u7684\u4ed3\u5e93\u5185\u5206\u652f\u540d\u79f0\uff0c\u4e4b\u540e\u53f3\u4e0b\u89d2\u4f1a\u5f39\u51fa\u4e00\u4e2a\u63d0\u793a\u6846\uff0c\u5185\u5bb9\u7c7b\u4f3c\u4e8e Created Pull Request #1 for OI-Wiki/OI-Wiki. \uff0c\u70b9\u51fb\u84dd\u5b57\u94fe\u63a5\u5373\u53ef\u67e5\u770b\u8be5 Pull Request\u3002","title":"\u7f16\u8f91\u591a\u4e2a\u9875\u9762\u5185\u7684\u5185\u5bb9"},{"location":"intro/htc.html#pull-request","text":"\u6253\u5f00 OI-Wiki \u7684 Pull Request \u5217\u8868 \uff0c\u627e\u5230\u60a8\u63d0\u4ea4\u7684 Pull Request \u5e76\u70b9\u51fb\u3002 Pull Request \u9875\u9762\u7684\u6807\u9898\u4e0b\u65b9\u5c06\u4f1a\u6709\u4e00\u6bb5\u4f8b\u5982 <\u60a8\u7684ID> wants to merge x commits into OI-wiki:master from <\u60a8\u7684ID>:patch-1 \u7684\u6587\u5b57\uff0c\u70b9\u51fb <\u60a8\u7684ID>:patch-1 \u90e8\u5206\u3002 \u60a8\u5e94\u8be5\u4f1a\u88ab\u91cd\u5b9a\u5411\u5230\u60a8\u7684\u5206\u652f\u4ed3\u5e93\u4e2d\uff0c\u800c\u4e14\u6587\u4ef6\u5217\u8868\u5de6\u4e0a\u89d2\u7684\u5206\u652f\u540d\u79f0\u662f\u4f60\u63d0\u4ea4 Pull Request \u7684\u5206\u652f\u540d\u79f0\uff08\u5728\u672c\u793a\u4f8b\u4e2d\u5e94\u4e3a patch-1 \uff09\u3002 \u8fdb\u884c\u60a8\u9700\u8981\u7684\u66f4\u6539\u3002 \u5982\u679c\u60a8\u9700\u8981\u7f16\u8f91\u5355\u4e2a\u6587\u4ef6\u6216\u591a\u4e2a\u4e92\u76f8\u65e0\u5173\u8054\u7684\u9875\u9762\u7684\u5185\u5bb9\uff0c\u8bf7\u76f4\u63a5\u627e\u5230\u4f60\u8981\u7684\u6587\u4ef6\u5e76\u8fdb\u884c\u66f4\u6539\uff0c\u66f4\u6539\u5b8c\u6210\u540e\u6eda\u52a8\u5230\u9875\u9762\u4e0b\u65b9\uff0c\u6309\u7167\u672c\u6587\u4e2d commit \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u586b\u5199 commit \u4fe1\u606f\uff0c\u4e4b\u540e\u70b9\u51fb Commit changes \u6309\u94ae\u63d0\u4ea4\u4fee\u6539\u3002 \u5982\u679c\u60a8\u9700\u8981\u7f16\u8f91\u591a\u4e2a\u6587\u4ef6\uff0c\u70b9\u51fb\u952e\u76d8\u4e0a\u7684 . \u6309\u94ae\uff08\u6216\u8005\u5c06 URL \u4e2d\u7684 github.com \u66f4\u6539\u4e3a github.dev \uff09[^ref2]\uff0c\u8fdb\u5165 GitHub \u7684\u7f51\u9875\u7248 VS Code \u7f16\u8f91\u5668\u5e76\u4f5c\u51fa\u66f4\u6539\u3002\u7136\u540e\u4f7f\u7528\u5de6\u4fa7\u7684 Source Control \u9009\u9879\u5361\uff0c\u5e76\u6309\u7167\u672c\u6587\u4e2d commit \u4fe1\u606f\u683c\u5f0f\u89c4\u8303 \u586b\u5199 commit \u4fe1\u606f\u5e76\u63d0\u4ea4\u4fee\u6539\u3002 \u8fd9\u65f6\u4f60\u7684\u66f4\u6539\u4f1a\u88ab\u81ea\u52a8\u8ffd\u52a0\u5728\u60a8\u7684 Pull Request \u4e2d\u3002","title":"\u5411 Pull Request \u8ffd\u52a0\u66f4\u6539"},{"location":"intro/htc.html#git","text":"Warning \u5bf9\u4e8e\u4e00\u822c\u7528\u6237\uff0c\u6211\u4eec\u66f4\u63a8\u8350\u4f7f\u7528\u4e0a\u65b9\u6240\u8ff0\u7684 GitHub \u7684 Web \u7f16\u8f91\u5668\u8fdb\u884c\u7f16\u8f91\u3002 \u867d\u7136\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u60a8\u53ef\u4ee5\u76f4\u63a5\u5728 GitHub \u4e0a\u8fdb\u884c\u7f16\u8f91\uff0c\u4f46\u5bf9\u4e8e\u4e00\u4e9b\u8f83\u4e3a\u7279\u6b8a\u7684\u60c5\u51b5\uff08\u5982\u9700\u8981\u4f7f\u7528 GPG \u7b7e\u540d\uff09\uff0c\u6211\u4eec\u66f4\u63a8\u8350\u4f7f\u7528 Git \u5728\u672c\u5730\u8fdb\u884c\u7f16\u8f91\u3002 \u5927\u81f4\u6d41\u7a0b\u5982\u4e0b\uff1a \u5c06\u4e3b\u4ed3\u5e93 Fork \u5230\u81ea\u5df1\u7684\u4ed3\u5e93\u4e2d\uff1b \u5c06 Fork \u540e\u7684\u5206\u652f\u4ed3\u5e93\u514b\u9686\uff08clone\uff09\u5230\u672c\u5730\uff1b \u5728\u672c\u5730\u8fdb\u884c\u4fee\u6539\u540e\u63d0\u4ea4\uff08commit\uff09\u8fd9\u4e9b\u66f4\u6539\uff1b \u5c06\u8fd9\u4e9b\u66f4\u6539\u63a8\u9001\uff08push\uff09\u5230\u4f60\u514b\u9686\u7684\u5206\u652f\u4ed3\u5e93\uff1b \u63d0\u4ea4 Pull Request \u81f3\u4e3b\u4ed3\u5e93\u3002 \u8be6\u7ec6\u7684\u64cd\u4f5c\u65b9\u5f0f\u53ef\u4ee5\u53c2\u8003 Git \u9875\u9762\u3002","title":"\u4f7f\u7528 Git \u5728\u672c\u5730\u8fdb\u884c\u7f16\u8f91"},{"location":"intro/htc.html#pull-request_1","text":"\u5728 clone \u4e0b\u6765\u7684\u672c\u5730\u5206\u652f\u4ed3\u5e93\u4e2d\u7ee7\u7eed\u8fdb\u884c\u4fee\u6539\uff0c\u5e76\u63d0\u4ea4\uff08commit\uff09\u4ee5\u53ca\u63a8\u9001\uff08push\uff09\u8fd9\u4e9b\u66f4\u6539\u5373\u53ef\u3002\u4f60\u7684\u66f4\u6539\u4f1a\u88ab\u81ea\u52a8\u8ffd\u52a0\u5728 Pull Request \u4e2d\u3002","title":"\u5411 Pull Request \u8ffd\u52a0\u66f4\u6539"},{"location":"intro/htc.html#_5","text":"\u5728 Pull Request \u9875\u9762\u4e0b\u65b9\u53ef\u4ee5\u627e\u5230\u6d4b\u8bd5\u9875\u9762\uff0c\u70b9\u51fb netlify/oi-wiki/deploy-preview \u4e00\u9879\u7684 Details \u94fe\u63a5\uff08\u5982\u4e0b\u56fe\uff09\uff0c\u53ef\u4ee5\u8fdb\u5165\u81ea\u52a8\u6784\u5efa\u7684\uff0c\u7531\u60a8\u53d8\u66f4\u540e\u7684\u9875\u9762\u4f9b\u60a8\u9884\u89c8\u3002","title":"\u5728\u6784\u5efa\u7684\u7f51\u9875\u4e2d\u9884\u89c8\u53d8\u66f4"},{"location":"intro/htc.html#_6","text":"\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u60a8\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a\u65b0\u9875\u9762\uff0c\u6216\u8005\u4fee\u6539\u5df2\u6709\u9875\u9762\u5728\u76ee\u5f55\u4e2d\u7684\u94fe\u63a5\uff0c\u60a8\u5c31\u9700\u8981\u5bf9 mkdocs.yml \u6587\u4ef6\u4f5c\u51fa\u6539\u52a8\u3002 \u6dfb\u52a0\u65b0\u9875\u9762\u53ef\u4ee5\u53c2\u8003\u65e2\u6709\u7684\u683c\u5f0f\u3002\u4f46\u9664\u975e\u662f\u8fdb\u884c\u91cd\u6784\u6216\u4fee\u6b63\u540d\u8bcd\uff0c\u5426\u5219 \u6211\u4eec\u4e0d\u5efa\u8bae\u5bf9\u65e2\u6709\u9875\u9762\u7684\u5f15\u7528\u94fe\u63a5\u8fdb\u884c\u4fee\u6539 \uff0cPull Requests \u4e2d\u4e0d\u5fc5\u8981\u7684\u4fee\u6539\u4e5f\u5c06\u88ab\u9a73\u56de\u3002 \u5982\u679c\u60a8\u575a\u6301\u8981\u4fee\u6539\u94fe\u63a5\uff0c\u8bf7\u6ce8\u610f\u66f4\u65b0 author \u5b57\u6bb5\u548c\u91cd\u5b9a\u5411\u6587\u4ef6\u3002","title":"\u5bf9\u4e8e\u76ee\u5f55\u548c\u5f15\u7528\u7684\u53d8\u66f4"},{"location":"intro/htc.html#author","text":"GitHub API \u5728\u6587\u4ef6\u76ee\u5f55\u53d8\u66f4\u540e\u4e0d\u80fd\u8ddf\u8e2a\u7edf\u8ba1\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u6587\u4ef6\u5934\u624b\u52a8\u7ef4\u62a4\u4e86\u4e00\u4e2a\u4f5c\u8005\u5217\u8868\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002author \u5b57\u6bb5\u4f4d\u4e8e\u6574\u4e2a Markdown \u6587\u4ef6\u7684\u5f00\u5934\uff0c\u5f62\u5982 author: Ir1d, cjsoft \uff0c\u76f8\u90bb\u4e24\u4e2a ID \u4e4b\u95f4\u7528\u9017\u53f7\u52a0\u7a7a\u683c\u9694\u5f00\u3002\u8fd9\u91cc\u7684 ID \u662f GitHub \u7684\u7528\u6237\u540d\uff0c\u5373 GitHub profile \u7684\u5730\u5740\uff08\u4f8b\u5982 https://github.com/Ir1d \u4e2d\u7684 Ir1d \uff09\u3002 \u4fee\u6539\u94fe\u63a5\u65f6\uff0c\u9700\u8981\u5c06\u5f53\u524d\u9875\u9762\u4e2d\u7684 contributors \u9010\u4e00\u586b\u5165 author \u5b57\u6bb5\u3002","title":"author \u5b57\u6bb5"},{"location":"intro/htc.html#_7","text":"\u5728\u4fee\u6539\u94fe\u63a5\u65f6\uff0c\u4e3a\u4e86\u907f\u514d\u5728\u7ad9\u5916\u5f15\u7528\u65f6\u51fa\u73b0\u6b7b\u94fe\uff0c\u9700\u8981\u4fee\u6539\u91cd\u5b9a\u5411\u6587\u4ef6\u3002 _redirects \u6587\u4ef6\u7528\u4e8e\u751f\u6210 netlify \u7684\u914d\u7f6e \u548c \u7528\u4e8e\u8df3\u8f6c\u7684\u6587\u4ef6 \u3002 \u6bcf\u4e00\u884c\u8868\u793a\u4e00\u4e2a\u91cd\u5b9a\u5411\u89c4\u5219\uff0c\u5206\u522b\u5199\u8df3\u8f6c\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\u7684 url\uff08\u4e0d\u5305\u542b\u57df\u540d\uff09\uff1a /path/to/src /path/to/desc \u6ce8\uff1a\u6240\u6709\u8df3\u8f6c\u5747\u4e3a 301 \u8df3\u8f6c\uff0c\u53ea\u6709\u5728\u4fee\u6539\u76ee\u5f55\u4e2d url \u9020\u6210\u6b7b\u94fe\u7684\u65f6\u5019\u9700\u8981\u4fee\u6539\u3002","title":"\u91cd\u5b9a\u5411\u6587\u4ef6"},{"location":"intro/htc.html#commit","text":"\u5bf9\u4e8e\u63d0\u4ea4\u65f6\u9700\u8981\u586b\u5199\u7684 commit \u4fe1\u606f\uff0c\u8bf7\u9075\u5b88\u4ee5\u4e0b\u51e0\u70b9\u57fa\u672c\u8981\u6c42\uff1a commit \u6458\u8981\u8bf7\u7b80\u8981\u63cf\u8ff0\u8fd9\u4e00\u6b21 commit \u6539\u52a8\u7684\u5185\u5bb9\u3002\u6ce8\u610f commit \u6458\u8981\u7684\u957f\u5ea6\u4e0d\u8981\u8d85\u8fc7 50 \u5b57\u7b26\uff0c\u8d85\u51fa\u7684\u90e8\u5206\u4f1a\u81ea\u52a8\u7f6e\u4e8e\u6b63\u6587\u4e2d\u3002 \u5982\u679c\u9700\u8981\u8fdb\u4e00\u6b65\u63cf\u8ff0\u672c\u6b21 commit \u5185\u5bb9\uff0c\u8bf7\u5728\u6b63\u6587\u4e2d\u8be6\u7ec6\u8bf4\u660e\u3002 \u5bf9\u4e8e commit \u6458\u8981\uff0c\u63a8\u8350\u6309\u7167\u5982\u4e0b\u683c\u5f0f\u4e66\u5199\uff1a <\u4fee\u6539\u7c7b\u578b>(<\u6587\u4ef6\u540d>): <\u4fee\u6539\u7684\u5185\u5bb9> \u4fee\u6539\u7c7b\u578b\u5206\u4e3a\u5982\u4e0b\u51e0\u7c7b\uff1a feat \uff1a\u7528\u4e8e\u6dfb\u52a0\u5185\u5bb9\u7684\u60c5\u51b5\u3002 fix \uff1a\u7528\u4e8e\u4fee\u6b63\u73b0\u6709\u5185\u5bb9\u9519\u8bef\u7684\u60c5\u51b5\u3002 refactor \uff1a\u7528\u4e8e\u5bf9\u4e00\u4e2a\u9875\u9762\u8fdb\u884c\u91cd\u6784\uff08\u8f83\u5927\u89c4\u6a21\u7684\u66f4\u6539\uff09\u7684\u60c5\u51b5\u3002 revert \uff1a\u7528\u4e8e\u56de\u9000\u4e4b\u524d\u66f4\u6539\u7684\u60c5\u51b5\u3002","title":"Commit \u4fe1\u606f\u683c\u5f0f\u89c4\u8303"},{"location":"intro/htc.html#pull-request_2","text":"\u5bf9\u4e8e Pull Request\uff0c\u8bf7\u9075\u5b88\u4ee5\u4e0b\u51e0\u70b9\u8981\u6c42\uff1a \u6807\u9898\u8bf7\u5199\u660e\u672c\u6b21 PR \u7684\u76ee\u7684\uff08\u505a\u4e86 \u4ec0\u4e48 \u5de5\u4f5c\uff0c\u4fee\u590d\u4e86 \u4ec0\u4e48 \u95ee\u9898\uff09\u3002 \u5185\u5bb9\u8bf7\u7b80\u8981\u53d9\u8ff0\u4fee\u6539\u7684\u5185\u5bb9\u3002\u5982\u679c\u4fee\u590d\u4e86\u4e00\u4e2a issue \u7684\u95ee\u9898\uff0c\u8bf7\u5728\u5185\u5bb9\u4e2d\u6dfb\u52a0 fix #xxxx \u5b57\u6bb5\uff0c\u5176\u4e2d xxxx \u4ee3\u8868 issue \u7684\u7f16\u53f7\u3002 \u8bf7\u60a8\u4ed4\u7ec6\u9605\u8bfb \u8d21\u732e\u6307\u5357 \u548c \u793e\u533a\u516c\u7ea6 \uff0c\u5e76\u5728\u540c\u610f\u540e\u52fe\u9009 PR \u6a21\u677f\u4e2d\u7684\u6846\uff0c\u8868\u793a\u60a8\u540c\u610f\u4e86\u4ee5\u4e0a\u6307\u5357\u548c\u516c\u7ea6\u3002 \u5bf9\u4e8e Pull Request \u7684\u6807\u9898\uff0c\u63a8\u8350\u4f7f\u7528\u5982\u4e0b\u683c\u5f0f\u4e66\u5199\uff1a <\u4fee\u6539\u7c7b\u578b>(<\u6587\u4ef6\u540d>): <\u4fee\u6539\u7684\u5185\u5bb9> (<\u5bf9\u5e94 issue \u7684\u7f16\u53f7>) \u4fee\u6539\u7c7b\u578b\u5206\u4e3a\u5982\u4e0b\u51e0\u7c7b\uff1a feat \uff1a\u7528\u4e8e\u6dfb\u52a0\u5185\u5bb9\u7684\u60c5\u51b5\u3002 fix \uff1a\u7528\u4e8e\u4fee\u6b63\u73b0\u6709\u5185\u5bb9\u9519\u8bef\u7684\u60c5\u51b5\u3002 refactor \uff1a\u7528\u4e8e\u5bf9\u4e00\u4e2a\u9875\u9762\u8fdb\u884c\u91cd\u6784\uff08\u8f83\u5927\u89c4\u6a21\u7684\u66f4\u6539\uff09\u7684\u60c5\u51b5\u3002 revert \uff1a\u7528\u4e8e\u56de\u9000\u4e4b\u524d\u66f4\u6539\u7684\u60c5\u51b5\u3002 \u793a\u4f8b\uff1a fix(ds/persistent-seg): \u4fee\u6539\u4ee3\u7801\u6ce8\u91ca\u4f7f\u63cf\u8ff0\u66f4\u6e05\u6670 fix: tools/judger/index \u4e0d\u5728\u76ee\u5f55\u4e2d (#3709) feat(math/poly/fft): better proof refactor(ds/stack): \u6574\u7406\u9875\u9762\u5185\u5bb9","title":"Pull Request \u4fe1\u606f\u683c\u5f0f\u89c4\u8303"},{"location":"intro/htc.html#_8","text":"\u5728\u6536\u5230\u4e00\u4e2a\u65b0\u7684 Pull Request \u4e4b\u540e\uff0cGitHub \u4f1a\u7ed9 reviewer \u53d1\u9001\u90ae\u4ef6\uff1b \u4e0e\u6b64\u540c\u65f6\uff0c\u5728 GitHub Actions \u548c Netlify \u4e0a\u4f1a\u8fd0\u884c\u4e24\u7ec4\u6d4b\u8bd5\uff0c\u5b83\u4eec\u4f1a\u628a\u8fdb\u5ea6\u540c\u6b65\u5728 PR \u9875\u9762\u7684\u4e0b\u65b9\u3002GitHub Actions \u4e3b\u8981\u7528\u6765\u786e\u8ba4 PR \u4e2d\u5185\u5bb9\u7684\u4fee\u6539\u4e0d\u4f1a\u5f71\u54cd\u5230\u7f51\u7ad9\u6784\u5efa\u7684\u8fdb\u7a0b\uff1bNetlify \u7528\u6765\u628a PR \u4e2d\u7684\u66f4\u65b0\u6784\u5efa\u51fa\u6765\uff0c\u65b9\u4fbf reviewer \u5ba1\u6838\uff08\u5728\u6d4b\u8bd5\u5b8c\u6210\u540e\u70b9\u51fb Details \u53ef\u4ee5\u4e86\u89e3\u66f4\u591a\uff09\uff1b reviewer \u53ef\u80fd\u4f1a\u53d1\u73b0\u95ee\u9898\uff0c\u5e76\u63d0\u51fa review \u6216 suggested changes \uff08\u5efa\u8bae\u66f4\u6539\uff0c\u663e\u793a\u4e3a\u7070\u8272\u56fe\u6807\uff09/ requested changes \uff08\u5f3a\u5236\u66f4\u6539\uff0c\u663e\u793a\u4e3a\u7ea2\u8272\u56fe\u6807\uff0c\u53ea\u4f1a\u5728 reviewer \u62e5\u6709 repo \u5199\u6743\u9650\u65f6\u51fa\u73b0\uff09\u3002\u4e00\u822c\u6765\u8bf4\uff0creviewer \u4e5f\u4f1a\u9644\u4e0a\u5efa\u8bae\u548c\u9700\u8981\u8fdb\u884c\u7684\u66f4\u6539\uff0c\u5728\u8fd9\u65f6\uff0c\u60a8\u5c06\u4f1a\u9700\u8981\u7ee7\u7eed\u5411 Pull Request \u8ffd\u52a0\u5176\u4ed6\u66f4\u6539\u3002\u66f4\u6539\u7684\u65b9\u6cd5\u53ef\u4ee5\u53c2\u8003 \u5728 GitHub \u4e0a\u7f16\u8f91 \u6216\u8005 \u4f7f\u7528 Git \u5728\u672c\u5730\u8fdb\u884c\u7f16\u8f91 \u90e8\u5206\u7684 \u5411 Pull Request \u8ffd\u52a0\u66f4\u6539 \u90e8\u5206\u3002 \u5728\u8db3\u591f\u591a reviewer \u6295\u7968\u901a\u8fc7\u4e00\u4e2a PR \u4e4b\u540e\uff0c\u8fd9\u4e2a PR \u624d\u53ef\u4ee5\u5408\u5e76\u5230 master \u5206\u652f\u4e2d\uff1b \u5728\u5408\u5e76\u5230 master \u5206\u652f\u4e4b\u540e\uff0cGitHub Actions \u4f1a\u91cd\u65b0\u6784\u5efa\u4e00\u904d\u7f51\u7ad9\u5185\u5bb9\uff0c\u5e76\u66f4\u65b0\u5230 gh-pages \u5206\u652f\uff1b \u8fd9\u65f6\u670d\u52a1\u5668\u624d\u4f1a\u62c9\u53d6 gh-pages \u5206\u652f\u7684\u66f4\u65b0\uff0c\u5e76\u91cd\u65b0\u90e8\u7f72\u6700\u65b0\u7248\u672c\u7684\u5185\u5bb9\u3002","title":"\u534f\u4f5c\u6d41\u7a0b"},{"location":"intro/htc.html#_9","text":"[^ref2]: Web-based editor - GitHub Codespaces - GitHub Docs","title":"\u53c2\u8003\u8d44\u6599\u4e0e\u6ce8\u91ca"},{"location":"intro/mirrors.html","text":"OI Wiki \u90e8\u7f72\u5728\u56fd\u5916\u670d\u52a1\u5668\u4e0a\uff0c\u6709\u65f6\u53ef\u80fd\u4f1a\u56e0\u4e3a\u5404\u79cd\u539f\u56e0\uff0c\u51fa\u73b0\u8bbf\u95ee\u4e0d\u901a\u7545\u7684\u60c5\u51b5\u3002 \u6211\u4eec\u642d\u5efa\u4e86\u4e00\u4e2a\u72b6\u6001\u9875\uff1a https://status.oi-wiki.org \uff0c\u7528\u4e8e\u76d1\u63a7 OI Wiki \u7ad9\u70b9\u7684\u5728\u7ebf\u60c5\u51b5\u3002\u5982\u679c\u4f60\u9047\u5230\u4e86\u65e0\u6cd5\u8bbf\u95ee\u7684\u95ee\u9898\uff0c\u53ef\u4ee5\u6253\u5f00\u72b6\u6001\u9875\uff0c\u5bfb\u627e\u53ef\u4ee5\u8fde\u63a5\u7684\u955c\u50cf\u7ad9\u3002 \u4ee5\u4e0b\u662f\u4e00\u4e2a OI Wiki \u7684\u955c\u50cf\u7ad9\u5217\u8868\uff0c\u53ef\u4f9b\u9009\u7528\uff1a OI Wiki \u4e3b\u7ad9\uff0c\u7ebf\u8def\uff1aDMIT https://oi-wiki.org \u7ef4\u62a4\u8005\uff1a OI Wiki \uff0c\u7ebf\u8def\uff1a\u963f\u91cc\u4e91\uff0c\u540c\u6b65\u9891\u7387\uff1a\u4e0e\u4e3b\u7ad9\u76f8\u540c http://oi-wiki.com \u7ef4\u62a4\u8005\uff1a OI Wiki \uff0c\u7ebf\u8def\uff1aNetlify\uff0c\u540c\u6b65\u9891\u7387\uff1a\u4e0e\u4e3b\u7ad9\u76f8\u540c https://demo.oi-wiki.org \u7ef4\u62a4\u8005\uff1a\u7434\u6625\uff08 vx.st \uff09\uff0c\u7ebf\u8def\uff1aAWS\uff0c\u540c\u6b65\u9891\u7387\uff1a\u4e0e\u4e3b\u7ad9\u76f8\u540c https://oi-wiki.net https://oi-wiki.wiki https://oi-wiki.win https://oi-wiki.xyz https://oiwiki.moe https://oiwiki.net https://oiwiki.org https://oiwiki.vx.st https://oiwiki.wiki https://oiwiki.win https://oiwiki.com \u7ef4\u62a4\u8005\uff1aMenci\uff08 men.ci \uff09\uff0c\u7ebf\u8def\uff1aAzure + \u963f\u91cc\u4e91 CDN\uff0c\u540c\u6b65\u9891\u7387\uff1a\u4e0e\u4e3b\u7ad9\u76f8\u540c https://oi.wiki","title":"Mirrors"},{"location":"intro/symbol.html","text":"\u672c\u6587\u89c4\u5b9a\u4e86 OI Wiki \u4e2d\u6570\u5b66\u7b26\u53f7\u7684\u63a8\u8350\u5199\u6cd5\uff0c\u5e76\u7ed9\u51fa\u4e86\u4e00\u4e9b\u5e94\u7528\u8303\u4f8b\u3002 \u672c\u6587\u53c2\u8003\u4e86 GB/T 3102.11-1993 \u548c ISO 80000-2:2019 \u4fee\u8ba2\uff0c\u6545\u57fa\u672c\u4e0e\u56fd\u5185\u901a\u884c\u6559\u6750\u7684\u7b26\u53f7\u4f53\u7cfb\u517c\u5bb9\u3002 \u7b26\u53f7\u7684 LaTeX \u5199\u6cd5\u8bf7\u53c2\u8003 \u672c\u6587\u7ae0\u7684\u6e90\u4ee3\u7801 \u6570\u7406\u903b\u8f91 \u00b6 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n1.1 $p \\land q$ $p$ \u548c $q$ \u7684\u5408\u53d6 $p$ \u4e0e $q$ . n1.2 $p \\lor q$ $p$ \u548c $q$ \u7684\u6790\u53d6 $p$ \u6216 $q$ ; \u6b64\u5904\u7684 \"\u6216\" \u662f\u5305\u542b\u7684\uff0c\u5373\u82e5 $p$ \uff0c $q$ \u4e2d\u6709\u4e00\u4e2a\u4e3a\u771f\u9648\u8ff0\uff0c\u5219 $p \\lor q$ \u4e3a\u771f\u3002 n1.3 $\\lnot p$ $p$ \u7684\u5426\u5b9a \u975e $p$ . n1.4 $p \\implies q$ $p$ \u8574\u542b $q$ ; \u82e5 $p$ \u4e3a\u771f\uff0c\u5219 $q$ \u4e3a\u771f $q \\impliedby p$ \u548c $p \\implies q$ \u540c\u4e49\u3002 n1.5 $p \\iff q$ $p$ \u7b49\u4ef7\u4e8e $q$ $(p \\implies q) \\land (q \\implies p)$ \u548c $p \\iff q$ \u540c\u4e49\u3002 n1.6 $(\\forall~x \\in A)~~p(x)$ \u5bf9 $A$ \u4e2d\u6240\u6709\u7684 $x$ , \u547d\u9898 $p(x)$ \u5747\u4e3a\u771f \u5982\u679c\u4ece\u4e0a\u4e0b\u6587\u4e2d\u53ef\u4ee5\u5f97\u77e5\u8003\u8651\u7684\u662f\u54ea\u4e2a\u96c6\u5408 $A$ , \u53ef\u4ee5\u4f7f\u7528\u8bb0\u53f7 $(\\forall~x)~~p(x)$ . $\\forall$ \u79f0\u4e3a\u5168\u79f0\u91cf\u8bcd\u3002 $x \\in A$ \u7684\u542b\u4e49\u89c1 n2.1. n1.7 $(\\exists~x \\in A)~~p(x)$ \u5b58\u5728\u4e00\u4e2a\u5c5e\u4e8e $A$ \u7684 $x$ \u4f7f\u5f97 $p(x)$ \u4e3a\u771f \u5982\u679c\u4ece\u4e0a\u4e0b\u6587\u4e2d\u53ef\u4ee5\u5f97\u77e5\u8003\u8651\u7684\u662f\u54ea\u4e2a\u96c6\u5408 $A$ , \u53ef\u4ee5\u4f7f\u7528\u8bb0\u53f7 $(\\exists~x)~~p(x)$ . $\\exists$ \u79f0\u4e3a\u5b58\u5728\u91cf\u8bcd\u3002 $x \\in A$ \u7684\u542b\u4e49\u89c1 n2.1. $(\\exists!~x)~~p(x)$ \uff08\u552f\u4e00\u91cf\u8bcd\uff09\u7528\u6765\u8868\u793a\u6070\u6709\u4e00\u4e2a $x$ \u4f7f\u5f97 $p(x)$ \u4e3a\u771f\u3002 $\\exists!$ \u4e5f\u53ef\u4ee5\u5199\u4f5c $\\exists^1$ . \u96c6\u5408\u8bba \u00b6 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n2.1 $x \\in A$ $x$ \u5c5e\u4e8e $A$ \uff0c $x$ \u662f\u96c6\u5408 $A$ \u4e2d\u7684\u5143\u7d20 $A \\ni x$ \u548c $x \\in A$ \u540c\u4e49\u3002 n2.2 $y \\notin A$ $y$ \u4e0d\u5c5e\u4e8e $A$ \uff0c $y$ \u4e0d\u662f\u96c6\u5408 $A$ \u4e2d\u7684\u5143\u7d20 n2.3 $\\{x_1, x_2, \\dots, x_n\\}$ \u542b\u5143\u7d20 $x_1, x_2, \\dots, x_n$ \u7684\u96c6\u5408 \u4e5f\u53ef\u5199\u4f5c $\\{x_i ~\\vert~ i \\in I\\}$ , \u5176\u4e2d $I$ \u8868\u793a\u6307\u6807\u96c6\u3002 n2.4 $\\{x \\in A ~\\vert~ p(x)\\}$ $A$ \u4e2d\u4f7f\u547d\u9898 $p(x)$ \u4e3a\u771f\u7684\u6240\u6709\u5143\u7d20\u7ec4\u6210\u7684\u96c6\u5408 \u4f8b\u5982 $\\{x \\in \\textbf{R} ~\\vert~ x \\geq 5\\}$ ; \u5982\u679c\u4ece\u4e0a\u4e0b\u6587\u4e2d\u53ef\u4ee5\u5f97\u77e5\u8003\u8651\u7684\u662f\u54ea\u4e2a\u96c6\u5408 $A$ \uff0c\u53ef\u4ee5\u4f7f\u7528\u7b26\u53f7 $\\{x ~\\vert~ p(x)\\}$ \uff08\u5982\u5728\u53ea\u8003\u8651\u5b9e\u6570\u96c6\u65f6\u53ef\u4f7f\u7528 $\\{x ~\\vert~ x \\geq 5\\}$ \uff09 $\\vert$ \u4e5f\u53ef\u4ee5\u4f7f\u7528\u5192\u53f7\u66ff\u4ee3\uff0c\u5982 $\\{x \\in A : p(x)\\}$ . n2.5 $\\operatorname{card} A$ ; $\\vert A\\vert$ $A$ \u4e2d\u7684\u5143\u7d20\u4e2a\u6570\uff0c $A$ \u7684\u57fa\u6570 n2.6 $\\varnothing$ \u7a7a\u96c6 \u4e0d\u5e94\u4f7f\u7528 $\\emptyset$ . n2.7 $B \\subseteq A$ $B$ \u5305\u542b\u4e8e $A$ \u4e2d\uff0c $B$ \u662f $A$ \u7684\u5b50\u96c6 $B$ \u7684\u6bcf\u4e2a\u5143\u7d20\u90fd\u5c5e\u4e8e $A$ . $\\subset$ \u4e5f\u53ef\u7528\u4e8e\u8be5\u542b\u4e49\uff0c\u4f46\u8bf7\u53c2\u9605 n2.8 \u7684\u8bf4\u660e\u3002 $A \\supseteq B$ \u548c $B \\subseteq A$ \u540c\u4e49\u3002 n2.8 $B \\subset A$ $B$ \u771f\u5305\u542b\u4e8e $A$ \u4e2d\uff0c $B$ \u662f $A$ \u7684\u771f\u5b50\u96c6 $B$ \u7684\u6bcf\u4e2a\u5143\u7d20\u90fd\u5c5e\u4e8e $A$ , \u4e14 $A$ \u4e2d\u81f3\u5c11\u6709\u4e00\u4e2a\u5143\u7d20\u4e0d\u5c5e\u4e8e $B$ . \u82e5 $\\subset$ \u7684\u542b\u4e49\u53d6 n2.7, \u5219 n2.8 \u5bf9\u5e94\u7684\u7b26\u53f7\u5e94\u4f7f\u7528 $\\subsetneq$ . $A \\supset B$ \u4e0e $B \\subset A$ \u540c\u4e49\u3002 n2.9 $A \\cup B$ $A$ \u548c $B$ \u7684\u5e76\u96c6 $A \\cup B := \\{x ~\\vert~ x \\in A \\lor x \\in B\\}$ ; $:=$ \u7684\u5b9a\u4e49\u53c2\u89c1 n4.3 n2.10 $A \\cap B$ $A$ \u548c $B$ \u7684\u4ea4\u96c6 $A \\cap B := \\{x ~\\vert~ x \\in A \\land x \\in B\\}$ ; $:=$ \u7684\u5b9a\u4e49\u53c2\u89c1 n4.3 n2.11 $\\displaystyle \\bigcup\\limits_{i=1}^n A_i$ \u96c6\u5408 $A_1, A_2, \\dots, A_n$ \u7684\u5e76\u96c6 $\\displaystyle \\bigcup\\limits_{i=1}^n A_i=A_1\\cup A_2\\cup \\dots \\cup A_n$ ; \u4e5f\u53ef\u4f7f\u7528 $\\displaystyle \\bigcup\\nolimits_{i=1}^n$ \uff0c $\\displaystyle \\bigcup\\limits_{i\\in I}$ \uff0c $\\displaystyle \\bigcup\\nolimits_{i\\in I}$ , \u5176\u4e2d $I$ \u8868\u793a\u6307\u6807\u96c6 n2.12 $\\displaystyle \\bigcap\\limits_{i=1}^n A_i$ \u96c6\u5408 $A_1, A_2, \\dots, A_n$ \u7684\u4ea4\u96c6 $\\displaystyle \\bigcap\\limits_{i=1}^n A_i=A_1\\cap A_2\\cap \\dots \\cap A_n$ ; \u4e5f\u53ef\u4f7f\u7528 $\\displaystyle \\bigcap\\nolimits_{i=1}^n$ \uff0c $\\displaystyle \\bigcap\\limits_{i\\in I}$ \uff0c $\\displaystyle \\bigcap\\nolimits_{i\\in I}$ , \u5176\u4e2d $I$ \u8868\u793a\u6307\u6807\u96c6 n2.13 $A \\setminus B$ $A$ \u548c $B$ \u7684\u5dee\u96c6 $A \\setminus B = \\{x ~\\vert~ x \\in A \\land x \\notin B\\}$ ; \u4e0d\u5e94\u4f7f\u7528 $A - B$ ; \u5f53 $B$ \u662f $A$ \u7684\u5b50\u96c6\u65f6\u4e5f\u53ef\u4f7f\u7528 $\\complement_A B$ , \u5982\u679c\u4ece\u4e0a\u4e0b\u6587\u4e2d\u53ef\u4ee5\u5f97\u77e5\u8003\u8651\u7684\u662f\u54ea\u4e2a\u96c6\u5408 $A$ \uff0c\u5219 $A$ \u53ef\u4ee5\u7701\u7565\u3002 \u4e0d\u5f15\u8d77\u6b67\u4e49\u7684\u60c5\u51b5\u4e0b\u4e5f\u53ef\u4f7f\u7528 $\\overline{B}$ \u8868\u793a\u96c6\u5408 $B$ \u7684\u8865\u96c6\u3002 n2.14 $(a, b)$ \u6709\u5e8f\u6570\u5bf9 $a$ \uff0c $b$ ; \u6709\u5e8f\u5076 $a$ \uff0c $b$ $(a, b) = (c, d)$ \u5f53\u4e14\u4ec5\u5f53 $a = c$ \u4e14 $b = d$ . n2.15 $(a_1, a_2, \\dots, a_n)$ \u6709\u5e8f $n$ \u5143\u7ec4 \u53c2\u89c1 n2.14. n2.16 $A \\times B$ \u96c6\u5408 $A$ \u548c $B$ \u7684\u7b1b\u5361\u5c14\u79ef $A \\times B = \\{(x, y) ~\\vert~ x \\in A \\land y \\in B\\}$ . n2.17 $\\displaystyle \\prod\\limits_{i=1}^{n} A_i$ \u96c6\u5408 $A_1, A_2, \\dots, A_n$ \u7684\u7b1b\u5361\u5c14\u79ef $\\displaystyle \\prod\\limits_{i=1}^{n} A_i=\\{(x_1, x_2, \\dots, x_n) ~\\vert~ x_1 \\in A_1, x_2 \\in A_2, \\dots, x_n \\in A_n\\}$ ; $A \\times A \\times \\dots \\times A$ \u8bb0\u4e3a $A^n$ , \u5176\u4e2d $n$ \u662f\u4e58\u79ef\u4e2d\u7684\u56e0\u5b50\u6570\u3002 n2.18 $\\mathrm{id}_A$ $A\\times A$ \u7684\u5bf9\u89d2\u96c6 $\\mathrm{id}_A=\\{(x, x)~\\vert~x\\in A\\}$ ; \u5982\u679c\u4ece\u4e0a\u4e0b\u6587\u4e2d\u53ef\u4ee5\u5f97\u77e5\u8003\u8651\u7684\u662f\u54ea\u4e2a\u96c6\u5408 $A$ , \u5219 $A$ \u53ef\u4ee5\u7701\u7565\u3002 \u6807\u51c6\u6570\u96c6\u548c\u533a\u95f4 \u00b6 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n3.1 $\\mathbf{N}$ \u81ea\u7136\u6570\u96c6 $\\mathbf{N} = \\{0, 1, 2, 3, \\dots\\}$ ; $\\mathbf{N}^* = \\mathbf{N}_+ = \\{1, 2, 3, \\dots\\}$ ; \u53ef\u7528\u5982\u4e0b\u65b9\u5f0f\u6dfb\u52a0\u5176\u4ed6\u9650\u5236\uff1a $\\mathbf{N}_{> 5} = \\{n \\in \\mathbf{N} ~\\vert~ n > 5\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{N}$ . n3.2 $\\mathbf{Z}$ \u6574\u6570\u96c6 $\\mathbf{Z}^* = \\mathbf{Z}_+ = \\{n \\in \\mathbf{Z} ~\\vert~ n \\ne 0\\}$ ; \u53ef\u7528\u5982\u4e0b\u65b9\u5f0f\u6dfb\u52a0\u5176\u4ed6\u9650\u5236\uff1a $\\mathbf{Z}_{> -3} = \\{n \\in \\mathbf{Z} ~\\vert~ n > -3\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{Z}$ . n3.3 $\\mathbf{Q}$ \u6709\u7406\u6570\u96c6 $\\mathbf{Q}^* = \\mathbf{Q}_+ = \\{r \\in \\mathbf{Q} ~\\vert~ r \\ne 0\\}$ ; \u53ef\u7528\u5982\u4e0b\u65b9\u5f0f\u6dfb\u52a0\u5176\u4ed6\u9650\u5236\uff1a $\\mathbf{Q}_{< 0} = \\{r \\in \\mathbf{Q} ~\\vert~ r < 0\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{Q}$ . n3.4 $\\mathbf{R}$ \u5b9e\u6570\u96c6 $\\mathbf{R}^* = \\mathbf{R}_+ = \\{x \\in \\mathbf{R} ~\\vert~ x \\ne 0\\}$ ; \u53ef\u7528\u5982\u4e0b\u65b9\u5f0f\u6dfb\u52a0\u5176\u4ed6\u9650\u5236\uff1a $\\mathbf{R}_{> 0} = \\{x \\in \\mathbf{R} ~\\vert~ x > 0\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{R}$ . n3.5 $\\mathbf{C}$ \u590d\u6570\u96c6 $\\mathbf{C}^* = \\mathbf{C}_+ = \\{z \\in \\mathbf{C} ~\\vert~ z \\ne 0\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{C}$ . n3.6 $\\mathbf{P}$ \uff08\u6b63\uff09\u7d20\u6570\u96c6 $\\mathbf{P} = \\{2, 3, 5, 7, 11, 13, 17, \\dots\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{P}$ . n3.7 $[a, b]$ $a$ \u5230 $b$ \u7684\u95ed\u533a\u95f4 $[a, b] = \\{x \\in \\mathbf{R} ~\\vert~ a \\leq x \\leq b\\}$ . n3.8 $(a, b]$ $a$ \u5230 $b$ \u7684\u5de6\u5f00\u53f3\u95ed\u533a\u95f4 $(a, b] = \\{x \\in \\mathbf{R} ~\\vert~ a < x \\leq b\\}$ ; $(-\\infty, b] = \\{x \\in \\mathbf{R} ~\\vert~ x \\leq b\\}$ . n3.9 $[a, b)$ $a$ \u5230 $b$ \u7684\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 $[a, b) = \\{x \\in \\mathbf{R} ~\\vert~ a \\leq x < b\\}$ ; $[a, +\\infty) = \\{x \\in \\mathbf{R} ~\\vert~ a \\leq x\\}$ . n3.10 $(a, b)$ $a$ \u5230 $b$ \u7684\u5f00\u533a\u95f4 $(a, b) = \\{x \\in \\mathbf{R} ~\\vert~ a < x < b\\}$ ; $(-\\infty, b) = \\{x \\in \\mathbf{R} ~\\vert~ x < b\\}$ ; $(a, +\\infty) = \\{x \\in \\mathbf{R} ~\\vert~ a < x\\}$ . \u5173\u7cfb \u00b6 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n4.1 $a = b$ $a$ \u7b49\u4e8e $b$ $\\equiv$ \u7528\u4e8e\u5f3a\u8c03\u67d0\u7b49\u5f0f\u662f\u6052\u7b49\u5f0f \u8be5\u7b26\u53f7\u7684\u53e6\u4e00\u4e2a\u542b\u4e49\u53c2\u89c1 n4.18. n4.2 $a \\ne b$ $a$ \u4e0d\u7b49\u4e8e $b$ n4.3 $a := b$ $a$ \u5b9a\u4e49\u4e3a $b$ \u53c2\u89c1 n2.9, n2.10 n4.4 $a \\approx b$ $a$ \u7ea6\u7b49\u4e8e $b$ \u4e0d\u6392\u9664\u76f8\u7b49\u3002 n4.5 $a \\simeq b$ $a$ \u6e10\u8fdb\u7b49\u4e8e $b$ \u4f8b\u5982\uff1a \u5f53 $x\\to a$ \u65f6\uff0c $\\dfrac{1}{\\sin(x-a)} \\simeq \\dfrac{1}{x-a}$ ; $x \\to a$ \u7684\u542b\u4e49\u53c2\u89c1 n4.15. n4.6 $a \\propto b$ $a$ \u4e0e $b$ \u6210\u6b63\u6bd4 \u4e5f\u53ef\u4f7f\u7528 $a \\sim b$ . $\\sim$ \u4e5f\u7528\u4e8e\u8868\u793a\u7b49\u4ef7\u5173\u7cfb\u3002 n4.7 $M \\cong N$ $M$ \u4e0e $N$ \u5168\u7b49 \u5f53 $M$ \u548c $N$ \u662f\u70b9\u96c6\uff08\u51e0\u4f55\u56fe\u5f62\uff09\u65f6\u3002 \u8be5\u7b26\u53f7\u4e5f\u7528\u4e8e\u8868\u793a\u4ee3\u6570\u7ed3\u6784\u7684\u540c\u6784\u3002 n4.8 $a < b$ $a$ \u5c0f\u4e8e $b$ n4.9 $b > a$ $b$ \u5927\u4e8e $a$ n4.10 $a \\leq b$ $a$ \u5c0f\u4e8e\u7b49\u4e8e $b$ n4.11 $b \\geq a$ $b$ \u5927\u4e8e\u7b49\u4e8e $a$ n4.12 $a \\ll b$ $a$ \u8fdc\u5c0f\u4e8e $b$ n4.13 $b \\gg a$ $b$ \u8fdc\u5927\u4e8e $a$ n4.14 $\\infty$ \u65e0\u7a77\u5927 \u8be5\u7b26\u53f7 \u4e0d \u662f\u6570\u5b57\u3002 \u4e5f\u53ef\u4ee5\u4f7f\u7528 $+\\infty$ \uff0c $-\\infty$ . n4.15 $x \\to a$ $x$ \u8d8b\u8fd1\u4e8e $a$ \u4e00\u822c\u51fa\u73b0\u5728\u6781\u9650\u8868\u8fbe\u5f0f\u4e2d\u3002 $a$ \u4e5f\u53ef\u4ee5\u4e3a $\\infty$ \uff0c $+\\infty$ \uff0c $-\\infty$ . n4.16 $m \\mid n$ $m$ \u6574\u9664 $n$ \u5bf9\u6574\u6570 $m$ \uff0c $n$ : $(\\exists~k \\in \\mathbf{Z})~~m\\cdot k = n$ . n4.17 $m \\perp n$ $m$ \u4e0e $n$ \u4e92\u8d28 \u5bf9\u6574\u6570 $m$ \uff0c $n$ : $(\\nexists~k \\in \\mathbf{Z}_{>1})~~(k \\mid m) \\land (k \\mid n)$ ; \u8be5\u7b26\u53f7\u7684\u53e6\u4e00\u79cd\u7528\u6cd5\u53c2\u89c1 n5.2 n4.18 $n \\equiv k \\pmod m$ $n$ \u6a21 $m$ \u4e0e $k$ \u540c\u4f59 \u5bf9\u6574\u6570 $n$ \uff0c $k$ \uff0c $m$ : $m \\mid (n - k)$ ; \u4e0d\u8981\u4e0e n4.1 \u4e2d\u63d0\u5230\u7684\u76f8\u6df7\u6dc6\u3002 \u521d\u7b49\u51e0\u4f55\u5b66 \u00b6 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n5.1 $\\parallel$ \u5e73\u884c n5.2 $\\perp$ \u5782\u76f4 \u8be5\u7b26\u53f7\u7684\u53e6\u4e00\u79cd\u7528\u6cd5\u53c2\u89c1 n4.17 n5.3 $\\angle$ \uff08\u5e73\u9762\uff09\u89d2 n5.4 $\\overline{\\mathrm{AB}}$ \u7ebf\u6bb5 $\\mathrm{AB}$ n5.5 $\\overrightarrow{\\mathrm{AB}}$ \u6709\u5411\u7ebf\u6bb5 $\\mathrm{AB}$ n5.6 $d(\\mathrm{A}, \\mathrm{B})$ \u70b9 $\\mathrm{A}$ \u548c $\\mathrm{B}$ \u4e4b\u95f4\u7684\u8ddd\u79bb \u5373 $\\overline{\\mathrm{AB}}$ \u7684\u957f\u5ea6\u3002 \u8fd0\u7b97\u7b26 \u00b6 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n6.1 $a + b$ $a$ \u52a0 $b$ n6.2 $a - b$ $a$ \u51cf $b$ n6.3 $a \\pm b$ $a$ \u52a0\u6216\u51cf $b$ n6.4 $a \\mp b$ $a$ \u51cf\u6216\u52a0 $b$ $-(a \\pm b) = -a \\mp b$ . n6.5 $a \\cdot b$ ; $a \\times b$ ; $ab$ $a$ \u4e58 $b$ \u82e5\u51fa\u73b0\u5c0f\u6570\u70b9\uff0c\u5219\u5e94\u53ea\u4f7f\u7528 $\\times$ ; \u90e8\u5206\u7528\u4f8b\u53c2\u89c1 n2.16, n2.17, n14.11, n14.12 n6.6 $\\dfrac{a}{b}$ ; $a/b$ ; $a:b$ $a$ \u9664\u4ee5 $b$ $\\dfrac{a}{b}=a\\cdot b^{-1}$ ; \u53ef\u7528 $:$ \u8868\u793a\u540c\u4e00\u91cf\u7eb2\u7684\u6570\u503c\u7684\u6bd4\u7387\u3002 \u4e0d\u5e94\u4f7f\u7528 $\u00f7$ . n6.7 $\\displaystyle \\sum\\limits_{i=1}^n a_i$ $a_1 + a_2 + \\dots + a_n$ \u4e5f\u53ef\u4f7f\u7528 $\\displaystyle \\sum\\nolimits_{i=1}^n a_i$ \uff0c $\\displaystyle \\sum\\limits_i a_i$ \uff0c $\\displaystyle \\sum\\nolimits_i a_i$ \uff0c $\\displaystyle \\sum a_i$ . n6.8 $\\displaystyle \\prod\\limits_{i=1}^n a_i$ $a_1 \\cdot a_2 \\cdot \\dots \\cdot a_n$ \u4e5f\u53ef\u4f7f\u7528 $\\displaystyle \\prod\\nolimits_{i=1}^n a_i$ \uff0c $\\displaystyle \\prod\\limits_i a_i$ \uff0c $\\displaystyle \\prod\\nolimits_i a_i$ \uff0c $\\displaystyle \\prod a_i$ . n6.9 $a^p$ $a$ \u7684 $p$ \u6b21\u5e42 n6.10 $a^{1/2}$ ; $\\sqrt{a}$ $a$ \u7684 $1/2$ \u6b21\u65b9\uff0c $a$ \u7684\u5e73\u65b9\u6839 \u5e94\u907f\u514d\u4f7f\u7528 $\\sqrt{}a$ . n6.11 $a^{1/n}$ ; $\\sqrt[n]{a}$ $a$ \u7684 $1/n$ \u6b21\u5e42\uff0c $a$ \u7684 $n$ \u6b21\u6839 \u5e94\u907f\u514d\u4f7f\u7528 $\\sqrt[n]{}a$ . n6.12 $\\bar{x}$ ; $\\bar{x}_a$ $x$ \u7684\u7b97\u6570\u5747\u503c \u5176\u4ed6\u5747\u503c\u6709\uff1a \u8c03\u548c\u5747\u503c $\\bar{x}_h$ ; \u51e0\u4f55\u5747\u503c $\\bar{x}_g$ ; \u4e8c\u6b21\u5747\u503c/\u5747\u65b9\u6839 $\\bar{x}_q$ \u6216 $\\bar{x}_{rms}$ . $\\bar{x}$ \u4e5f\u7528\u4e8e\u8868\u793a\u590d\u6570 $x$ \u7684\u5171\u8f6d\uff0c\u53c2\u89c1 n11.6. n6.13 $\\operatorname{sgn} a$ $a$ \u7684\u7b26\u53f7\u51fd\u6570 \u5bf9\u5b9e\u6570 $a$ : $\\operatorname{sgn} a=1\\quad (a>0)$ ; $\\operatorname{sgn} a=-1\\quad (a<0)$ ; $\\operatorname{sgn} 0=0$ ; \u53c2\u89c1 n11.7. n6.14 $\\inf M$ $M$ \u7684\u4e0b\u786e\u754c \u5c0f\u4e8e\u7b49\u4e8e\u975e\u7a7a\u96c6\u5408 $M$ \u4e2d\u5143\u7d20\u7684\u6700\u5927\u4e0a\u754c\u3002 n6.15 $\\sup M$ $M$ \u7684\u4e0a\u786e\u754c \u5927\u4e8e\u7b49\u4e8e\u975e\u7a7a\u96c6\u5408 $M$ \u4e2d\u5143\u7d20\u7684\u6700\u5c0f\u4e0b\u754c\u3002 n6.16 $\\lvert a\\rvert$ $a$ \u7684\u7edd\u5bf9\u503c \u4e5f\u53ef\u4f7f\u7528 $\\operatorname{abs} a$ . n6.17 $\\lfloor a\\rfloor$ \u5411\u4e0b\u53d6\u6574 \u5c0f\u4e8e\u7b49\u4e8e\u5b9e\u6570 $a$ \u7684\u6700\u5927\u6574\u6570 \u4f8b\u5982\uff1a $\\lfloor 2.4\\rfloor = 2$ ; $\\lfloor -2.4\\rfloor = -3$ . n6.18 $\\lceil a\\rceil$ \u5411\u4e0a\u53d6\u6574 \u5927\u4e8e\u7b49\u4e8e\u5b9e\u6570 $a$ \u7684\u6700\u5c0f\u6574\u6570 \u4f8b\u5982\uff1a $\\lceil 2.4\\rceil = 3$ ; $\\lceil -2.4\\rceil = -2$ . n6.19 $\\min(a, b)$ ; $\\min\\{a, b\\}$ $a$ \u548c $b$ \u7684\u6700\u5c0f\u503c \u53ef\u63a8\u5e7f\u5230\u6709\u9650\u96c6\u4e2d\u3002 \u8981\u8868\u793a\u65e0\u9650\u96c6\u4e2d\u7684\u6700\u5c0f\u503c\u5efa\u8bae\u4f7f\u7528 $\\inf$ , \u53c2\u89c1 n6.14 n6.20 $\\max(a, b)$ ; $\\max\\{a, b\\}$ $a$ \u548c $b$ \u7684\u6700\u5927\u503c \u53ef\u63a8\u5e7f\u5230\u6709\u9650\u96c6\u4e2d\u3002 \u8981\u8868\u793a\u65e0\u9650\u96c6\u4e2d\u7684\u6700\u5927\u503c\u5efa\u8bae\u4f7f\u7528 $\\sup$ , \u53c2\u89c1 n6.15 n6.21 $n \\bmod m$ $n$ \u6a21 $m$ \u7684\u4f59\u6570 \u5bf9\u6b63\u6574\u6570 $n$ \uff0c $m$ : $(\\exists~q\\in\\mathbf{N}, r\\in[0, m))~~n=qm+r$ ; \u5176\u4e2d $r=n \\bmod m$ . n6.22 $\\gcd(a, b)$ ; $\\gcd\\{a, b\\}$ \u6574\u6570 $a$ \u548c $b$ \u7684\u6700\u5927\u516c\u56e0\u6570 \u53ef\u63a8\u5e7f\u5230\u6709\u9650\u96c6\u4e2d\u3002\u4e0d\u5f15\u8d77\u6b67\u4e49\u7684\u60c5\u51b5\u4e0b\u53ef\u5199\u4e3a $(a, b)$ . n6.23 $\\operatorname{lcm}(a, b)$ ; $\\operatorname{lcm}\\{a, b\\}$ \u6574\u6570 $a$ \u548c $b$ \u7684\u6700\u5c0f\u516c\u500d\u6570 \u53ef\u63a8\u5e7f\u5230\u6709\u9650\u96c6\u4e2d\u3002\u4e0d\u5f15\u8d77\u6b67\u4e49\u7684\u60c5\u51b5\u4e0b\u53ef\u5199\u4e3a $[a, b]$ ; $(a, b)[a, b]=\\lvert ab\\rvert$ . \u7ec4\u5408\u6570\u5b66 \u00b6 \u672c\u8282\u4e2d\u7684 $n$ \u548c $k$ \u662f\u81ea\u7136\u6570\uff0c $a$ \u662f\u590d\u6570\uff0c\u4e14 $k\\leq n$ . \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n7.1 $n!$ \u9636\u4e58 $n!=\\prod_{k=1}^n k=1\\cdot 2\\cdot 3\\cdot \\dots \\cdot n\\quad (n>0)$ ; $0!=1$ . n7.2 $a^{\\underline{k}}$ \u4e0b\u964d\u9636\u4e58\u5e42 $a^{\\underline{k}}=a\\cdot(a-1)\\cdot \\dots \\cdot(a-k+1)\\quad (k>0)$ ; $a^{\\underline{0}}=1$ ; $n^{\\underline{k}}=\\dfrac{n!}{(n-k)!}$ . n7.3 $a^{\\overline{k}}$ \u4e0a\u5347\u9636\u4e58\u5e42 $a^{\\overline{k}}=a\\cdot(a+1)\\cdot \\dots \\cdot(a+k-1)\\quad (k>0)$ ; $a^{\\overline{0}}=1$ ; $n^{\\overline{k}}=\\dfrac{(n+k-1)!}{(n-1)!}$ . n7.4 $\\dbinom{n}{k}$ \u7ec4\u5408\u6570 $\\dbinom{n}{k}=\\dfrac{n!}{k!(n-k)!}$ . n7.5 $\\displaystyle{n\\brack k}$ \u7b2c\u4e00\u7c7b Stirling \u6570 $\\displaystyle{n+1\\brack k}=n{n\\brack k}+{n\\brack k-1}$ ; $\\displaystyle x^{\\overline{n}}=\\sum_{k=0}^n{n\\brack k}x^k$ . n7.6 $\\displaystyle{n\\brace k}$ \u7b2c\u4e8c\u7c7b Stirling \u6570 $\\displaystyle{n\\brace k}=\\frac{1}{k!}\\sum_{i=0}^k(-1)^i\\binom{k}{i}(k-i)^n$ ; $\\displaystyle\\sum_{k=0}^n{n\\brace k}x^{\\underline{k}}=x^n$ . \u51fd\u6570 \u00b6 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n8.1 $f$ \u51fd\u6570 n8.2 $f(x)$ \uff0c $f(x_1, \\dots, x_n)$ \u51fd\u6570 $f$ \u5728 $x$ \u5904\u7684\u503c \u51fd\u6570 $f$ \u5728 $(x_1, \\dots, x_n)$ \u5904\u7684\u503c n8.3 $\\operatorname{dom} f$ $f$ \u7684\u5b9a\u4e49\u57df \u4e5f\u53ef\u4f7f\u7528 $\\mathrm{D}(f)$ . n8.4 $\\operatorname{ran} f$ $f$ \u7684\u503c\u57df \u4e5f\u53ef\u4f7f\u7528 $\\mathrm{R}(f)$ . n8.5 $f:A\\to B$ $f$ \u662f $A$ \u5230 $B$ \u7684\u6620\u5c04 $\\operatorname{dom} f=A$ \u4e14 $(\\forall~x \\in\\operatorname{dom} f)~~ f(x) \\in B$ . n8.6 $x\\mapsto T(x), x\\in A$ \u5c06\u6240\u6709 $x\\in A$ \u6620\u5c04\u5230 $T(x)$ \u7684\u51fd\u6570 $T(x)$ \u4ec5\u7528\u4e8e\u5b9a\u4e49\uff0c\u7528\u6765\u8868\u793a\u67d0\u4e2a\u53c2\u6570\u4e3a $x\\in A$ \u7684\u67d0\u4e2a\u51fd\u6570\u503c\u3002\u82e5\u8fd9\u4e2a\u51fd\u6570\u4e3a $f$ , \u5219\u5bf9\u6240\u6709 $x\\in A$ \u5747\u6709 $f(x)=T(x)$ . \u56e0\u6b64 $T(x)$ \u901a\u5e38\u7528\u6765\u5b9a\u4e49\u51fd\u6570 $f$ . \u4f8b\u5982\uff1a $x\\mapsto 3x^2y, x\\in[0, 2]$ ; \u8fd9\u662f\u7531 $3x^2y$ \u5b9a\u4e49\u7684\u4e00\u4e2a\u5173\u4e8e $x$ \u7684\u4e8c\u6b21\u51fd\u6570\u3002\u82e5\u672a\u5f15\u5165\u51fd\u6570\u7b26\u53f7\uff0c\u5219\u7528 $3x^2y$ \u8868\u793a\u8be5\u51fd\u6570 n8.7 $f^{-1}$ $f$ \u7684\u53cd\u51fd\u6570 \u51fd\u6570 $f$ \u7684\u53cd\u51fd\u6570 $f^{-1}$ \u6709\u5b9a\u4e49\u5f53\u4e14\u4ec5\u5f53 $f$ \u662f\u5355\u5c04\u3002 \u82e5 $f$ \u662f\u5355\u5c04\uff0c\u5219 $\\operatorname{dom}\\left(f^{-1}\\right) = \\operatorname{ran} f$ \uff0c $\\operatorname{ran}\\left(f^{-1}\\right) = \\operatorname{dom} f$ , \u4e14 $(\\forall~x\\in\\operatorname{dom} f)~~f^{-1}(f(x)) = x$ . \u4e0d\u8981\u4e0e\u51fd\u6570\u7684\u5012\u6570 $f(x)^{-1}$ \u6df7\u6dc6\u3002 n8.8 $g\\circ f$ $f$ \u548c $g$ \u7684\u590d\u5408\u51fd\u6570 $(g\\circ f)(x)=g(f(x))$ . n8.9 $f:x\\mapsto y$ $f(x)=y$ \uff0c $f$ \u5c06 $x$ \u6620\u5c04\u5230 $y$ n8.10 $f\\vert_a^b$ ; $f(\\dots, u, \\dots)\\vert_{u=a}^{u=b}$ $f(b)-f(a)$ ; $f(\\dots, b, \\dots)-f(\\dots, a, \\dots)$ \u4e3b\u8981\u7528\u4e8e\u5b9a\u79ef\u5206\u7684\u8ba1\u7b97\u4e2d\u3002 n8.11 $\\displaystyle \\lim\\limits_{x\\to a}f(x)$ ; $\\lim\\nolimits_{x\\to a}f(x)$ \u5f53 $x$ \u8d8b\u8fd1\u4e8e $a$ \u65f6 $f(x)$ \u7684\u6781\u9650 $\\lim\\nolimits_{x\\to a}f(x)=b$ \u53ef\u4ee5\u5199\u6210 $f(x)\\to b\\quad (x \\to a)$ . \u53f3\u6781\u9650\u548c\u5de6\u6781\u9650\u7684\u7b26\u53f7\u5206\u522b\u4e3a $\\lim\\nolimits_{x\\to a+}f(x)$ \u548c $\\lim\\nolimits_{x\\to a-}f(x)$ . n8.12 $f(x) = O(g(x))$ $\\lvert f(x)/g(x)\\rvert$ \u5728\u4e0a\u4e0b\u6587\u9690\u542b\u7684\u9650\u5236\u4e2d\u6709\u4e0a\u754c\uff0c $f(x)$ \u7684\u9636\u4e0d\u9ad8\u4e8e $g(x)$ \u5f53 $f/g$ \u4e0e $g/f$ \u5747\u6709\u754c\u65f6\u79f0 $f$ \u4e0e $g$ \u662f\u540c\u9636\u7684\u3002 \u4f7f\u7528\u7b26\u53f7 \" $=$ \" \u662f\u51fa\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u5176\u5728\u6b64\u5904\u4e0d\u8868\u793a\u7b49\u4ef7\uff0c\u56e0\u4e3a\u4e0d\u6ee1\u8db3\u4f20\u9012\u6027\u3002 \u4f8b\u5982\uff1a $\\sin x=O(x)\\quad (x\\to 0)$ . n8.13 $f(x) = o(g(x))$ \u5728\u4e0a\u4e0b\u6587\u9690\u542b\u7684\u9650\u5236\u4e2d\u6709 $f(x)/g(x)\\to 0$ \uff0c $f(x)$ \u7684\u9636\u9ad8\u4e8e $g(x)$ \u4f7f\u7528\u7b26\u53f7 \" $=$ \" \u662f\u51fa\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u5176\u5728\u6b64\u5904\u4e0d\u8868\u793a\u7b49\u4ef7\uff0c\u56e0\u4e3a\u4e0d\u6ee1\u8db3\u4f20\u9012\u6027\u3002 \u4f8b\u5982\uff1a $\\cos x=1+o(x)\\quad (x\\to 0)$ . n8.14 $\\Delta f$ $f$ \u7684\u6709\u9650\u589e\u91cf \u4e0a\u4e0b\u6587\u9690\u542b\u7684\u4e24\u51fd\u6570\u503c\u7684\u5dee\u5206\u3002\u4f8b\u5982\uff1a $\\Delta x=x_2-x_1$ ; $\\Delta f(x)=f(x_2)-f(x_1)$ . n8.15 $\\dfrac{\\mathrm{d}f}{\\mathrm{d}x}$ ; $f'$ $f$ \u5bf9 $x$ \u7684\u5bfc\uff08\u51fd\uff09\u6570 \u4ec5\u7528\u4e8e\u4e00\u5143\u51fd\u6570\u3002 \u53ef\u4ee5\u663e\u5f0f\u6307\u660e\u81ea\u53d8\u91cf\uff0c\u5982 $\\dfrac{\\mathrm{d}f(x)}{\\mathrm{d}x}$ \uff0c $f'(x)$ . n8.16 $\\left(\\dfrac{\\mathrm{d}f}{\\mathrm{d}x}\\right)_{x=a}$ ; $f'(a)$ $f$ \u5728 $a$ \u5904\u7684\u5bfc\uff08\u51fd\uff09\u6570\u503c \u53c2\u89c1 n8.15 n8.17 $\\dfrac{\\mathrm{d}^n f}{\\mathrm{d}x^n}$ ; $f^{(n)}$ $f$ \u5bf9 $x$ \u7684 $n$ \u9636\u5bfc\uff08\u51fd\uff09\u6570 \u4ec5\u7528\u4e8e\u4e00\u5143\u51fd\u6570\u3002 \u53ef\u4ee5\u663e\u5f0f\u6307\u660e\u81ea\u53d8\u91cf\uff0c\u5982 $\\dfrac{\\mathrm{d}^n f(x)}{\\mathrm{d}x^n}$ \uff0c $f^{(n)}(x)$ . \u53ef\u7528 $f''$ \u548c $f'''$ \u5206\u522b\u8868\u793a $f^{(2)}$ \u548c $f^{(3)}$ . n8.18 $\\dfrac{\\partial f}{\\partial x}$ ; $f_x$ $f$ \u5bf9 $x$ \u7684\u504f\u5bfc\u6570 \u4ec5\u7528\u4e8e\u591a\u5143\u51fd\u6570\u3002 \u53ef\u4ee5\u663e\u5f0f\u6307\u660e\u81ea\u53d8\u91cf\uff0c\u5982 $\\dfrac{\\partial f(x, y, \\dots)}{\\partial x}$ \uff0c $f_x(x, y, \\dots)$ . \u53ef\u4ee5\u6269\u5c55\u5230\u9ad8\u9636\uff0c\u5982 $f_{xx}=\\dfrac{\\partial^2 f}{\\partial x^2}=\\dfrac{\\partial}{\\partial x}\\left(\\dfrac{\\partial f}{\\partial x}\\right)$ ; $f_{xy}=\\dfrac{\\partial^2 f}{\\partial y\\partial x}=\\dfrac{\\partial}{\\partial y}\\left(\\dfrac{\\partial f}{\\partial x}\\right)$ . n8.19 $\\dfrac{\\partial(f_1, \\dots, f_m)}{\\partial(x_1, \\dots, x_n)}$ Jacobi \u77e9\u9635 \u53c2\u89c1 [^n8.19-ref1] n8.20 $\\mathrm{d}f$ $f$ \u7684\u5168\u5fae\u5206 $\\mathrm{d}f(x, y, \\dots)=\\dfrac{\\partial f}{\\partial x}\\mathrm{d}x+\\dfrac{\\partial f}{\\partial y}\\mathrm{d}y+\\dots$ . n8.21 $\\delta f$ $f$ \u7684\uff08\u65e0\u7a77\u5c0f\uff09\u53d8\u5206 n8.22 $\\displaystyle \\int f(x)\\mathrm{d}x$ $f$ \u7684\u4e0d\u5b9a\u79ef\u5206 n8.23 $\\displaystyle \\int\\limits_a^b f(x)\\mathrm{d}x$ $f$ \u4ece $a$ \u5230 $b$ \u7684\u5b9a\u79ef\u5206 \u4e5f\u53ef\u4f7f\u7528 $\\displaystyle \\int\\nolimits_a^b f(x)\\mathrm{d}x$ ; \u5b9a\u79ef\u5206\u8fd8\u53ef\u4ee5\u5b9a\u4e49\u5728\u66f4\u4e00\u822c\u7684\u57df\u4e0a\u3002\u5982 $\\displaystyle\\int\\limits_C$ \uff0c $\\displaystyle\\int\\limits_S$ \uff0c $\\displaystyle\\int\\limits_V$ \uff0c $\\displaystyle\\oint$ , \u5206\u522b\u8868\u793a\u5728\u66f2\u7ebf $C$ , \u66f2\u9762 $S$ , \u4e09\u7ef4\u533a\u57df $V$ , \u548c\u95ed\u66f2\u7ebf\u6216\u66f2\u9762\u4e0a\u7684\u5b9a\u79ef\u5206\u3002 \u591a\u91cd\u79ef\u5206\u53ef\u5199\u6210 $\\displaystyle\\iint$ \uff0c $\\displaystyle\\iiint$ \u7b49\u3002 n8.24 $f*g$ \u51fd\u6570 $f$ \u548c $g$ \u7684\u5377\u79ef $\\displaystyle (f*g)(x)=\\int\\limits_{-\\infty}^{\\infty}f(y)g(x-y)\\mathrm{d}y$ . [^n8.19-ref1]: $\\dfrac{\\partial(f_1, \\dots, f_m)}{\\partial(x_1, \\dots, x_n)}=\\begin{pmatrix}\\dfrac{\\partial f_1}{\\partial x_1}&\\cdots&\\dfrac{\\partial f_1}{\\partial x_n}\\\\\\vdots&\\ddots&\\vdots\\\\\\dfrac{\\partial f_m}{\\partial x_1}&\\cdots&\\dfrac{\\partial f_m}{\\partial x_n}\\end{pmatrix}$ ; \u77e9\u9635\u7684\u5b9a\u4e49\u53c2\u89c1 n12.1 \u6307\u6570\u548c\u5bf9\u6570\u51fd\u6570 \u00b6 $x$ \u53ef\u4ee5\u662f\u590d\u6570\u3002 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n9.1 $\\mathrm{e}$ \u81ea\u7136\u5bf9\u6570\u7684\u5e95 $\\displaystyle \\mathrm{e}=\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{n}\\right)^n=2.718~281~8\\dots$ ; \u4e0d\u8981\u5199\u6210 $e$ . n9.2 $a^x$ $x$ \u7684\u6307\u6570\u51fd\u6570\uff08\u4ee5 $a$ \u4e3a\u5e95\uff09 \u53c2\u89c1 n6.9. n9.3 $\\mathrm{e}^x$ ; $\\exp x$ $x$ \u7684\u6307\u6570\u51fd\u6570\uff08\u4ee5 $\\mathrm{e}$ \u4e3a\u5e95\uff09 n9.4 $\\log_a x$ $x$ \u7684\u4ee5 $a$ \u4e3a\u5e95\u7684\u5bf9\u6570 \u5f53\u5e95\u6570\u4e0d\u9700\u8981\u6307\u5b9a\u7684\u65f6\u5019\u53ef\u4ee5\u4f7f\u7528 $\\log x$ . \u4e0d\u5e94\u7528 $\\log x$ \u66ff\u6362 $\\ln x$ \uff0c $\\lg x$ \uff0c $\\operatorname{lb} x$ \u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u3002 n9.5 $\\ln x$ $x$ \u7684\u81ea\u7136\u5bf9\u6570 $\\ln x = \\log_{\\mathrm{e}} x$ ; \u53c2\u89c1 n9.4. n9.6 $\\lg x$ $x$ \u7684\u5e38\u7528\u5bf9\u6570 $\\lg x = \\log_{10} x$ ; \u53c2\u89c1 n9.4. n9.7 $\\operatorname{lb} x$ $x$ \u7684\u4ee5 $2$ \u4e3a\u5e95\u7684\u5bf9\u6570 $\\operatorname{lb} x = \\log_2 x$ ; \u53c2\u89c1 n9.4. \u4e09\u89d2\u51fd\u6570\u548c\u53cc\u66f2\u51fd\u6570 \u00b6 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n10.1 $\\pi$ \u5706\u5468\u7387 $\\pi = 3.141~592~6\\dots$ . n10.2 $\\sin x$ $x$ \u7684\u6b63\u5f26 $\\sin x=\\dfrac{\\mathrm{e}^{\\mathrm{i}x}-\\mathrm{e}^{-\\mathrm{i}x}}{2\\mathrm{i}}$ ; $(\\sin x)^n$ \uff0c $(\\cos x)^n$ ( $n\\geq 2$ ) \u7b49\u901a\u5e38\u5199\u4e3a $\\sin^n x$ \uff0c $\\cos^n x$ \u7b49\u3002 n10.3 $\\cos x$ $x$ \u7684\u4f59\u5f26 $\\cos x = \\sin(x + \\pi/2)$ . n10.4 $\\tan x$ $x$ \u7684\u6b63\u5207 $\\tan x = \\sin x/\\cos x$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{tg} x$ . n10.5 $\\cot x$ $x$ \u7684\u4f59\u5207 $\\cot x = 1/\\tan x$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{ctg} x$ . n10.6 $\\sec x$ $x$ \u7684\u6b63\u5272 $\\sec x = 1/\\cos x$ . n10.7 $\\csc x$ $x$ \u7684\u4f59\u5272 $\\csc x = 1/\\sin x$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{cosec} x$ . n10.8 $\\arcsin x$ $x$ \u7684\u53cd\u6b63\u5f26 $y = \\arcsin x \\iff x = \\sin y\\quad (-\\pi/2 \\leq y \\leq \\pi/2)$ . n10.9 $\\arccos x$ $x$ \u7684\u53cd\u4f59\u5f26 $y = \\arccos x \\iff x = \\cos y\\quad (0 \\leq y \\leq \\pi)$ . n10.10 $\\arctan x$ $x$ \u53cd\u6b63\u5207 $y = \\arctan x \\iff x = \\tan y\\quad (-\\pi/2 \\leq y \\leq \\pi/2)$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arctg} x$ . n10.11 $\\operatorname{arccot} x$ $x$ \u53cd\u4f59\u5207 $y = \\operatorname{arccot} x \\iff x = \\cot y\\quad (0 \\leq y \\leq \\pi)$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arcctg} x$ . n10.12 $\\operatorname{arcsec} x$ $x$ \u53cd\u6b63\u5272 $y = \\operatorname{arcsec} x \\iff x = \\sec y\\quad (0\\leq y \\leq \\pi, y\\ne \\pi/2)$ . n10.13 $\\operatorname{arccsc} x$ $x$ \u7684\u53cd\u4f59\u5272 $y = \\operatorname{arccsc} x \\iff x = \\csc y\\quad (-\\pi/2 \\leq y \\leq \\pi/2, y\\ne 0)$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arccosec} x$ . n10.14 $\\sinh x$ $x$ \u7684\u53cc\u66f2\u6b63\u5f26 $\\sinh x=\\dfrac{\\mathrm{e}^x-\\mathrm{e}^{-x}}{2}$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{sh} x$ . n10.15 $\\cosh x$ $x$ \u7684\u53cc\u66f2\u4f59\u5f26 $\\cosh^2 x = \\sinh^2 x + 1$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{ch} x$ . n10.16 $\\tanh x$ $x$ \u7684\u53cc\u66f2\u6b63\u5207 $\\tanh x = \\sinh x/\\cosh x$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{th} x$ . n10.17 $\\coth x$ $x$ \u7684\u53cc\u66f2\u4f59\u5207 $\\coth x = 1/\\tanh x$ . n10.18 $\\operatorname{sech} x$ $x$ \u7684\u53cc\u66f2\u6b63\u5272 $\\operatorname{sech} x = 1/\\cosh x$ . n10.19 $\\operatorname{csch} x$ $x$ \u7684\u53cc\u66f2\u4f59\u5272 $\\operatorname{csch} x = 1/\\sinh x$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{cosech} x$ . n10.20 $\\operatorname{arsinh} x$ $x$ \u7684\u53cd\u53cc\u66f2\u6b63\u5f26 $y = \\operatorname{arsinh} x \\iff x = \\sinh y$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arsh} x$ . n10.21 $\\operatorname{arcosh} x$ $x$ \u7684\u53cd\u53cc\u66f2\u4f59\u5f26 $y = \\operatorname{arcosh} x \\iff x = \\cosh y\\quad (y \\geq 0)$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arch} x$ . n10.22 $\\operatorname{artanh} x$ $x$ \u7684\u53cd\u53cc\u66f2\u6b63\u5207 $y = \\operatorname{artanh} x \\iff x = \\tanh y$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arth} x$ . n10.23 $\\operatorname{arcoth} x$ $x$ \u7684\u53cd\u53cc\u66f2\u4f59\u5207 $y = \\operatorname{arcoth} x \\iff x = \\coth y\\quad (y \\ne 0)$ . n10.24 $\\operatorname{arsech} x$ $x$ \u7684\u53cd\u53cc\u66f2\u6b63\u5272 $y = \\operatorname{arsech} x \\iff x = \\operatorname{sech} y\\quad (y \\geq 0)$ . n10.25 $\\operatorname{arcsch} x$ $x$ \u7684\u53cd\u53cc\u66f2\u4f59\u5272 $y = \\operatorname{arcsch} x \\iff x = \\operatorname{csch} y\\quad (y \\geq 0)$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arcosech} x$ . \u590d\u6570 \u00b6 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n11.1 $\\mathrm{i}$ \u865a\u6570\u5355\u4f4d $\\mathrm{i}^2 = -1$ ; \u4e0d\u53ef\u4f7f\u7528 $i$ \u6216 i n11.2 $\\operatorname{Re} z$ $z$ \u7684\u5b9e\u90e8 \u53c2\u89c1 n11.3. n11.3 $\\operatorname{Im} z$ $z$ \u7684\u865a\u90e8 \u82e5 $z = x + \\mathrm{i} y\\quad (x, y\\in\\mathbf{R})$ , \u5219 $x = \\operatorname{Re} z$ \uff0c $y = \\operatorname{Im} z$ . n11.4 $\\lvert z\\rvert$ $z$ \u7684\u6a21 $\\lvert z\\rvert=\\sqrt{(\\operatorname{Re} z)^2+(\\operatorname{Im} z)^2}$ . n11.5 $\\arg z$ $z$ \u7684\u8f90\u89d2 \u82e5 $z = r \\mathrm{e}^{\\mathrm{i}\\varphi}$ , \u5176\u4e2d $r = \\lvert z\\rvert$ \u4e14 $-\\pi < \\varphi \\leq \\pi$ , \u5219 $\\varphi = \\arg z$ . $\\operatorname{Re} z = r \\cos \\varphi$ \uff0c $\\operatorname{Im} z = r \\sin \\varphi$ . n11.6 $\\bar{z}$ ; $z^*$ $z$ \u7684\u590d\u5171\u8f6d $\\bar{z}=\\operatorname{Re}z-\\mathrm{i}\\operatorname{Im}z$ . n11.7 $\\operatorname{sgn} z$ $z$ \u7684\u5355\u4f4d\u6a21\u51fd\u6570 $\\operatorname{sgn} z =z / \\lvert z\\rvert = \\exp(\\mathrm{i} \\arg z)\\quad (z \\ne 0)$ ; $\\operatorname{sgn} 0 = 0$ ; \u53c2\u89c1 n6.13. \u77e9\u9635 \u00b6 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n12.1 $A$ ; \u53c2\u89c1 ^n12.1-ref1 $m\\times n$ \u578b\u77e9\u9635 $A$ $a_{ij} = (A)_{ij}$ ; \u4e5f\u53ef\u4f7f\u7528 $A = (a_{ij})$ . \u5176\u4e2d $m$ \u4e3a\u884c\u6570\uff0c $n$ \u4e3a\u5217\u6570 $m=n$ \u65f6\u79f0\u4e3a\u65b9\u9635 \u53ef\u7528\u65b9\u62ec\u53f7\u66ff\u4ee3\u5706\u62ec\u53f7\u3002 n12.2 $A + B$ \u77e9\u9635 $A$ \u548c $B$ \u7684\u548c $(A + B)_{ij} = (A)_{ij} + (B)_{ij}$ ; \u77e9\u9635 $A$ \u548c $B$ \u7684\u884c\u6570\u548c\u5217\u6570\u5fc5\u987b\u5206\u522b\u76f8\u540c\u3002 n12.3 $x A$ \u6807\u91cf $x$ \u548c\u77e9\u9635 $A$ \u7684\u4e58\u79ef $(x A)_{ij} = x (A)_{ij}$ . n12.4 $AB$ \u77e9\u9635 $A$ \u548c $B$ \u7684\u4e58\u79ef $\\displaystyle(AB)_{ik} = \\sum\\limits_{j}(A)_{ij}(B)_{jk}$ ; \u77e9\u9635 $A$ \u7684\u5217\u6570\u5fc5\u987b\u7b49\u4e8e\u77e9\u9635 $B$ \u7684\u884c\u6570\u3002 n12.5 $I$ ; $E$ \u5355\u4f4d\u77e9\u9635 $(I)_{ik} = \\delta_{ik}$ ; $\\delta_{ik}$ \u7684\u5b9a\u4e49\u53c2\u89c1 n14.9. n12.6 $A^{-1}$ \u65b9\u9635 $A$ \u7684\u9006 $AA^{-1} = A^{-1}A = I\\quad (\\det A \\ne 0)$ . $\\det A$ \u7684\u5b9a\u4e49\u53c2\u89c1 n12.10. n12.7 $A^{\\mathrm{T}}$ ; $A'$ $A$ \u7684\u8f6c\u7f6e\u77e9\u9635 $(A^{\\mathrm{T}})_{ik} = (A)_{ki}$ . n12.8 $\\overline{A}$ ; $A^*$ $A$ \u7684\u590d\u5171\u8f6d\u77e9\u9635 $\\left(\\overline{A}\\right)_{ik}=\\overline{(A)_{ik}}$ . n12.9 $A^{\\mathrm{H}}$ ; $A^{\\dagger}$ $A$ \u7684 Hermite \u5171\u8f6d\u77e9\u9635 $A^{\\mathrm{H}} = \\left(\\overline{A}\\right)^{\\mathrm{T}}$ . n12.10 $\\det A$ ; \u53c2\u89c1 [^n12.10-ref1] \u65b9\u9635 $A$ \u7684\u884c\u5217\u5f0f \u4e5f\u53ef\u4f7f\u7528 $\\lvert A\\rvert$ . n12.11 $\\operatorname{rank}A$ \u77e9\u9635 $A$ \u7684\u79e9 n12.12 $\\operatorname{tr}A$ \u65b9\u9635 $A$ \u7684\u8ff9 $\\displaystyle\\operatorname{tr}A=\\sum\\limits_{i}(A)_{ii}$ . n12.13 $\\lVert A\\rVert$ \u77e9\u9635 $A$ \u7684\u8303\u6570 \u6ee1\u8db3\u4e09\u89d2\u4e0d\u7b49\u5f0f\uff1a\u82e5 $A + B = C$ , \u5219 $\\lVert A\\rVert+\\lVert B\\rVert \\geq \\lVert C\\rVert$ . [^n12.10-ref1]: $\\begin{vmatrix}a_{11}&\\cdots&a_{1n}\\\\\\vdots& &\\vdots\\\\a_{n1}&\\cdots&a_{nn}\\end{vmatrix}$ \u5750\u6807\u7cfb \u00b6 \u672c\u8282\u8003\u8651\u4e09\u7ef4\u7a7a\u95f4\u4e2d\u7684\u4e00\u4e9b\u5750\u6807\u7cfb\u3002\u70b9 $\\mathrm{O}$ \u4e3a\u5750\u6807\u7cfb\u7684 \u539f\u70b9 \u3002\u4efb\u610f\u70b9 $\\mathrm{P}$ \u5747\u7531\u4ece\u539f\u70b9 $\\mathrm{O}$ \u5230\u70b9 $\\mathrm{P}$ \u7684 \u4f4d\u7f6e\u5411\u91cf \u786e\u5b9a\u3002 \u7f16\u53f7 \u5750\u6807 \u4f4d\u7f6e\u5411\u91cf\u548c\u5fae\u5206 \u5750\u6807\u540d \u5907\u6ce8 n13.1 $x$ \uff0c $y$ \uff0c $z$ $\\boldsymbol{r} = x \\boldsymbol{e}_x + y \\boldsymbol{e}_y + z \\boldsymbol{e}_z$ ; $\\mathrm{d}\\boldsymbol{r} = \\mathrm{d}x~\\boldsymbol{e}_x + \\mathrm{d}y~\\boldsymbol{e}_y + \\mathrm{d}z~\\boldsymbol{e}_z$ \u7b1b\u5361\u5c14\u5750\u6807 \u57fa\u5411\u91cf $\\boldsymbol{e}_x$ \uff0c $\\boldsymbol{e}_y$ \uff0c $\\boldsymbol{e}_z$ \u6784\u6210\u53f3\u624b\u6b63\u4ea4\u7cfb\uff0c\u89c1\u56fe 1 \u548c\u56fe 4\u3002 \u57fa\u5411\u91cf\u4e5f\u53ef\u7528 $\\boldsymbol{e}_1$ \uff0c $\\boldsymbol{e}_2$ \uff0c $\\boldsymbol{e}_3$ \u6216 $\\boldsymbol{i}$ \uff0c $\\boldsymbol{j}$ \uff0c $\\boldsymbol{k}$ \u8868\u793a\uff0c\u5750\u6807\u4e5f\u53ef\u7528 $x_1$ \uff0c $x_2$ \uff0c $x_3$ \u6216 $i$ \uff0c $j$ \uff0c $k$ \u8868\u793a\u3002 n13.2 $\\rho$ \uff0c $\\varphi$ \uff0c $z$ $\\boldsymbol{r} = \\rho~\\boldsymbol{e}_{\\rho} + z~\\boldsymbol{e}_z$ ; $\\mathrm{d}\\boldsymbol{r} = \\mathrm{d}\\rho~\\boldsymbol{e}_{\\rho} +\\rho~\\mathrm{d}\\varphi~\\boldsymbol{e}_{\\varphi} + \\mathrm{d}z~\\boldsymbol{e}_z$ \u67f1\u5750\u6807 $\\boldsymbol{e}_{\\rho}(\\varphi)$ \uff0c $\\boldsymbol{e}_{\\varphi}(\\varphi)$ \uff0c $\\boldsymbol{e}_z$ \u7ec4\u6210\u53f3\u624b\u6b63\u4ea4\u7cfb\uff0c\u89c1\u56fe 2\u3002 \u82e5 $z = 0$ , \u5219 $\\rho$ \u548c $\\varphi$ \u662f\u5e73\u9762\u4e0a\u7684\u6781\u5750\u6807\u3002 n13.3 $r$ \uff0c $\\vartheta$ \uff0c $\\varphi$ $\\boldsymbol{r} = r \\boldsymbol{e}_r$ ; $\\mathrm{d}\\boldsymbol{r} = \\mathrm{d}r~\\boldsymbol{e}_r + r~\\mathrm{d}\\vartheta~\\boldsymbol{e}_{\\vartheta} + r~\\sin\\vartheta~\\mathrm{\\mathrm{d}}\\varphi~\\boldsymbol{e}_{\\varphi}$ \u7403\u5750\u6807 $\\boldsymbol{e}_r(\\vartheta, \\varphi)$ \uff0c $\\boldsymbol{e}_{\\vartheta}(\\vartheta, \\varphi)$ \uff0c $\\boldsymbol{e}_{\\varphi}(\\varphi)$ \u7ec4\u6210\u53f3\u624b\u6b63\u4ea4\u7cfb\uff0c\u89c1\u56fe 3\u3002 \u5982\u679c\u4e0d\u4f7f\u7528\u53f3\u624b\u5750\u6807\u7cfb\uff08\u89c1\u56fe 4\uff09\uff0c\u800c\u4f7f\u7528\u5de6\u624b\u5750\u6807\u7cfb\uff08\u89c1\u56fe 5\uff09\uff0c\u5219\u5e94\u5728\u4e4b\u524d\u660e\u786e\u5f3a\u8c03\uff0c\u4ee5\u514d\u7b26\u53f7\u8bef\u7528\u3002 \u56fe 1 \u53f3\u624b\u7b1b\u5361\u5c14\u5750\u6807\u7cfb \u56fe 2 \u53f3\u624b\u67f1\u5750\u6807\u7cfb \u56fe 3 \u53f3\u624b\u7403\u5750\u6807\u7cfb \u56fe 4 \u53f3\u624b\u5750\u6807\u7cfb \u56fe 5 \u5de6\u624b\u5750\u6807\u7cfb \u6807\u91cf\u548c\u5411\u91cf \u00b6 \u672c\u8282\u4e2d\uff0c\u57fa\u5411\u91cf\u7528 $\\boldsymbol{e}_1$ \uff0c $\\boldsymbol{e}_2$ \uff0c $\\boldsymbol{e}_3$ \u8868\u793a\u3002\u672c\u8282\u4e2d\u7684\u8bb8\u591a\u6982\u5ff5\u90fd\u53ef\u4ee5\u63a8\u5e7f\u5230 $n$ \u7ef4\u7a7a\u95f4\u3002 \u6807\u91cf\u548c\u5411\u91cf\u672c\u8eab\u4e0e\u5750\u6807\u7cfb\u7684\u9009\u62e9\u65e0\u5173\uff0c\u800c\u5411\u91cf\u7684\u6bcf\u4e2a\u6807\u91cf\u5206\u91cf\u4e0e\u5750\u6807\u7cfb\u7684\u9009\u62e9\u6709\u5173\u3002 \u5bf9\u4e8e\u57fa\u5411\u91cf $\\boldsymbol{e}_1$ \uff0c $\\boldsymbol{e}_2$ \uff0c $\\boldsymbol{e}_3$ , \u6bcf\u4e2a\u5411\u91cf $\\boldsymbol{a}$ \u90fd\u53ef\u4ee5\u8868\u793a\u4e3a $\\boldsymbol{a}=a_1\\boldsymbol{e}_1+a_2\\boldsymbol{e}_2+a_3\\boldsymbol{e}_3$ , \u5176\u4e2d $a_1$ \uff0c $a_2$ \u548c $a_3$ \u662f\u552f\u4e00\u786e\u5b9a\u7684\u6807\u91cf\u503c\uff0c\u5c06\u5176\u79f0\u4e3a\u5411\u91cf\u76f8\u5bf9\u4e8e\u8be5\u7ec4\u57fa\u5411\u91cf\u7684 \"\u5750\u6807\"\uff0c $a_1\\boldsymbol{e}_1$ \uff0c $a_2\\boldsymbol{e}_2$ \u548c $a_3\\boldsymbol{e}_3$ \u79f0\u4e3a\u5411\u91cf\u76f8\u5bf9\u4e8e\u8be5\u7ec4\u57fa\u5411\u91cf\u7684\u5206\u5411\u91cf\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u53ea\u8003\u8651\u666e\u901a\u7a7a\u95f4\u7684\u7b1b\u5361\u5c14\uff08\u6b63\u4ea4\uff09\u5750\u6807\u3002\u7b1b\u5361\u5c14\u5750\u6807\u7528 $x$ \uff0c $y$ \uff0c $z$ \u6216 $a_1$ \uff0c $a_2$ \uff0c $a_3$ \u6216 $x_1$ \uff0c $x_2$ \uff0c $x_3$ \u8868\u793a\u3002 \u672c\u8282\u6240\u6709\u4e0b\u6807 $i$ \uff0c $j$ \uff0c $k$ \u7684\u8303\u56f4\u5747\u4e3a $1$ \u5230 $3$ . \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n14.1 $\\boldsymbol{a}$ ; $\\vec{a}$ \u5411\u91cf $\\boldsymbol{a}$ n14.2 $\\boldsymbol{a} + \\boldsymbol{b}$ \u5411\u91cf $\\boldsymbol{a}$ \u548c $\\boldsymbol{b}$ \u7684\u548c $(\\boldsymbol{a} + \\boldsymbol{b})_i = a_i + b_i$ . n14.3 $x\\boldsymbol{a}$ \u6807\u91cf $x$ \u4e0e\u5411\u91cf $\\boldsymbol{a}$ \u7684\u4e58\u79ef $(x\\boldsymbol{a})_i = xa_i$ . n14.4 $\\lvert \\boldsymbol{a}\\rvert$ \u5411\u91cf $\\boldsymbol{a}$ \u7684\u5927\u5c0f\uff0c\u5411\u91cf $\\boldsymbol{a}$ \u7684\u8303\u6570 $\\lvert \\boldsymbol{a}\\rvert=\\sqrt{a_x^2+a_y^2+a_z^2}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\lVert a\\rVert$ . n14.5 $\\boldsymbol{0}$ ; $\\vec{0}$ \u96f6\u5411\u91cf \u96f6\u5411\u91cf\u7684\u5927\u5c0f\u4e3a $0$ . n14.6 $\\boldsymbol{e_a}$ $\\boldsymbol{a}$ \u65b9\u5411\u7684\u5355\u4f4d\u5411\u91cf $\\boldsymbol{e_a} = \\boldsymbol{a}/\\lvert\\boldsymbol{a}\\rvert\\quad (\\boldsymbol{a}\\ne \\boldsymbol{0})$ . n14.7 $\\boldsymbol{e}_x$ \uff0c $\\boldsymbol{e}_y$ \uff0c $\\boldsymbol{e}_z$ ; $\\boldsymbol{e}_1$ \uff0c $\\boldsymbol{e}_2$ \uff0c $\\boldsymbol{e}_3$ \u7b1b\u5361\u5c14\u5750\u6807\u8f74\u65b9\u5411\u7684\u5355\u4f4d\u5411\u91cf \u4e5f\u53ef\u4f7f\u7528 $\\boldsymbol{i}$ \uff0c $\\boldsymbol{j}$ \uff0c $\\boldsymbol{k}$ . n14.8 $a_x$ \uff0c $a_y$ \uff0c $a_z$ ; $a_i$ \u5411\u91cf $\\boldsymbol{a}$ \u7684\u7b1b\u5361\u5c14\u5206\u91cf $\\boldsymbol{a} = a_x \\boldsymbol{e}_x + a_y \\boldsymbol{e}_y + a_z \\boldsymbol{e}_z$ ; \u5982\u679c\u4e0a\u4e0b\u6587\u786e\u5b9a\u4e86\u57fa\u5411\u91cf\uff0c\u5219\u5411\u91cf\u53ef\u4ee5\u5199\u4e3a $\\boldsymbol{a} = (a_x, a_y, a_z)$ . $a_x = \\boldsymbol{a}\\cdot \\boldsymbol{e}_x$ \uff0c $a_y = \\boldsymbol{a}\\cdot \\boldsymbol{e}_y$ \uff0c $a_z = \\boldsymbol{a}\\cdot \\boldsymbol{e}_z$ ; $\\boldsymbol{r} = x\\boldsymbol{e}_x + y\\boldsymbol{e}_y + z\\boldsymbol{e}_z$ \u662f\u5750\u6807\u4e3a $x$ \uff0c $y$ \uff0c $z$ \u7684\u4f4d\u7f6e\u5411\u91cf\u3002 n14.9 $\\delta_{ik}$ Kronecker delta \u7b26\u53f7 $\\delta_{ik}=1\\quad (i=k)$ ; $\\delta_{ik}=0\\quad (i\\ne k)$ . n14.10 $\\varepsilon_{ijk}$ Levi-Civita \u7b26\u53f7 $\\varepsilon_{123} = \\varepsilon_{231} = \\varepsilon_{312} = 1$ ; $\\varepsilon_{132} = \\varepsilon_{321} = \\varepsilon_{213} = -1$ ; \u5176\u4f59\u7684 $\\varepsilon_{ijk}$ \u5747\u4e3a $0$ . n14.11 $\\boldsymbol{a}\\cdot\\boldsymbol{b}$ \u5411\u91cf $\\boldsymbol{a}$ \u548c $\\boldsymbol{b}$ \u7684\u6807\u91cf\u79ef/\u5185\u79ef $\\displaystyle\\boldsymbol{a}\\cdot\\boldsymbol{b}=\\sum\\limits_i a_ib_i$ . n14.12 $\\boldsymbol{a}\\times\\boldsymbol{b}$ \u5411\u91cf $\\boldsymbol{a}$ \u548c $\\boldsymbol{b}$ \u7684\u5411\u91cf\u79ef/\u5916\u79ef \u53f3\u624b\u7b1b\u5361\u5c14\u5750\u6807\u7cfb\u4e2d\uff0c $\\displaystyle (\\boldsymbol{a}\\times\\boldsymbol{b})_i = \\sum\\limits_j\\sum\\limits_k\\varepsilon_{ijk}a_jb_k$ ; $\\varepsilon_{ijk}$ \u7684\u5b9a\u4e49\u53c2\u89c1 n14.10. n14.13 $\\mathbf{\\nabla}$ nabla \u7b97\u5b50 $\\displaystyle \\mathbf{\\nabla} = \\boldsymbol{e}_x\\frac{\\partial}{\\partial x}+\\boldsymbol{e}_y\\frac{\\partial}{\\partial y}+\\boldsymbol{e}_z\\frac{\\partial}{\\partial z}=\\sum\\limits_i\\boldsymbol{e}_i\\frac{\\partial}{\\partial x_i}$ . n14.14 $\\mathbf{\\nabla}\\varphi$ ; $\\operatorname{\\mathbf{grad}}\\varphi$ $\\varphi$ \u7684\u68af\u5ea6 $\\displaystyle \\mathbf{\\nabla}\\varphi=\\sum\\limits_i\\boldsymbol{e}_i\\frac{\\partial\\varphi}{\\partial x_i}$ ; $\\operatorname{\\mathbf{grad}}$ \u5e94\u4f7f\u7528 \\operatorname{\\mathbf{grad}} . n14.15 $\\mathbf{\\nabla}\\cdot\\boldsymbol{a}$ ; $\\operatorname{\\mathbf{div}}\\boldsymbol{a}$ $\\boldsymbol{a}$ \u7684\u6563\u5ea6 $\\displaystyle \\mathbf{\\nabla}\\cdot\\boldsymbol{a}=\\sum\\limits_i\\frac{\\partial a_i}{\\partial x_i}$ ; $\\operatorname{\\mathbf{div}}$ \u5e94\u4f7f\u7528 \\operatorname{\\mathbf{div}} . n14.16 $\\mathbf{\\nabla}\\times\\boldsymbol{a}$ ; $\\operatorname{\\mathbf{rot}}\\boldsymbol{a}$ $\\boldsymbol{a}$ \u7684\u65cb\u5ea6 $\\displaystyle (\\mathbf{\\nabla}\\times\\boldsymbol{a})_i=\\sum\\limits_j\\sum\\limits_k\\varepsilon_{ijk}\\frac{\\partial a_k}{\\partial x_j}$ ; $\\operatorname{\\mathbf{rot}}$ \u5e94\u4f7f\u7528 \\operatorname{\\mathbf{rot}} . \u4e0d\u5e94\u4f7f\u7528 $\\operatorname{\\mathbf{curl}}$ . $\\varepsilon_{ijk}$ \u7684\u5b9a\u4e49\u53c2\u89c1 n14.10. n14.17 $\\mathbf{\\nabla}^2$ ; $\\Delta$ Laplace \u7b97\u5b50 $\\mathbf{\\nabla}^2=\\dfrac{\\partial^2}{\\partial x^2}+\\dfrac{\\partial^2}{\\partial y^2}+\\dfrac{\\partial^2}{\\partial z^2}$ . \u7279\u6b8a\u51fd\u6570 \u00b6 \u672c\u8282\u4e2d\u7684 $z$ \uff0c $w$ \u662f\u590d\u6570\uff0c $k$ \uff0c $n$ \u662f\u81ea\u7136\u6570\uff0c\u4e14 $k\\leq n$ \u3002 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n15.1 $\\gamma$ Euler\u2013Mascheroni \u5e38\u6570 $\\displaystyle \\gamma=\\lim\\limits_{n\\to\\infty}\\left(\\sum\\limits_{k=1}^n\\frac{1}{k}-\\ln n\\right)= 0.577~215~6 \\dots$ . n15.2 $\\Gamma(z)$ gamma \u51fd\u6570 $\\displaystyle\\Gamma(z)=\\int\\limits_0^{\\infty}t^{z-1}\\mathrm{e}^{-t}\\mathrm{d}t\\quad (\\operatorname{Re}z>0)$ ; $\\Gamma(n+1)=n!$ . n15.3 $\\zeta(z)$ Riemann zeta \u51fd\u6570 $\\displaystyle\\zeta(z)=\\sum\\limits_{n=1}^{\\infty}\\frac{1}{n^z}\\quad (\\operatorname{Re}z>1)$ . n15.4 $\\operatorname{B}(z, w)$ beta \u51fd\u6570 $\\displaystyle\\operatorname{B}(z, w)=\\int\\limits_0^1 t^{z-1}(1-t)^{w-1}\\mathrm{d}t\\quad (\\operatorname{Re} z>0$ \uff0c $\\operatorname{Re} w>0)$ ; $\\operatorname{B}(z, w)=\\dfrac{\\Gamma(z)\\Gamma(w)}{\\Gamma(z+w)}$ ; $\\dfrac{1}{(n+1)\\operatorname{B}(k+1, n-k+1)}=\\dbinom{n}{k}$ .","title":"Symbol"},{"location":"intro/symbol.html#_1","text":"\u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n1.1 $p \\land q$ $p$ \u548c $q$ \u7684\u5408\u53d6 $p$ \u4e0e $q$ . n1.2 $p \\lor q$ $p$ \u548c $q$ \u7684\u6790\u53d6 $p$ \u6216 $q$ ; \u6b64\u5904\u7684 \"\u6216\" \u662f\u5305\u542b\u7684\uff0c\u5373\u82e5 $p$ \uff0c $q$ \u4e2d\u6709\u4e00\u4e2a\u4e3a\u771f\u9648\u8ff0\uff0c\u5219 $p \\lor q$ \u4e3a\u771f\u3002 n1.3 $\\lnot p$ $p$ \u7684\u5426\u5b9a \u975e $p$ . n1.4 $p \\implies q$ $p$ \u8574\u542b $q$ ; \u82e5 $p$ \u4e3a\u771f\uff0c\u5219 $q$ \u4e3a\u771f $q \\impliedby p$ \u548c $p \\implies q$ \u540c\u4e49\u3002 n1.5 $p \\iff q$ $p$ \u7b49\u4ef7\u4e8e $q$ $(p \\implies q) \\land (q \\implies p)$ \u548c $p \\iff q$ \u540c\u4e49\u3002 n1.6 $(\\forall~x \\in A)~~p(x)$ \u5bf9 $A$ \u4e2d\u6240\u6709\u7684 $x$ , \u547d\u9898 $p(x)$ \u5747\u4e3a\u771f \u5982\u679c\u4ece\u4e0a\u4e0b\u6587\u4e2d\u53ef\u4ee5\u5f97\u77e5\u8003\u8651\u7684\u662f\u54ea\u4e2a\u96c6\u5408 $A$ , \u53ef\u4ee5\u4f7f\u7528\u8bb0\u53f7 $(\\forall~x)~~p(x)$ . $\\forall$ \u79f0\u4e3a\u5168\u79f0\u91cf\u8bcd\u3002 $x \\in A$ \u7684\u542b\u4e49\u89c1 n2.1. n1.7 $(\\exists~x \\in A)~~p(x)$ \u5b58\u5728\u4e00\u4e2a\u5c5e\u4e8e $A$ \u7684 $x$ \u4f7f\u5f97 $p(x)$ \u4e3a\u771f \u5982\u679c\u4ece\u4e0a\u4e0b\u6587\u4e2d\u53ef\u4ee5\u5f97\u77e5\u8003\u8651\u7684\u662f\u54ea\u4e2a\u96c6\u5408 $A$ , \u53ef\u4ee5\u4f7f\u7528\u8bb0\u53f7 $(\\exists~x)~~p(x)$ . $\\exists$ \u79f0\u4e3a\u5b58\u5728\u91cf\u8bcd\u3002 $x \\in A$ \u7684\u542b\u4e49\u89c1 n2.1. $(\\exists!~x)~~p(x)$ \uff08\u552f\u4e00\u91cf\u8bcd\uff09\u7528\u6765\u8868\u793a\u6070\u6709\u4e00\u4e2a $x$ \u4f7f\u5f97 $p(x)$ \u4e3a\u771f\u3002 $\\exists!$ \u4e5f\u53ef\u4ee5\u5199\u4f5c $\\exists^1$ .","title":"\u6570\u7406\u903b\u8f91"},{"location":"intro/symbol.html#_2","text":"\u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n2.1 $x \\in A$ $x$ \u5c5e\u4e8e $A$ \uff0c $x$ \u662f\u96c6\u5408 $A$ \u4e2d\u7684\u5143\u7d20 $A \\ni x$ \u548c $x \\in A$ \u540c\u4e49\u3002 n2.2 $y \\notin A$ $y$ \u4e0d\u5c5e\u4e8e $A$ \uff0c $y$ \u4e0d\u662f\u96c6\u5408 $A$ \u4e2d\u7684\u5143\u7d20 n2.3 $\\{x_1, x_2, \\dots, x_n\\}$ \u542b\u5143\u7d20 $x_1, x_2, \\dots, x_n$ \u7684\u96c6\u5408 \u4e5f\u53ef\u5199\u4f5c $\\{x_i ~\\vert~ i \\in I\\}$ , \u5176\u4e2d $I$ \u8868\u793a\u6307\u6807\u96c6\u3002 n2.4 $\\{x \\in A ~\\vert~ p(x)\\}$ $A$ \u4e2d\u4f7f\u547d\u9898 $p(x)$ \u4e3a\u771f\u7684\u6240\u6709\u5143\u7d20\u7ec4\u6210\u7684\u96c6\u5408 \u4f8b\u5982 $\\{x \\in \\textbf{R} ~\\vert~ x \\geq 5\\}$ ; \u5982\u679c\u4ece\u4e0a\u4e0b\u6587\u4e2d\u53ef\u4ee5\u5f97\u77e5\u8003\u8651\u7684\u662f\u54ea\u4e2a\u96c6\u5408 $A$ \uff0c\u53ef\u4ee5\u4f7f\u7528\u7b26\u53f7 $\\{x ~\\vert~ p(x)\\}$ \uff08\u5982\u5728\u53ea\u8003\u8651\u5b9e\u6570\u96c6\u65f6\u53ef\u4f7f\u7528 $\\{x ~\\vert~ x \\geq 5\\}$ \uff09 $\\vert$ \u4e5f\u53ef\u4ee5\u4f7f\u7528\u5192\u53f7\u66ff\u4ee3\uff0c\u5982 $\\{x \\in A : p(x)\\}$ . n2.5 $\\operatorname{card} A$ ; $\\vert A\\vert$ $A$ \u4e2d\u7684\u5143\u7d20\u4e2a\u6570\uff0c $A$ \u7684\u57fa\u6570 n2.6 $\\varnothing$ \u7a7a\u96c6 \u4e0d\u5e94\u4f7f\u7528 $\\emptyset$ . n2.7 $B \\subseteq A$ $B$ \u5305\u542b\u4e8e $A$ \u4e2d\uff0c $B$ \u662f $A$ \u7684\u5b50\u96c6 $B$ \u7684\u6bcf\u4e2a\u5143\u7d20\u90fd\u5c5e\u4e8e $A$ . $\\subset$ \u4e5f\u53ef\u7528\u4e8e\u8be5\u542b\u4e49\uff0c\u4f46\u8bf7\u53c2\u9605 n2.8 \u7684\u8bf4\u660e\u3002 $A \\supseteq B$ \u548c $B \\subseteq A$ \u540c\u4e49\u3002 n2.8 $B \\subset A$ $B$ \u771f\u5305\u542b\u4e8e $A$ \u4e2d\uff0c $B$ \u662f $A$ \u7684\u771f\u5b50\u96c6 $B$ \u7684\u6bcf\u4e2a\u5143\u7d20\u90fd\u5c5e\u4e8e $A$ , \u4e14 $A$ \u4e2d\u81f3\u5c11\u6709\u4e00\u4e2a\u5143\u7d20\u4e0d\u5c5e\u4e8e $B$ . \u82e5 $\\subset$ \u7684\u542b\u4e49\u53d6 n2.7, \u5219 n2.8 \u5bf9\u5e94\u7684\u7b26\u53f7\u5e94\u4f7f\u7528 $\\subsetneq$ . $A \\supset B$ \u4e0e $B \\subset A$ \u540c\u4e49\u3002 n2.9 $A \\cup B$ $A$ \u548c $B$ \u7684\u5e76\u96c6 $A \\cup B := \\{x ~\\vert~ x \\in A \\lor x \\in B\\}$ ; $:=$ \u7684\u5b9a\u4e49\u53c2\u89c1 n4.3 n2.10 $A \\cap B$ $A$ \u548c $B$ \u7684\u4ea4\u96c6 $A \\cap B := \\{x ~\\vert~ x \\in A \\land x \\in B\\}$ ; $:=$ \u7684\u5b9a\u4e49\u53c2\u89c1 n4.3 n2.11 $\\displaystyle \\bigcup\\limits_{i=1}^n A_i$ \u96c6\u5408 $A_1, A_2, \\dots, A_n$ \u7684\u5e76\u96c6 $\\displaystyle \\bigcup\\limits_{i=1}^n A_i=A_1\\cup A_2\\cup \\dots \\cup A_n$ ; \u4e5f\u53ef\u4f7f\u7528 $\\displaystyle \\bigcup\\nolimits_{i=1}^n$ \uff0c $\\displaystyle \\bigcup\\limits_{i\\in I}$ \uff0c $\\displaystyle \\bigcup\\nolimits_{i\\in I}$ , \u5176\u4e2d $I$ \u8868\u793a\u6307\u6807\u96c6 n2.12 $\\displaystyle \\bigcap\\limits_{i=1}^n A_i$ \u96c6\u5408 $A_1, A_2, \\dots, A_n$ \u7684\u4ea4\u96c6 $\\displaystyle \\bigcap\\limits_{i=1}^n A_i=A_1\\cap A_2\\cap \\dots \\cap A_n$ ; \u4e5f\u53ef\u4f7f\u7528 $\\displaystyle \\bigcap\\nolimits_{i=1}^n$ \uff0c $\\displaystyle \\bigcap\\limits_{i\\in I}$ \uff0c $\\displaystyle \\bigcap\\nolimits_{i\\in I}$ , \u5176\u4e2d $I$ \u8868\u793a\u6307\u6807\u96c6 n2.13 $A \\setminus B$ $A$ \u548c $B$ \u7684\u5dee\u96c6 $A \\setminus B = \\{x ~\\vert~ x \\in A \\land x \\notin B\\}$ ; \u4e0d\u5e94\u4f7f\u7528 $A - B$ ; \u5f53 $B$ \u662f $A$ \u7684\u5b50\u96c6\u65f6\u4e5f\u53ef\u4f7f\u7528 $\\complement_A B$ , \u5982\u679c\u4ece\u4e0a\u4e0b\u6587\u4e2d\u53ef\u4ee5\u5f97\u77e5\u8003\u8651\u7684\u662f\u54ea\u4e2a\u96c6\u5408 $A$ \uff0c\u5219 $A$ \u53ef\u4ee5\u7701\u7565\u3002 \u4e0d\u5f15\u8d77\u6b67\u4e49\u7684\u60c5\u51b5\u4e0b\u4e5f\u53ef\u4f7f\u7528 $\\overline{B}$ \u8868\u793a\u96c6\u5408 $B$ \u7684\u8865\u96c6\u3002 n2.14 $(a, b)$ \u6709\u5e8f\u6570\u5bf9 $a$ \uff0c $b$ ; \u6709\u5e8f\u5076 $a$ \uff0c $b$ $(a, b) = (c, d)$ \u5f53\u4e14\u4ec5\u5f53 $a = c$ \u4e14 $b = d$ . n2.15 $(a_1, a_2, \\dots, a_n)$ \u6709\u5e8f $n$ \u5143\u7ec4 \u53c2\u89c1 n2.14. n2.16 $A \\times B$ \u96c6\u5408 $A$ \u548c $B$ \u7684\u7b1b\u5361\u5c14\u79ef $A \\times B = \\{(x, y) ~\\vert~ x \\in A \\land y \\in B\\}$ . n2.17 $\\displaystyle \\prod\\limits_{i=1}^{n} A_i$ \u96c6\u5408 $A_1, A_2, \\dots, A_n$ \u7684\u7b1b\u5361\u5c14\u79ef $\\displaystyle \\prod\\limits_{i=1}^{n} A_i=\\{(x_1, x_2, \\dots, x_n) ~\\vert~ x_1 \\in A_1, x_2 \\in A_2, \\dots, x_n \\in A_n\\}$ ; $A \\times A \\times \\dots \\times A$ \u8bb0\u4e3a $A^n$ , \u5176\u4e2d $n$ \u662f\u4e58\u79ef\u4e2d\u7684\u56e0\u5b50\u6570\u3002 n2.18 $\\mathrm{id}_A$ $A\\times A$ \u7684\u5bf9\u89d2\u96c6 $\\mathrm{id}_A=\\{(x, x)~\\vert~x\\in A\\}$ ; \u5982\u679c\u4ece\u4e0a\u4e0b\u6587\u4e2d\u53ef\u4ee5\u5f97\u77e5\u8003\u8651\u7684\u662f\u54ea\u4e2a\u96c6\u5408 $A$ , \u5219 $A$ \u53ef\u4ee5\u7701\u7565\u3002","title":"\u96c6\u5408\u8bba"},{"location":"intro/symbol.html#_3","text":"\u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n3.1 $\\mathbf{N}$ \u81ea\u7136\u6570\u96c6 $\\mathbf{N} = \\{0, 1, 2, 3, \\dots\\}$ ; $\\mathbf{N}^* = \\mathbf{N}_+ = \\{1, 2, 3, \\dots\\}$ ; \u53ef\u7528\u5982\u4e0b\u65b9\u5f0f\u6dfb\u52a0\u5176\u4ed6\u9650\u5236\uff1a $\\mathbf{N}_{> 5} = \\{n \\in \\mathbf{N} ~\\vert~ n > 5\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{N}$ . n3.2 $\\mathbf{Z}$ \u6574\u6570\u96c6 $\\mathbf{Z}^* = \\mathbf{Z}_+ = \\{n \\in \\mathbf{Z} ~\\vert~ n \\ne 0\\}$ ; \u53ef\u7528\u5982\u4e0b\u65b9\u5f0f\u6dfb\u52a0\u5176\u4ed6\u9650\u5236\uff1a $\\mathbf{Z}_{> -3} = \\{n \\in \\mathbf{Z} ~\\vert~ n > -3\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{Z}$ . n3.3 $\\mathbf{Q}$ \u6709\u7406\u6570\u96c6 $\\mathbf{Q}^* = \\mathbf{Q}_+ = \\{r \\in \\mathbf{Q} ~\\vert~ r \\ne 0\\}$ ; \u53ef\u7528\u5982\u4e0b\u65b9\u5f0f\u6dfb\u52a0\u5176\u4ed6\u9650\u5236\uff1a $\\mathbf{Q}_{< 0} = \\{r \\in \\mathbf{Q} ~\\vert~ r < 0\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{Q}$ . n3.4 $\\mathbf{R}$ \u5b9e\u6570\u96c6 $\\mathbf{R}^* = \\mathbf{R}_+ = \\{x \\in \\mathbf{R} ~\\vert~ x \\ne 0\\}$ ; \u53ef\u7528\u5982\u4e0b\u65b9\u5f0f\u6dfb\u52a0\u5176\u4ed6\u9650\u5236\uff1a $\\mathbf{R}_{> 0} = \\{x \\in \\mathbf{R} ~\\vert~ x > 0\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{R}$ . n3.5 $\\mathbf{C}$ \u590d\u6570\u96c6 $\\mathbf{C}^* = \\mathbf{C}_+ = \\{z \\in \\mathbf{C} ~\\vert~ z \\ne 0\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{C}$ . n3.6 $\\mathbf{P}$ \uff08\u6b63\uff09\u7d20\u6570\u96c6 $\\mathbf{P} = \\{2, 3, 5, 7, 11, 13, 17, \\dots\\}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\mathbb{P}$ . n3.7 $[a, b]$ $a$ \u5230 $b$ \u7684\u95ed\u533a\u95f4 $[a, b] = \\{x \\in \\mathbf{R} ~\\vert~ a \\leq x \\leq b\\}$ . n3.8 $(a, b]$ $a$ \u5230 $b$ \u7684\u5de6\u5f00\u53f3\u95ed\u533a\u95f4 $(a, b] = \\{x \\in \\mathbf{R} ~\\vert~ a < x \\leq b\\}$ ; $(-\\infty, b] = \\{x \\in \\mathbf{R} ~\\vert~ x \\leq b\\}$ . n3.9 $[a, b)$ $a$ \u5230 $b$ \u7684\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 $[a, b) = \\{x \\in \\mathbf{R} ~\\vert~ a \\leq x < b\\}$ ; $[a, +\\infty) = \\{x \\in \\mathbf{R} ~\\vert~ a \\leq x\\}$ . n3.10 $(a, b)$ $a$ \u5230 $b$ \u7684\u5f00\u533a\u95f4 $(a, b) = \\{x \\in \\mathbf{R} ~\\vert~ a < x < b\\}$ ; $(-\\infty, b) = \\{x \\in \\mathbf{R} ~\\vert~ x < b\\}$ ; $(a, +\\infty) = \\{x \\in \\mathbf{R} ~\\vert~ a < x\\}$ .","title":"\u6807\u51c6\u6570\u96c6\u548c\u533a\u95f4"},{"location":"intro/symbol.html#_4","text":"\u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n4.1 $a = b$ $a$ \u7b49\u4e8e $b$ $\\equiv$ \u7528\u4e8e\u5f3a\u8c03\u67d0\u7b49\u5f0f\u662f\u6052\u7b49\u5f0f \u8be5\u7b26\u53f7\u7684\u53e6\u4e00\u4e2a\u542b\u4e49\u53c2\u89c1 n4.18. n4.2 $a \\ne b$ $a$ \u4e0d\u7b49\u4e8e $b$ n4.3 $a := b$ $a$ \u5b9a\u4e49\u4e3a $b$ \u53c2\u89c1 n2.9, n2.10 n4.4 $a \\approx b$ $a$ \u7ea6\u7b49\u4e8e $b$ \u4e0d\u6392\u9664\u76f8\u7b49\u3002 n4.5 $a \\simeq b$ $a$ \u6e10\u8fdb\u7b49\u4e8e $b$ \u4f8b\u5982\uff1a \u5f53 $x\\to a$ \u65f6\uff0c $\\dfrac{1}{\\sin(x-a)} \\simeq \\dfrac{1}{x-a}$ ; $x \\to a$ \u7684\u542b\u4e49\u53c2\u89c1 n4.15. n4.6 $a \\propto b$ $a$ \u4e0e $b$ \u6210\u6b63\u6bd4 \u4e5f\u53ef\u4f7f\u7528 $a \\sim b$ . $\\sim$ \u4e5f\u7528\u4e8e\u8868\u793a\u7b49\u4ef7\u5173\u7cfb\u3002 n4.7 $M \\cong N$ $M$ \u4e0e $N$ \u5168\u7b49 \u5f53 $M$ \u548c $N$ \u662f\u70b9\u96c6\uff08\u51e0\u4f55\u56fe\u5f62\uff09\u65f6\u3002 \u8be5\u7b26\u53f7\u4e5f\u7528\u4e8e\u8868\u793a\u4ee3\u6570\u7ed3\u6784\u7684\u540c\u6784\u3002 n4.8 $a < b$ $a$ \u5c0f\u4e8e $b$ n4.9 $b > a$ $b$ \u5927\u4e8e $a$ n4.10 $a \\leq b$ $a$ \u5c0f\u4e8e\u7b49\u4e8e $b$ n4.11 $b \\geq a$ $b$ \u5927\u4e8e\u7b49\u4e8e $a$ n4.12 $a \\ll b$ $a$ \u8fdc\u5c0f\u4e8e $b$ n4.13 $b \\gg a$ $b$ \u8fdc\u5927\u4e8e $a$ n4.14 $\\infty$ \u65e0\u7a77\u5927 \u8be5\u7b26\u53f7 \u4e0d \u662f\u6570\u5b57\u3002 \u4e5f\u53ef\u4ee5\u4f7f\u7528 $+\\infty$ \uff0c $-\\infty$ . n4.15 $x \\to a$ $x$ \u8d8b\u8fd1\u4e8e $a$ \u4e00\u822c\u51fa\u73b0\u5728\u6781\u9650\u8868\u8fbe\u5f0f\u4e2d\u3002 $a$ \u4e5f\u53ef\u4ee5\u4e3a $\\infty$ \uff0c $+\\infty$ \uff0c $-\\infty$ . n4.16 $m \\mid n$ $m$ \u6574\u9664 $n$ \u5bf9\u6574\u6570 $m$ \uff0c $n$ : $(\\exists~k \\in \\mathbf{Z})~~m\\cdot k = n$ . n4.17 $m \\perp n$ $m$ \u4e0e $n$ \u4e92\u8d28 \u5bf9\u6574\u6570 $m$ \uff0c $n$ : $(\\nexists~k \\in \\mathbf{Z}_{>1})~~(k \\mid m) \\land (k \\mid n)$ ; \u8be5\u7b26\u53f7\u7684\u53e6\u4e00\u79cd\u7528\u6cd5\u53c2\u89c1 n5.2 n4.18 $n \\equiv k \\pmod m$ $n$ \u6a21 $m$ \u4e0e $k$ \u540c\u4f59 \u5bf9\u6574\u6570 $n$ \uff0c $k$ \uff0c $m$ : $m \\mid (n - k)$ ; \u4e0d\u8981\u4e0e n4.1 \u4e2d\u63d0\u5230\u7684\u76f8\u6df7\u6dc6\u3002","title":"\u5173\u7cfb"},{"location":"intro/symbol.html#_5","text":"\u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n5.1 $\\parallel$ \u5e73\u884c n5.2 $\\perp$ \u5782\u76f4 \u8be5\u7b26\u53f7\u7684\u53e6\u4e00\u79cd\u7528\u6cd5\u53c2\u89c1 n4.17 n5.3 $\\angle$ \uff08\u5e73\u9762\uff09\u89d2 n5.4 $\\overline{\\mathrm{AB}}$ \u7ebf\u6bb5 $\\mathrm{AB}$ n5.5 $\\overrightarrow{\\mathrm{AB}}$ \u6709\u5411\u7ebf\u6bb5 $\\mathrm{AB}$ n5.6 $d(\\mathrm{A}, \\mathrm{B})$ \u70b9 $\\mathrm{A}$ \u548c $\\mathrm{B}$ \u4e4b\u95f4\u7684\u8ddd\u79bb \u5373 $\\overline{\\mathrm{AB}}$ \u7684\u957f\u5ea6\u3002","title":"\u521d\u7b49\u51e0\u4f55\u5b66"},{"location":"intro/symbol.html#_6","text":"\u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n6.1 $a + b$ $a$ \u52a0 $b$ n6.2 $a - b$ $a$ \u51cf $b$ n6.3 $a \\pm b$ $a$ \u52a0\u6216\u51cf $b$ n6.4 $a \\mp b$ $a$ \u51cf\u6216\u52a0 $b$ $-(a \\pm b) = -a \\mp b$ . n6.5 $a \\cdot b$ ; $a \\times b$ ; $ab$ $a$ \u4e58 $b$ \u82e5\u51fa\u73b0\u5c0f\u6570\u70b9\uff0c\u5219\u5e94\u53ea\u4f7f\u7528 $\\times$ ; \u90e8\u5206\u7528\u4f8b\u53c2\u89c1 n2.16, n2.17, n14.11, n14.12 n6.6 $\\dfrac{a}{b}$ ; $a/b$ ; $a:b$ $a$ \u9664\u4ee5 $b$ $\\dfrac{a}{b}=a\\cdot b^{-1}$ ; \u53ef\u7528 $:$ \u8868\u793a\u540c\u4e00\u91cf\u7eb2\u7684\u6570\u503c\u7684\u6bd4\u7387\u3002 \u4e0d\u5e94\u4f7f\u7528 $\u00f7$ . n6.7 $\\displaystyle \\sum\\limits_{i=1}^n a_i$ $a_1 + a_2 + \\dots + a_n$ \u4e5f\u53ef\u4f7f\u7528 $\\displaystyle \\sum\\nolimits_{i=1}^n a_i$ \uff0c $\\displaystyle \\sum\\limits_i a_i$ \uff0c $\\displaystyle \\sum\\nolimits_i a_i$ \uff0c $\\displaystyle \\sum a_i$ . n6.8 $\\displaystyle \\prod\\limits_{i=1}^n a_i$ $a_1 \\cdot a_2 \\cdot \\dots \\cdot a_n$ \u4e5f\u53ef\u4f7f\u7528 $\\displaystyle \\prod\\nolimits_{i=1}^n a_i$ \uff0c $\\displaystyle \\prod\\limits_i a_i$ \uff0c $\\displaystyle \\prod\\nolimits_i a_i$ \uff0c $\\displaystyle \\prod a_i$ . n6.9 $a^p$ $a$ \u7684 $p$ \u6b21\u5e42 n6.10 $a^{1/2}$ ; $\\sqrt{a}$ $a$ \u7684 $1/2$ \u6b21\u65b9\uff0c $a$ \u7684\u5e73\u65b9\u6839 \u5e94\u907f\u514d\u4f7f\u7528 $\\sqrt{}a$ . n6.11 $a^{1/n}$ ; $\\sqrt[n]{a}$ $a$ \u7684 $1/n$ \u6b21\u5e42\uff0c $a$ \u7684 $n$ \u6b21\u6839 \u5e94\u907f\u514d\u4f7f\u7528 $\\sqrt[n]{}a$ . n6.12 $\\bar{x}$ ; $\\bar{x}_a$ $x$ \u7684\u7b97\u6570\u5747\u503c \u5176\u4ed6\u5747\u503c\u6709\uff1a \u8c03\u548c\u5747\u503c $\\bar{x}_h$ ; \u51e0\u4f55\u5747\u503c $\\bar{x}_g$ ; \u4e8c\u6b21\u5747\u503c/\u5747\u65b9\u6839 $\\bar{x}_q$ \u6216 $\\bar{x}_{rms}$ . $\\bar{x}$ \u4e5f\u7528\u4e8e\u8868\u793a\u590d\u6570 $x$ \u7684\u5171\u8f6d\uff0c\u53c2\u89c1 n11.6. n6.13 $\\operatorname{sgn} a$ $a$ \u7684\u7b26\u53f7\u51fd\u6570 \u5bf9\u5b9e\u6570 $a$ : $\\operatorname{sgn} a=1\\quad (a>0)$ ; $\\operatorname{sgn} a=-1\\quad (a<0)$ ; $\\operatorname{sgn} 0=0$ ; \u53c2\u89c1 n11.7. n6.14 $\\inf M$ $M$ \u7684\u4e0b\u786e\u754c \u5c0f\u4e8e\u7b49\u4e8e\u975e\u7a7a\u96c6\u5408 $M$ \u4e2d\u5143\u7d20\u7684\u6700\u5927\u4e0a\u754c\u3002 n6.15 $\\sup M$ $M$ \u7684\u4e0a\u786e\u754c \u5927\u4e8e\u7b49\u4e8e\u975e\u7a7a\u96c6\u5408 $M$ \u4e2d\u5143\u7d20\u7684\u6700\u5c0f\u4e0b\u754c\u3002 n6.16 $\\lvert a\\rvert$ $a$ \u7684\u7edd\u5bf9\u503c \u4e5f\u53ef\u4f7f\u7528 $\\operatorname{abs} a$ . n6.17 $\\lfloor a\\rfloor$ \u5411\u4e0b\u53d6\u6574 \u5c0f\u4e8e\u7b49\u4e8e\u5b9e\u6570 $a$ \u7684\u6700\u5927\u6574\u6570 \u4f8b\u5982\uff1a $\\lfloor 2.4\\rfloor = 2$ ; $\\lfloor -2.4\\rfloor = -3$ . n6.18 $\\lceil a\\rceil$ \u5411\u4e0a\u53d6\u6574 \u5927\u4e8e\u7b49\u4e8e\u5b9e\u6570 $a$ \u7684\u6700\u5c0f\u6574\u6570 \u4f8b\u5982\uff1a $\\lceil 2.4\\rceil = 3$ ; $\\lceil -2.4\\rceil = -2$ . n6.19 $\\min(a, b)$ ; $\\min\\{a, b\\}$ $a$ \u548c $b$ \u7684\u6700\u5c0f\u503c \u53ef\u63a8\u5e7f\u5230\u6709\u9650\u96c6\u4e2d\u3002 \u8981\u8868\u793a\u65e0\u9650\u96c6\u4e2d\u7684\u6700\u5c0f\u503c\u5efa\u8bae\u4f7f\u7528 $\\inf$ , \u53c2\u89c1 n6.14 n6.20 $\\max(a, b)$ ; $\\max\\{a, b\\}$ $a$ \u548c $b$ \u7684\u6700\u5927\u503c \u53ef\u63a8\u5e7f\u5230\u6709\u9650\u96c6\u4e2d\u3002 \u8981\u8868\u793a\u65e0\u9650\u96c6\u4e2d\u7684\u6700\u5927\u503c\u5efa\u8bae\u4f7f\u7528 $\\sup$ , \u53c2\u89c1 n6.15 n6.21 $n \\bmod m$ $n$ \u6a21 $m$ \u7684\u4f59\u6570 \u5bf9\u6b63\u6574\u6570 $n$ \uff0c $m$ : $(\\exists~q\\in\\mathbf{N}, r\\in[0, m))~~n=qm+r$ ; \u5176\u4e2d $r=n \\bmod m$ . n6.22 $\\gcd(a, b)$ ; $\\gcd\\{a, b\\}$ \u6574\u6570 $a$ \u548c $b$ \u7684\u6700\u5927\u516c\u56e0\u6570 \u53ef\u63a8\u5e7f\u5230\u6709\u9650\u96c6\u4e2d\u3002\u4e0d\u5f15\u8d77\u6b67\u4e49\u7684\u60c5\u51b5\u4e0b\u53ef\u5199\u4e3a $(a, b)$ . n6.23 $\\operatorname{lcm}(a, b)$ ; $\\operatorname{lcm}\\{a, b\\}$ \u6574\u6570 $a$ \u548c $b$ \u7684\u6700\u5c0f\u516c\u500d\u6570 \u53ef\u63a8\u5e7f\u5230\u6709\u9650\u96c6\u4e2d\u3002\u4e0d\u5f15\u8d77\u6b67\u4e49\u7684\u60c5\u51b5\u4e0b\u53ef\u5199\u4e3a $[a, b]$ ; $(a, b)[a, b]=\\lvert ab\\rvert$ .","title":"\u8fd0\u7b97\u7b26"},{"location":"intro/symbol.html#_7","text":"\u672c\u8282\u4e2d\u7684 $n$ \u548c $k$ \u662f\u81ea\u7136\u6570\uff0c $a$ \u662f\u590d\u6570\uff0c\u4e14 $k\\leq n$ . \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n7.1 $n!$ \u9636\u4e58 $n!=\\prod_{k=1}^n k=1\\cdot 2\\cdot 3\\cdot \\dots \\cdot n\\quad (n>0)$ ; $0!=1$ . n7.2 $a^{\\underline{k}}$ \u4e0b\u964d\u9636\u4e58\u5e42 $a^{\\underline{k}}=a\\cdot(a-1)\\cdot \\dots \\cdot(a-k+1)\\quad (k>0)$ ; $a^{\\underline{0}}=1$ ; $n^{\\underline{k}}=\\dfrac{n!}{(n-k)!}$ . n7.3 $a^{\\overline{k}}$ \u4e0a\u5347\u9636\u4e58\u5e42 $a^{\\overline{k}}=a\\cdot(a+1)\\cdot \\dots \\cdot(a+k-1)\\quad (k>0)$ ; $a^{\\overline{0}}=1$ ; $n^{\\overline{k}}=\\dfrac{(n+k-1)!}{(n-1)!}$ . n7.4 $\\dbinom{n}{k}$ \u7ec4\u5408\u6570 $\\dbinom{n}{k}=\\dfrac{n!}{k!(n-k)!}$ . n7.5 $\\displaystyle{n\\brack k}$ \u7b2c\u4e00\u7c7b Stirling \u6570 $\\displaystyle{n+1\\brack k}=n{n\\brack k}+{n\\brack k-1}$ ; $\\displaystyle x^{\\overline{n}}=\\sum_{k=0}^n{n\\brack k}x^k$ . n7.6 $\\displaystyle{n\\brace k}$ \u7b2c\u4e8c\u7c7b Stirling \u6570 $\\displaystyle{n\\brace k}=\\frac{1}{k!}\\sum_{i=0}^k(-1)^i\\binom{k}{i}(k-i)^n$ ; $\\displaystyle\\sum_{k=0}^n{n\\brace k}x^{\\underline{k}}=x^n$ .","title":"\u7ec4\u5408\u6570\u5b66"},{"location":"intro/symbol.html#_8","text":"\u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n8.1 $f$ \u51fd\u6570 n8.2 $f(x)$ \uff0c $f(x_1, \\dots, x_n)$ \u51fd\u6570 $f$ \u5728 $x$ \u5904\u7684\u503c \u51fd\u6570 $f$ \u5728 $(x_1, \\dots, x_n)$ \u5904\u7684\u503c n8.3 $\\operatorname{dom} f$ $f$ \u7684\u5b9a\u4e49\u57df \u4e5f\u53ef\u4f7f\u7528 $\\mathrm{D}(f)$ . n8.4 $\\operatorname{ran} f$ $f$ \u7684\u503c\u57df \u4e5f\u53ef\u4f7f\u7528 $\\mathrm{R}(f)$ . n8.5 $f:A\\to B$ $f$ \u662f $A$ \u5230 $B$ \u7684\u6620\u5c04 $\\operatorname{dom} f=A$ \u4e14 $(\\forall~x \\in\\operatorname{dom} f)~~ f(x) \\in B$ . n8.6 $x\\mapsto T(x), x\\in A$ \u5c06\u6240\u6709 $x\\in A$ \u6620\u5c04\u5230 $T(x)$ \u7684\u51fd\u6570 $T(x)$ \u4ec5\u7528\u4e8e\u5b9a\u4e49\uff0c\u7528\u6765\u8868\u793a\u67d0\u4e2a\u53c2\u6570\u4e3a $x\\in A$ \u7684\u67d0\u4e2a\u51fd\u6570\u503c\u3002\u82e5\u8fd9\u4e2a\u51fd\u6570\u4e3a $f$ , \u5219\u5bf9\u6240\u6709 $x\\in A$ \u5747\u6709 $f(x)=T(x)$ . \u56e0\u6b64 $T(x)$ \u901a\u5e38\u7528\u6765\u5b9a\u4e49\u51fd\u6570 $f$ . \u4f8b\u5982\uff1a $x\\mapsto 3x^2y, x\\in[0, 2]$ ; \u8fd9\u662f\u7531 $3x^2y$ \u5b9a\u4e49\u7684\u4e00\u4e2a\u5173\u4e8e $x$ \u7684\u4e8c\u6b21\u51fd\u6570\u3002\u82e5\u672a\u5f15\u5165\u51fd\u6570\u7b26\u53f7\uff0c\u5219\u7528 $3x^2y$ \u8868\u793a\u8be5\u51fd\u6570 n8.7 $f^{-1}$ $f$ \u7684\u53cd\u51fd\u6570 \u51fd\u6570 $f$ \u7684\u53cd\u51fd\u6570 $f^{-1}$ \u6709\u5b9a\u4e49\u5f53\u4e14\u4ec5\u5f53 $f$ \u662f\u5355\u5c04\u3002 \u82e5 $f$ \u662f\u5355\u5c04\uff0c\u5219 $\\operatorname{dom}\\left(f^{-1}\\right) = \\operatorname{ran} f$ \uff0c $\\operatorname{ran}\\left(f^{-1}\\right) = \\operatorname{dom} f$ , \u4e14 $(\\forall~x\\in\\operatorname{dom} f)~~f^{-1}(f(x)) = x$ . \u4e0d\u8981\u4e0e\u51fd\u6570\u7684\u5012\u6570 $f(x)^{-1}$ \u6df7\u6dc6\u3002 n8.8 $g\\circ f$ $f$ \u548c $g$ \u7684\u590d\u5408\u51fd\u6570 $(g\\circ f)(x)=g(f(x))$ . n8.9 $f:x\\mapsto y$ $f(x)=y$ \uff0c $f$ \u5c06 $x$ \u6620\u5c04\u5230 $y$ n8.10 $f\\vert_a^b$ ; $f(\\dots, u, \\dots)\\vert_{u=a}^{u=b}$ $f(b)-f(a)$ ; $f(\\dots, b, \\dots)-f(\\dots, a, \\dots)$ \u4e3b\u8981\u7528\u4e8e\u5b9a\u79ef\u5206\u7684\u8ba1\u7b97\u4e2d\u3002 n8.11 $\\displaystyle \\lim\\limits_{x\\to a}f(x)$ ; $\\lim\\nolimits_{x\\to a}f(x)$ \u5f53 $x$ \u8d8b\u8fd1\u4e8e $a$ \u65f6 $f(x)$ \u7684\u6781\u9650 $\\lim\\nolimits_{x\\to a}f(x)=b$ \u53ef\u4ee5\u5199\u6210 $f(x)\\to b\\quad (x \\to a)$ . \u53f3\u6781\u9650\u548c\u5de6\u6781\u9650\u7684\u7b26\u53f7\u5206\u522b\u4e3a $\\lim\\nolimits_{x\\to a+}f(x)$ \u548c $\\lim\\nolimits_{x\\to a-}f(x)$ . n8.12 $f(x) = O(g(x))$ $\\lvert f(x)/g(x)\\rvert$ \u5728\u4e0a\u4e0b\u6587\u9690\u542b\u7684\u9650\u5236\u4e2d\u6709\u4e0a\u754c\uff0c $f(x)$ \u7684\u9636\u4e0d\u9ad8\u4e8e $g(x)$ \u5f53 $f/g$ \u4e0e $g/f$ \u5747\u6709\u754c\u65f6\u79f0 $f$ \u4e0e $g$ \u662f\u540c\u9636\u7684\u3002 \u4f7f\u7528\u7b26\u53f7 \" $=$ \" \u662f\u51fa\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u5176\u5728\u6b64\u5904\u4e0d\u8868\u793a\u7b49\u4ef7\uff0c\u56e0\u4e3a\u4e0d\u6ee1\u8db3\u4f20\u9012\u6027\u3002 \u4f8b\u5982\uff1a $\\sin x=O(x)\\quad (x\\to 0)$ . n8.13 $f(x) = o(g(x))$ \u5728\u4e0a\u4e0b\u6587\u9690\u542b\u7684\u9650\u5236\u4e2d\u6709 $f(x)/g(x)\\to 0$ \uff0c $f(x)$ \u7684\u9636\u9ad8\u4e8e $g(x)$ \u4f7f\u7528\u7b26\u53f7 \" $=$ \" \u662f\u51fa\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u5176\u5728\u6b64\u5904\u4e0d\u8868\u793a\u7b49\u4ef7\uff0c\u56e0\u4e3a\u4e0d\u6ee1\u8db3\u4f20\u9012\u6027\u3002 \u4f8b\u5982\uff1a $\\cos x=1+o(x)\\quad (x\\to 0)$ . n8.14 $\\Delta f$ $f$ \u7684\u6709\u9650\u589e\u91cf \u4e0a\u4e0b\u6587\u9690\u542b\u7684\u4e24\u51fd\u6570\u503c\u7684\u5dee\u5206\u3002\u4f8b\u5982\uff1a $\\Delta x=x_2-x_1$ ; $\\Delta f(x)=f(x_2)-f(x_1)$ . n8.15 $\\dfrac{\\mathrm{d}f}{\\mathrm{d}x}$ ; $f'$ $f$ \u5bf9 $x$ \u7684\u5bfc\uff08\u51fd\uff09\u6570 \u4ec5\u7528\u4e8e\u4e00\u5143\u51fd\u6570\u3002 \u53ef\u4ee5\u663e\u5f0f\u6307\u660e\u81ea\u53d8\u91cf\uff0c\u5982 $\\dfrac{\\mathrm{d}f(x)}{\\mathrm{d}x}$ \uff0c $f'(x)$ . n8.16 $\\left(\\dfrac{\\mathrm{d}f}{\\mathrm{d}x}\\right)_{x=a}$ ; $f'(a)$ $f$ \u5728 $a$ \u5904\u7684\u5bfc\uff08\u51fd\uff09\u6570\u503c \u53c2\u89c1 n8.15 n8.17 $\\dfrac{\\mathrm{d}^n f}{\\mathrm{d}x^n}$ ; $f^{(n)}$ $f$ \u5bf9 $x$ \u7684 $n$ \u9636\u5bfc\uff08\u51fd\uff09\u6570 \u4ec5\u7528\u4e8e\u4e00\u5143\u51fd\u6570\u3002 \u53ef\u4ee5\u663e\u5f0f\u6307\u660e\u81ea\u53d8\u91cf\uff0c\u5982 $\\dfrac{\\mathrm{d}^n f(x)}{\\mathrm{d}x^n}$ \uff0c $f^{(n)}(x)$ . \u53ef\u7528 $f''$ \u548c $f'''$ \u5206\u522b\u8868\u793a $f^{(2)}$ \u548c $f^{(3)}$ . n8.18 $\\dfrac{\\partial f}{\\partial x}$ ; $f_x$ $f$ \u5bf9 $x$ \u7684\u504f\u5bfc\u6570 \u4ec5\u7528\u4e8e\u591a\u5143\u51fd\u6570\u3002 \u53ef\u4ee5\u663e\u5f0f\u6307\u660e\u81ea\u53d8\u91cf\uff0c\u5982 $\\dfrac{\\partial f(x, y, \\dots)}{\\partial x}$ \uff0c $f_x(x, y, \\dots)$ . \u53ef\u4ee5\u6269\u5c55\u5230\u9ad8\u9636\uff0c\u5982 $f_{xx}=\\dfrac{\\partial^2 f}{\\partial x^2}=\\dfrac{\\partial}{\\partial x}\\left(\\dfrac{\\partial f}{\\partial x}\\right)$ ; $f_{xy}=\\dfrac{\\partial^2 f}{\\partial y\\partial x}=\\dfrac{\\partial}{\\partial y}\\left(\\dfrac{\\partial f}{\\partial x}\\right)$ . n8.19 $\\dfrac{\\partial(f_1, \\dots, f_m)}{\\partial(x_1, \\dots, x_n)}$ Jacobi \u77e9\u9635 \u53c2\u89c1 [^n8.19-ref1] n8.20 $\\mathrm{d}f$ $f$ \u7684\u5168\u5fae\u5206 $\\mathrm{d}f(x, y, \\dots)=\\dfrac{\\partial f}{\\partial x}\\mathrm{d}x+\\dfrac{\\partial f}{\\partial y}\\mathrm{d}y+\\dots$ . n8.21 $\\delta f$ $f$ \u7684\uff08\u65e0\u7a77\u5c0f\uff09\u53d8\u5206 n8.22 $\\displaystyle \\int f(x)\\mathrm{d}x$ $f$ \u7684\u4e0d\u5b9a\u79ef\u5206 n8.23 $\\displaystyle \\int\\limits_a^b f(x)\\mathrm{d}x$ $f$ \u4ece $a$ \u5230 $b$ \u7684\u5b9a\u79ef\u5206 \u4e5f\u53ef\u4f7f\u7528 $\\displaystyle \\int\\nolimits_a^b f(x)\\mathrm{d}x$ ; \u5b9a\u79ef\u5206\u8fd8\u53ef\u4ee5\u5b9a\u4e49\u5728\u66f4\u4e00\u822c\u7684\u57df\u4e0a\u3002\u5982 $\\displaystyle\\int\\limits_C$ \uff0c $\\displaystyle\\int\\limits_S$ \uff0c $\\displaystyle\\int\\limits_V$ \uff0c $\\displaystyle\\oint$ , \u5206\u522b\u8868\u793a\u5728\u66f2\u7ebf $C$ , \u66f2\u9762 $S$ , \u4e09\u7ef4\u533a\u57df $V$ , \u548c\u95ed\u66f2\u7ebf\u6216\u66f2\u9762\u4e0a\u7684\u5b9a\u79ef\u5206\u3002 \u591a\u91cd\u79ef\u5206\u53ef\u5199\u6210 $\\displaystyle\\iint$ \uff0c $\\displaystyle\\iiint$ \u7b49\u3002 n8.24 $f*g$ \u51fd\u6570 $f$ \u548c $g$ \u7684\u5377\u79ef $\\displaystyle (f*g)(x)=\\int\\limits_{-\\infty}^{\\infty}f(y)g(x-y)\\mathrm{d}y$ . [^n8.19-ref1]: $\\dfrac{\\partial(f_1, \\dots, f_m)}{\\partial(x_1, \\dots, x_n)}=\\begin{pmatrix}\\dfrac{\\partial f_1}{\\partial x_1}&\\cdots&\\dfrac{\\partial f_1}{\\partial x_n}\\\\\\vdots&\\ddots&\\vdots\\\\\\dfrac{\\partial f_m}{\\partial x_1}&\\cdots&\\dfrac{\\partial f_m}{\\partial x_n}\\end{pmatrix}$ ; \u77e9\u9635\u7684\u5b9a\u4e49\u53c2\u89c1 n12.1","title":"\u51fd\u6570"},{"location":"intro/symbol.html#_9","text":"$x$ \u53ef\u4ee5\u662f\u590d\u6570\u3002 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n9.1 $\\mathrm{e}$ \u81ea\u7136\u5bf9\u6570\u7684\u5e95 $\\displaystyle \\mathrm{e}=\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{n}\\right)^n=2.718~281~8\\dots$ ; \u4e0d\u8981\u5199\u6210 $e$ . n9.2 $a^x$ $x$ \u7684\u6307\u6570\u51fd\u6570\uff08\u4ee5 $a$ \u4e3a\u5e95\uff09 \u53c2\u89c1 n6.9. n9.3 $\\mathrm{e}^x$ ; $\\exp x$ $x$ \u7684\u6307\u6570\u51fd\u6570\uff08\u4ee5 $\\mathrm{e}$ \u4e3a\u5e95\uff09 n9.4 $\\log_a x$ $x$ \u7684\u4ee5 $a$ \u4e3a\u5e95\u7684\u5bf9\u6570 \u5f53\u5e95\u6570\u4e0d\u9700\u8981\u6307\u5b9a\u7684\u65f6\u5019\u53ef\u4ee5\u4f7f\u7528 $\\log x$ . \u4e0d\u5e94\u7528 $\\log x$ \u66ff\u6362 $\\ln x$ \uff0c $\\lg x$ \uff0c $\\operatorname{lb} x$ \u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u3002 n9.5 $\\ln x$ $x$ \u7684\u81ea\u7136\u5bf9\u6570 $\\ln x = \\log_{\\mathrm{e}} x$ ; \u53c2\u89c1 n9.4. n9.6 $\\lg x$ $x$ \u7684\u5e38\u7528\u5bf9\u6570 $\\lg x = \\log_{10} x$ ; \u53c2\u89c1 n9.4. n9.7 $\\operatorname{lb} x$ $x$ \u7684\u4ee5 $2$ \u4e3a\u5e95\u7684\u5bf9\u6570 $\\operatorname{lb} x = \\log_2 x$ ; \u53c2\u89c1 n9.4.","title":"\u6307\u6570\u548c\u5bf9\u6570\u51fd\u6570"},{"location":"intro/symbol.html#_10","text":"\u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n10.1 $\\pi$ \u5706\u5468\u7387 $\\pi = 3.141~592~6\\dots$ . n10.2 $\\sin x$ $x$ \u7684\u6b63\u5f26 $\\sin x=\\dfrac{\\mathrm{e}^{\\mathrm{i}x}-\\mathrm{e}^{-\\mathrm{i}x}}{2\\mathrm{i}}$ ; $(\\sin x)^n$ \uff0c $(\\cos x)^n$ ( $n\\geq 2$ ) \u7b49\u901a\u5e38\u5199\u4e3a $\\sin^n x$ \uff0c $\\cos^n x$ \u7b49\u3002 n10.3 $\\cos x$ $x$ \u7684\u4f59\u5f26 $\\cos x = \\sin(x + \\pi/2)$ . n10.4 $\\tan x$ $x$ \u7684\u6b63\u5207 $\\tan x = \\sin x/\\cos x$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{tg} x$ . n10.5 $\\cot x$ $x$ \u7684\u4f59\u5207 $\\cot x = 1/\\tan x$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{ctg} x$ . n10.6 $\\sec x$ $x$ \u7684\u6b63\u5272 $\\sec x = 1/\\cos x$ . n10.7 $\\csc x$ $x$ \u7684\u4f59\u5272 $\\csc x = 1/\\sin x$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{cosec} x$ . n10.8 $\\arcsin x$ $x$ \u7684\u53cd\u6b63\u5f26 $y = \\arcsin x \\iff x = \\sin y\\quad (-\\pi/2 \\leq y \\leq \\pi/2)$ . n10.9 $\\arccos x$ $x$ \u7684\u53cd\u4f59\u5f26 $y = \\arccos x \\iff x = \\cos y\\quad (0 \\leq y \\leq \\pi)$ . n10.10 $\\arctan x$ $x$ \u53cd\u6b63\u5207 $y = \\arctan x \\iff x = \\tan y\\quad (-\\pi/2 \\leq y \\leq \\pi/2)$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arctg} x$ . n10.11 $\\operatorname{arccot} x$ $x$ \u53cd\u4f59\u5207 $y = \\operatorname{arccot} x \\iff x = \\cot y\\quad (0 \\leq y \\leq \\pi)$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arcctg} x$ . n10.12 $\\operatorname{arcsec} x$ $x$ \u53cd\u6b63\u5272 $y = \\operatorname{arcsec} x \\iff x = \\sec y\\quad (0\\leq y \\leq \\pi, y\\ne \\pi/2)$ . n10.13 $\\operatorname{arccsc} x$ $x$ \u7684\u53cd\u4f59\u5272 $y = \\operatorname{arccsc} x \\iff x = \\csc y\\quad (-\\pi/2 \\leq y \\leq \\pi/2, y\\ne 0)$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arccosec} x$ . n10.14 $\\sinh x$ $x$ \u7684\u53cc\u66f2\u6b63\u5f26 $\\sinh x=\\dfrac{\\mathrm{e}^x-\\mathrm{e}^{-x}}{2}$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{sh} x$ . n10.15 $\\cosh x$ $x$ \u7684\u53cc\u66f2\u4f59\u5f26 $\\cosh^2 x = \\sinh^2 x + 1$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{ch} x$ . n10.16 $\\tanh x$ $x$ \u7684\u53cc\u66f2\u6b63\u5207 $\\tanh x = \\sinh x/\\cosh x$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{th} x$ . n10.17 $\\coth x$ $x$ \u7684\u53cc\u66f2\u4f59\u5207 $\\coth x = 1/\\tanh x$ . n10.18 $\\operatorname{sech} x$ $x$ \u7684\u53cc\u66f2\u6b63\u5272 $\\operatorname{sech} x = 1/\\cosh x$ . n10.19 $\\operatorname{csch} x$ $x$ \u7684\u53cc\u66f2\u4f59\u5272 $\\operatorname{csch} x = 1/\\sinh x$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{cosech} x$ . n10.20 $\\operatorname{arsinh} x$ $x$ \u7684\u53cd\u53cc\u66f2\u6b63\u5f26 $y = \\operatorname{arsinh} x \\iff x = \\sinh y$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arsh} x$ . n10.21 $\\operatorname{arcosh} x$ $x$ \u7684\u53cd\u53cc\u66f2\u4f59\u5f26 $y = \\operatorname{arcosh} x \\iff x = \\cosh y\\quad (y \\geq 0)$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arch} x$ . n10.22 $\\operatorname{artanh} x$ $x$ \u7684\u53cd\u53cc\u66f2\u6b63\u5207 $y = \\operatorname{artanh} x \\iff x = \\tanh y$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arth} x$ . n10.23 $\\operatorname{arcoth} x$ $x$ \u7684\u53cd\u53cc\u66f2\u4f59\u5207 $y = \\operatorname{arcoth} x \\iff x = \\coth y\\quad (y \\ne 0)$ . n10.24 $\\operatorname{arsech} x$ $x$ \u7684\u53cd\u53cc\u66f2\u6b63\u5272 $y = \\operatorname{arsech} x \\iff x = \\operatorname{sech} y\\quad (y \\geq 0)$ . n10.25 $\\operatorname{arcsch} x$ $x$ \u7684\u53cd\u53cc\u66f2\u4f59\u5272 $y = \\operatorname{arcsch} x \\iff x = \\operatorname{csch} y\\quad (y \\geq 0)$ ; \u4e0d\u53ef\u4f7f\u7528 $\\operatorname{arcosech} x$ .","title":"\u4e09\u89d2\u51fd\u6570\u548c\u53cc\u66f2\u51fd\u6570"},{"location":"intro/symbol.html#_11","text":"\u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n11.1 $\\mathrm{i}$ \u865a\u6570\u5355\u4f4d $\\mathrm{i}^2 = -1$ ; \u4e0d\u53ef\u4f7f\u7528 $i$ \u6216 i n11.2 $\\operatorname{Re} z$ $z$ \u7684\u5b9e\u90e8 \u53c2\u89c1 n11.3. n11.3 $\\operatorname{Im} z$ $z$ \u7684\u865a\u90e8 \u82e5 $z = x + \\mathrm{i} y\\quad (x, y\\in\\mathbf{R})$ , \u5219 $x = \\operatorname{Re} z$ \uff0c $y = \\operatorname{Im} z$ . n11.4 $\\lvert z\\rvert$ $z$ \u7684\u6a21 $\\lvert z\\rvert=\\sqrt{(\\operatorname{Re} z)^2+(\\operatorname{Im} z)^2}$ . n11.5 $\\arg z$ $z$ \u7684\u8f90\u89d2 \u82e5 $z = r \\mathrm{e}^{\\mathrm{i}\\varphi}$ , \u5176\u4e2d $r = \\lvert z\\rvert$ \u4e14 $-\\pi < \\varphi \\leq \\pi$ , \u5219 $\\varphi = \\arg z$ . $\\operatorname{Re} z = r \\cos \\varphi$ \uff0c $\\operatorname{Im} z = r \\sin \\varphi$ . n11.6 $\\bar{z}$ ; $z^*$ $z$ \u7684\u590d\u5171\u8f6d $\\bar{z}=\\operatorname{Re}z-\\mathrm{i}\\operatorname{Im}z$ . n11.7 $\\operatorname{sgn} z$ $z$ \u7684\u5355\u4f4d\u6a21\u51fd\u6570 $\\operatorname{sgn} z =z / \\lvert z\\rvert = \\exp(\\mathrm{i} \\arg z)\\quad (z \\ne 0)$ ; $\\operatorname{sgn} 0 = 0$ ; \u53c2\u89c1 n6.13.","title":"\u590d\u6570"},{"location":"intro/symbol.html#_12","text":"\u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n12.1 $A$ ; \u53c2\u89c1 ^n12.1-ref1 $m\\times n$ \u578b\u77e9\u9635 $A$ $a_{ij} = (A)_{ij}$ ; \u4e5f\u53ef\u4f7f\u7528 $A = (a_{ij})$ . \u5176\u4e2d $m$ \u4e3a\u884c\u6570\uff0c $n$ \u4e3a\u5217\u6570 $m=n$ \u65f6\u79f0\u4e3a\u65b9\u9635 \u53ef\u7528\u65b9\u62ec\u53f7\u66ff\u4ee3\u5706\u62ec\u53f7\u3002 n12.2 $A + B$ \u77e9\u9635 $A$ \u548c $B$ \u7684\u548c $(A + B)_{ij} = (A)_{ij} + (B)_{ij}$ ; \u77e9\u9635 $A$ \u548c $B$ \u7684\u884c\u6570\u548c\u5217\u6570\u5fc5\u987b\u5206\u522b\u76f8\u540c\u3002 n12.3 $x A$ \u6807\u91cf $x$ \u548c\u77e9\u9635 $A$ \u7684\u4e58\u79ef $(x A)_{ij} = x (A)_{ij}$ . n12.4 $AB$ \u77e9\u9635 $A$ \u548c $B$ \u7684\u4e58\u79ef $\\displaystyle(AB)_{ik} = \\sum\\limits_{j}(A)_{ij}(B)_{jk}$ ; \u77e9\u9635 $A$ \u7684\u5217\u6570\u5fc5\u987b\u7b49\u4e8e\u77e9\u9635 $B$ \u7684\u884c\u6570\u3002 n12.5 $I$ ; $E$ \u5355\u4f4d\u77e9\u9635 $(I)_{ik} = \\delta_{ik}$ ; $\\delta_{ik}$ \u7684\u5b9a\u4e49\u53c2\u89c1 n14.9. n12.6 $A^{-1}$ \u65b9\u9635 $A$ \u7684\u9006 $AA^{-1} = A^{-1}A = I\\quad (\\det A \\ne 0)$ . $\\det A$ \u7684\u5b9a\u4e49\u53c2\u89c1 n12.10. n12.7 $A^{\\mathrm{T}}$ ; $A'$ $A$ \u7684\u8f6c\u7f6e\u77e9\u9635 $(A^{\\mathrm{T}})_{ik} = (A)_{ki}$ . n12.8 $\\overline{A}$ ; $A^*$ $A$ \u7684\u590d\u5171\u8f6d\u77e9\u9635 $\\left(\\overline{A}\\right)_{ik}=\\overline{(A)_{ik}}$ . n12.9 $A^{\\mathrm{H}}$ ; $A^{\\dagger}$ $A$ \u7684 Hermite \u5171\u8f6d\u77e9\u9635 $A^{\\mathrm{H}} = \\left(\\overline{A}\\right)^{\\mathrm{T}}$ . n12.10 $\\det A$ ; \u53c2\u89c1 [^n12.10-ref1] \u65b9\u9635 $A$ \u7684\u884c\u5217\u5f0f \u4e5f\u53ef\u4f7f\u7528 $\\lvert A\\rvert$ . n12.11 $\\operatorname{rank}A$ \u77e9\u9635 $A$ \u7684\u79e9 n12.12 $\\operatorname{tr}A$ \u65b9\u9635 $A$ \u7684\u8ff9 $\\displaystyle\\operatorname{tr}A=\\sum\\limits_{i}(A)_{ii}$ . n12.13 $\\lVert A\\rVert$ \u77e9\u9635 $A$ \u7684\u8303\u6570 \u6ee1\u8db3\u4e09\u89d2\u4e0d\u7b49\u5f0f\uff1a\u82e5 $A + B = C$ , \u5219 $\\lVert A\\rVert+\\lVert B\\rVert \\geq \\lVert C\\rVert$ . [^n12.10-ref1]: $\\begin{vmatrix}a_{11}&\\cdots&a_{1n}\\\\\\vdots& &\\vdots\\\\a_{n1}&\\cdots&a_{nn}\\end{vmatrix}$","title":"\u77e9\u9635"},{"location":"intro/symbol.html#_13","text":"\u672c\u8282\u8003\u8651\u4e09\u7ef4\u7a7a\u95f4\u4e2d\u7684\u4e00\u4e9b\u5750\u6807\u7cfb\u3002\u70b9 $\\mathrm{O}$ \u4e3a\u5750\u6807\u7cfb\u7684 \u539f\u70b9 \u3002\u4efb\u610f\u70b9 $\\mathrm{P}$ \u5747\u7531\u4ece\u539f\u70b9 $\\mathrm{O}$ \u5230\u70b9 $\\mathrm{P}$ \u7684 \u4f4d\u7f6e\u5411\u91cf \u786e\u5b9a\u3002 \u7f16\u53f7 \u5750\u6807 \u4f4d\u7f6e\u5411\u91cf\u548c\u5fae\u5206 \u5750\u6807\u540d \u5907\u6ce8 n13.1 $x$ \uff0c $y$ \uff0c $z$ $\\boldsymbol{r} = x \\boldsymbol{e}_x + y \\boldsymbol{e}_y + z \\boldsymbol{e}_z$ ; $\\mathrm{d}\\boldsymbol{r} = \\mathrm{d}x~\\boldsymbol{e}_x + \\mathrm{d}y~\\boldsymbol{e}_y + \\mathrm{d}z~\\boldsymbol{e}_z$ \u7b1b\u5361\u5c14\u5750\u6807 \u57fa\u5411\u91cf $\\boldsymbol{e}_x$ \uff0c $\\boldsymbol{e}_y$ \uff0c $\\boldsymbol{e}_z$ \u6784\u6210\u53f3\u624b\u6b63\u4ea4\u7cfb\uff0c\u89c1\u56fe 1 \u548c\u56fe 4\u3002 \u57fa\u5411\u91cf\u4e5f\u53ef\u7528 $\\boldsymbol{e}_1$ \uff0c $\\boldsymbol{e}_2$ \uff0c $\\boldsymbol{e}_3$ \u6216 $\\boldsymbol{i}$ \uff0c $\\boldsymbol{j}$ \uff0c $\\boldsymbol{k}$ \u8868\u793a\uff0c\u5750\u6807\u4e5f\u53ef\u7528 $x_1$ \uff0c $x_2$ \uff0c $x_3$ \u6216 $i$ \uff0c $j$ \uff0c $k$ \u8868\u793a\u3002 n13.2 $\\rho$ \uff0c $\\varphi$ \uff0c $z$ $\\boldsymbol{r} = \\rho~\\boldsymbol{e}_{\\rho} + z~\\boldsymbol{e}_z$ ; $\\mathrm{d}\\boldsymbol{r} = \\mathrm{d}\\rho~\\boldsymbol{e}_{\\rho} +\\rho~\\mathrm{d}\\varphi~\\boldsymbol{e}_{\\varphi} + \\mathrm{d}z~\\boldsymbol{e}_z$ \u67f1\u5750\u6807 $\\boldsymbol{e}_{\\rho}(\\varphi)$ \uff0c $\\boldsymbol{e}_{\\varphi}(\\varphi)$ \uff0c $\\boldsymbol{e}_z$ \u7ec4\u6210\u53f3\u624b\u6b63\u4ea4\u7cfb\uff0c\u89c1\u56fe 2\u3002 \u82e5 $z = 0$ , \u5219 $\\rho$ \u548c $\\varphi$ \u662f\u5e73\u9762\u4e0a\u7684\u6781\u5750\u6807\u3002 n13.3 $r$ \uff0c $\\vartheta$ \uff0c $\\varphi$ $\\boldsymbol{r} = r \\boldsymbol{e}_r$ ; $\\mathrm{d}\\boldsymbol{r} = \\mathrm{d}r~\\boldsymbol{e}_r + r~\\mathrm{d}\\vartheta~\\boldsymbol{e}_{\\vartheta} + r~\\sin\\vartheta~\\mathrm{\\mathrm{d}}\\varphi~\\boldsymbol{e}_{\\varphi}$ \u7403\u5750\u6807 $\\boldsymbol{e}_r(\\vartheta, \\varphi)$ \uff0c $\\boldsymbol{e}_{\\vartheta}(\\vartheta, \\varphi)$ \uff0c $\\boldsymbol{e}_{\\varphi}(\\varphi)$ \u7ec4\u6210\u53f3\u624b\u6b63\u4ea4\u7cfb\uff0c\u89c1\u56fe 3\u3002 \u5982\u679c\u4e0d\u4f7f\u7528\u53f3\u624b\u5750\u6807\u7cfb\uff08\u89c1\u56fe 4\uff09\uff0c\u800c\u4f7f\u7528\u5de6\u624b\u5750\u6807\u7cfb\uff08\u89c1\u56fe 5\uff09\uff0c\u5219\u5e94\u5728\u4e4b\u524d\u660e\u786e\u5f3a\u8c03\uff0c\u4ee5\u514d\u7b26\u53f7\u8bef\u7528\u3002 \u56fe 1 \u53f3\u624b\u7b1b\u5361\u5c14\u5750\u6807\u7cfb \u56fe 2 \u53f3\u624b\u67f1\u5750\u6807\u7cfb \u56fe 3 \u53f3\u624b\u7403\u5750\u6807\u7cfb \u56fe 4 \u53f3\u624b\u5750\u6807\u7cfb \u56fe 5 \u5de6\u624b\u5750\u6807\u7cfb","title":"\u5750\u6807\u7cfb"},{"location":"intro/symbol.html#_14","text":"\u672c\u8282\u4e2d\uff0c\u57fa\u5411\u91cf\u7528 $\\boldsymbol{e}_1$ \uff0c $\\boldsymbol{e}_2$ \uff0c $\\boldsymbol{e}_3$ \u8868\u793a\u3002\u672c\u8282\u4e2d\u7684\u8bb8\u591a\u6982\u5ff5\u90fd\u53ef\u4ee5\u63a8\u5e7f\u5230 $n$ \u7ef4\u7a7a\u95f4\u3002 \u6807\u91cf\u548c\u5411\u91cf\u672c\u8eab\u4e0e\u5750\u6807\u7cfb\u7684\u9009\u62e9\u65e0\u5173\uff0c\u800c\u5411\u91cf\u7684\u6bcf\u4e2a\u6807\u91cf\u5206\u91cf\u4e0e\u5750\u6807\u7cfb\u7684\u9009\u62e9\u6709\u5173\u3002 \u5bf9\u4e8e\u57fa\u5411\u91cf $\\boldsymbol{e}_1$ \uff0c $\\boldsymbol{e}_2$ \uff0c $\\boldsymbol{e}_3$ , \u6bcf\u4e2a\u5411\u91cf $\\boldsymbol{a}$ \u90fd\u53ef\u4ee5\u8868\u793a\u4e3a $\\boldsymbol{a}=a_1\\boldsymbol{e}_1+a_2\\boldsymbol{e}_2+a_3\\boldsymbol{e}_3$ , \u5176\u4e2d $a_1$ \uff0c $a_2$ \u548c $a_3$ \u662f\u552f\u4e00\u786e\u5b9a\u7684\u6807\u91cf\u503c\uff0c\u5c06\u5176\u79f0\u4e3a\u5411\u91cf\u76f8\u5bf9\u4e8e\u8be5\u7ec4\u57fa\u5411\u91cf\u7684 \"\u5750\u6807\"\uff0c $a_1\\boldsymbol{e}_1$ \uff0c $a_2\\boldsymbol{e}_2$ \u548c $a_3\\boldsymbol{e}_3$ \u79f0\u4e3a\u5411\u91cf\u76f8\u5bf9\u4e8e\u8be5\u7ec4\u57fa\u5411\u91cf\u7684\u5206\u5411\u91cf\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u53ea\u8003\u8651\u666e\u901a\u7a7a\u95f4\u7684\u7b1b\u5361\u5c14\uff08\u6b63\u4ea4\uff09\u5750\u6807\u3002\u7b1b\u5361\u5c14\u5750\u6807\u7528 $x$ \uff0c $y$ \uff0c $z$ \u6216 $a_1$ \uff0c $a_2$ \uff0c $a_3$ \u6216 $x_1$ \uff0c $x_2$ \uff0c $x_3$ \u8868\u793a\u3002 \u672c\u8282\u6240\u6709\u4e0b\u6807 $i$ \uff0c $j$ \uff0c $k$ \u7684\u8303\u56f4\u5747\u4e3a $1$ \u5230 $3$ . \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n14.1 $\\boldsymbol{a}$ ; $\\vec{a}$ \u5411\u91cf $\\boldsymbol{a}$ n14.2 $\\boldsymbol{a} + \\boldsymbol{b}$ \u5411\u91cf $\\boldsymbol{a}$ \u548c $\\boldsymbol{b}$ \u7684\u548c $(\\boldsymbol{a} + \\boldsymbol{b})_i = a_i + b_i$ . n14.3 $x\\boldsymbol{a}$ \u6807\u91cf $x$ \u4e0e\u5411\u91cf $\\boldsymbol{a}$ \u7684\u4e58\u79ef $(x\\boldsymbol{a})_i = xa_i$ . n14.4 $\\lvert \\boldsymbol{a}\\rvert$ \u5411\u91cf $\\boldsymbol{a}$ \u7684\u5927\u5c0f\uff0c\u5411\u91cf $\\boldsymbol{a}$ \u7684\u8303\u6570 $\\lvert \\boldsymbol{a}\\rvert=\\sqrt{a_x^2+a_y^2+a_z^2}$ ; \u4e5f\u53ef\u4f7f\u7528 $\\lVert a\\rVert$ . n14.5 $\\boldsymbol{0}$ ; $\\vec{0}$ \u96f6\u5411\u91cf \u96f6\u5411\u91cf\u7684\u5927\u5c0f\u4e3a $0$ . n14.6 $\\boldsymbol{e_a}$ $\\boldsymbol{a}$ \u65b9\u5411\u7684\u5355\u4f4d\u5411\u91cf $\\boldsymbol{e_a} = \\boldsymbol{a}/\\lvert\\boldsymbol{a}\\rvert\\quad (\\boldsymbol{a}\\ne \\boldsymbol{0})$ . n14.7 $\\boldsymbol{e}_x$ \uff0c $\\boldsymbol{e}_y$ \uff0c $\\boldsymbol{e}_z$ ; $\\boldsymbol{e}_1$ \uff0c $\\boldsymbol{e}_2$ \uff0c $\\boldsymbol{e}_3$ \u7b1b\u5361\u5c14\u5750\u6807\u8f74\u65b9\u5411\u7684\u5355\u4f4d\u5411\u91cf \u4e5f\u53ef\u4f7f\u7528 $\\boldsymbol{i}$ \uff0c $\\boldsymbol{j}$ \uff0c $\\boldsymbol{k}$ . n14.8 $a_x$ \uff0c $a_y$ \uff0c $a_z$ ; $a_i$ \u5411\u91cf $\\boldsymbol{a}$ \u7684\u7b1b\u5361\u5c14\u5206\u91cf $\\boldsymbol{a} = a_x \\boldsymbol{e}_x + a_y \\boldsymbol{e}_y + a_z \\boldsymbol{e}_z$ ; \u5982\u679c\u4e0a\u4e0b\u6587\u786e\u5b9a\u4e86\u57fa\u5411\u91cf\uff0c\u5219\u5411\u91cf\u53ef\u4ee5\u5199\u4e3a $\\boldsymbol{a} = (a_x, a_y, a_z)$ . $a_x = \\boldsymbol{a}\\cdot \\boldsymbol{e}_x$ \uff0c $a_y = \\boldsymbol{a}\\cdot \\boldsymbol{e}_y$ \uff0c $a_z = \\boldsymbol{a}\\cdot \\boldsymbol{e}_z$ ; $\\boldsymbol{r} = x\\boldsymbol{e}_x + y\\boldsymbol{e}_y + z\\boldsymbol{e}_z$ \u662f\u5750\u6807\u4e3a $x$ \uff0c $y$ \uff0c $z$ \u7684\u4f4d\u7f6e\u5411\u91cf\u3002 n14.9 $\\delta_{ik}$ Kronecker delta \u7b26\u53f7 $\\delta_{ik}=1\\quad (i=k)$ ; $\\delta_{ik}=0\\quad (i\\ne k)$ . n14.10 $\\varepsilon_{ijk}$ Levi-Civita \u7b26\u53f7 $\\varepsilon_{123} = \\varepsilon_{231} = \\varepsilon_{312} = 1$ ; $\\varepsilon_{132} = \\varepsilon_{321} = \\varepsilon_{213} = -1$ ; \u5176\u4f59\u7684 $\\varepsilon_{ijk}$ \u5747\u4e3a $0$ . n14.11 $\\boldsymbol{a}\\cdot\\boldsymbol{b}$ \u5411\u91cf $\\boldsymbol{a}$ \u548c $\\boldsymbol{b}$ \u7684\u6807\u91cf\u79ef/\u5185\u79ef $\\displaystyle\\boldsymbol{a}\\cdot\\boldsymbol{b}=\\sum\\limits_i a_ib_i$ . n14.12 $\\boldsymbol{a}\\times\\boldsymbol{b}$ \u5411\u91cf $\\boldsymbol{a}$ \u548c $\\boldsymbol{b}$ \u7684\u5411\u91cf\u79ef/\u5916\u79ef \u53f3\u624b\u7b1b\u5361\u5c14\u5750\u6807\u7cfb\u4e2d\uff0c $\\displaystyle (\\boldsymbol{a}\\times\\boldsymbol{b})_i = \\sum\\limits_j\\sum\\limits_k\\varepsilon_{ijk}a_jb_k$ ; $\\varepsilon_{ijk}$ \u7684\u5b9a\u4e49\u53c2\u89c1 n14.10. n14.13 $\\mathbf{\\nabla}$ nabla \u7b97\u5b50 $\\displaystyle \\mathbf{\\nabla} = \\boldsymbol{e}_x\\frac{\\partial}{\\partial x}+\\boldsymbol{e}_y\\frac{\\partial}{\\partial y}+\\boldsymbol{e}_z\\frac{\\partial}{\\partial z}=\\sum\\limits_i\\boldsymbol{e}_i\\frac{\\partial}{\\partial x_i}$ . n14.14 $\\mathbf{\\nabla}\\varphi$ ; $\\operatorname{\\mathbf{grad}}\\varphi$ $\\varphi$ \u7684\u68af\u5ea6 $\\displaystyle \\mathbf{\\nabla}\\varphi=\\sum\\limits_i\\boldsymbol{e}_i\\frac{\\partial\\varphi}{\\partial x_i}$ ; $\\operatorname{\\mathbf{grad}}$ \u5e94\u4f7f\u7528 \\operatorname{\\mathbf{grad}} . n14.15 $\\mathbf{\\nabla}\\cdot\\boldsymbol{a}$ ; $\\operatorname{\\mathbf{div}}\\boldsymbol{a}$ $\\boldsymbol{a}$ \u7684\u6563\u5ea6 $\\displaystyle \\mathbf{\\nabla}\\cdot\\boldsymbol{a}=\\sum\\limits_i\\frac{\\partial a_i}{\\partial x_i}$ ; $\\operatorname{\\mathbf{div}}$ \u5e94\u4f7f\u7528 \\operatorname{\\mathbf{div}} . n14.16 $\\mathbf{\\nabla}\\times\\boldsymbol{a}$ ; $\\operatorname{\\mathbf{rot}}\\boldsymbol{a}$ $\\boldsymbol{a}$ \u7684\u65cb\u5ea6 $\\displaystyle (\\mathbf{\\nabla}\\times\\boldsymbol{a})_i=\\sum\\limits_j\\sum\\limits_k\\varepsilon_{ijk}\\frac{\\partial a_k}{\\partial x_j}$ ; $\\operatorname{\\mathbf{rot}}$ \u5e94\u4f7f\u7528 \\operatorname{\\mathbf{rot}} . \u4e0d\u5e94\u4f7f\u7528 $\\operatorname{\\mathbf{curl}}$ . $\\varepsilon_{ijk}$ \u7684\u5b9a\u4e49\u53c2\u89c1 n14.10. n14.17 $\\mathbf{\\nabla}^2$ ; $\\Delta$ Laplace \u7b97\u5b50 $\\mathbf{\\nabla}^2=\\dfrac{\\partial^2}{\\partial x^2}+\\dfrac{\\partial^2}{\\partial y^2}+\\dfrac{\\partial^2}{\\partial z^2}$ .","title":"\u6807\u91cf\u548c\u5411\u91cf"},{"location":"intro/symbol.html#_15","text":"\u672c\u8282\u4e2d\u7684 $z$ \uff0c $w$ \u662f\u590d\u6570\uff0c $k$ \uff0c $n$ \u662f\u81ea\u7136\u6570\uff0c\u4e14 $k\\leq n$ \u3002 \u7f16\u53f7 \u7b26\u53f7\uff0c\u8868\u8fbe\u5f0f \u610f\u4e49\uff0c\u7b49\u540c\u8868\u8ff0 \u5907\u6ce8\u4e0e\u793a\u4f8b n15.1 $\\gamma$ Euler\u2013Mascheroni \u5e38\u6570 $\\displaystyle \\gamma=\\lim\\limits_{n\\to\\infty}\\left(\\sum\\limits_{k=1}^n\\frac{1}{k}-\\ln n\\right)= 0.577~215~6 \\dots$ . n15.2 $\\Gamma(z)$ gamma \u51fd\u6570 $\\displaystyle\\Gamma(z)=\\int\\limits_0^{\\infty}t^{z-1}\\mathrm{e}^{-t}\\mathrm{d}t\\quad (\\operatorname{Re}z>0)$ ; $\\Gamma(n+1)=n!$ . n15.3 $\\zeta(z)$ Riemann zeta \u51fd\u6570 $\\displaystyle\\zeta(z)=\\sum\\limits_{n=1}^{\\infty}\\frac{1}{n^z}\\quad (\\operatorname{Re}z>1)$ . n15.4 $\\operatorname{B}(z, w)$ beta \u51fd\u6570 $\\displaystyle\\operatorname{B}(z, w)=\\int\\limits_0^1 t^{z-1}(1-t)^{w-1}\\mathrm{d}t\\quad (\\operatorname{Re} z>0$ \uff0c $\\operatorname{Re} w>0)$ ; $\\operatorname{B}(z, w)=\\dfrac{\\Gamma(z)\\Gamma(w)}{\\Gamma(z+w)}$ ; $\\dfrac{1}{(n+1)\\operatorname{B}(k+1, n-k+1)}=\\dbinom{n}{k}$ .","title":"\u7279\u6b8a\u51fd\u6570"},{"location":"intro/thanks.html","text":"\u672c\u9879\u76ee\u76ee\u524d\u6682\u4e0d\u63a5\u53d7\u6350\u8d60\u3002 \u6240\u6709\u6b3e\u9879\u5c06\u88ab\u7528\u4e8e OI Wiki \u7684\u57df\u540d\u3001\u670d\u52a1\u5668\u3001\u8fd0\u7ef4\u7b49\u5fc5\u9700\u652f\u51fa\u3002 \u5927\u989d\u6350\u8d60\u5c06\u4f1a\u8bb0\u5f55\u5728\u672c\u9875\u9762\u4e0b\u65b9\u6216\u65e5\u540e\u66f4\u5408\u9002\u7684\u4f4d\u7f6e\u6765\u8868\u793a\u611f\u8c22\u3002 id amount date \u533f\u540d\u6350\u8d60\u8005 10 \u5143 2021.6.20 \u533f\u540d\u6350\u8d60\u8005 100 \u5143 2021.6.10 wood3 256 \u5143 2021.6.4 \u6d77\u5916\u5154 102 \u5143 2021.5.12 \u9010\u68a6\u4e4b\u4eba 80.7 \u5143 2021.5.3 \u5341\u5bf8\u96e8 zsg 10.24 \u5143 2021.2.27 \u533f\u540d\u6350\u8d60\u8005 2 \u5143 2020.12.10 \u543e\u6709\u4e00\u6578\u540d\u4e4b\u66f0\u8a92 10.24 \u5143 2020.10.19 Huah 66 \u5143 2020.9.7 icedream61 66 \u5143 2020.9.2 \u4e09\u9e3d\u9178\u9e3d\u53ef\u7231 2.33 \u5143 2020.8.31 Apoi2333 23.33 \u5143 2020.8.31 \u8349\u8393\u718a 50 \u5143 2020.7.4 \u533f\u540d\u6350\u8d60\u8005 200 \u5143 2020.6.29 Hiroid 30 \u5143 2020.5.13 dcmfqw 20.48 \u5143 2020.5.4 akira 66 \u5143 2020.3.30 Hermione 10 \u5143 2020.3.26 Siyuan 10 \u5143 2020.2.28 hsh 15 \u5143 2020.2.21 \u964c\u964c 10 \u5143 2020.2.6 \u533f\u540d\u6350\u8d60\u8005 10 \u5143 2020.2.5 Yisin 10 \u5143 2020.2.4 GinRyan 50 \u5143 2019.11.30 JuicyMio 10 \u5143 2019.11.30 \u533f\u540d\u6350\u8d60\u8005 10 \u5143 2019.11.14 QQ \u8054\u7cfb 12 5 \u5143 2019.10.28 \u533f\u540d\u6350\u8d60\u8005 5 \u5143 2019.10.27 \u589e\u80a5\u4e2d\u7684\u5c0f\u80a5 50 \u5143 2019.10.24 ianahao 10 \u5143 2019.10.12 Sundy 10 \u5143 2019.10.11 \u4e09\u9e3d\u6700\u53ef\u7231 23.33 \u5143 2019.8.17 Fburan 10.24 \u5143 2019.8.17 \u533f\u540d\u6350\u8d60\u8005 30 \u5143 2019.8.8 Billchenchina 100 \u5143 2019.8.7 \u8d37\u6b3e\u6350\u5934\u7684\u533f\u540d\u5165\u571f 30 \u5143 2019.8.4 sshwy 50 \u5143 2019.8.4 \u533f\u540d\u6350\u8d60\u8005 10 \u5143 2018.9.9 \u533f\u540d\u6350\u8d60\u8005 20 \u5143 2018.8.31 Xeonacid 30 \u5143 2018.8.30 \u533f\u540d\u6350\u8d60\u8005 240 \u5143 2018.8.29 Anguei 5 \u5143 2018.8.29","title":"Thanks"},{"location":"intro/what-oi-wiki-is-not.html","text":"\u6ce8\u610f \u4f5c\u4e3a\u9879\u76ee\u65b9\u9488\u7684\u4e00\u90e8\u5206\uff0c\u672c\u9875\u9762\u5341\u5206\u91cd\u8981\uff0c\u6bcf\u4e2a\u8d21\u732e\u8005\u90fd\u5e94\u786e\u4fdd\u60a8\u7684\u8d21\u732e\u6ee1\u8db3\u5982\u4e0b\u6761\u4ef6\u3002 OI Wiki \u4e0d\u662f\u53d1\u8868\u539f\u521b\u7814\u7a76\u7684\u573a\u6240 \u00b6 \u4f5c\u4e3a\u4e00\u4e2a Wiki\uff0c OI Wiki \u4e0d\u662f\u53d1\u8868 \u539f\u521b\u7814\u7a76 \uff08\u5982 \u65b0\u7406\u8bba\u53ca\u89e3\u6cd5 \u3001 \u539f\u521b\u89c2\u70b9 \u3001 \u81ea\u521b\u5b9a\u4e49\u6216\u8bcd\u8bed \u7b49\uff09\u7684\u573a\u6240\u3002\u4f8b\u5982\uff1a \u60a8\u53d1\u73b0\u4e86\u67d0\u9898\u76ee\u7684\u975e\u5e38\u89c4\u505a\u6cd5\uff0c\u82e5\u60a8\u4e0d\u80fd\u8bc1\u660e\u8be5\u505a\u6cd5\u5df2\u7ecf\u88ab\u5e94\u7528\u4e8e\u5176\u4ed6\u9898\u76ee\u4e2d\uff0c\u5219 \u4e0d\u5e94 \u5728 OI Wiki \u4e2d\u5f00\u8bbe\u5355\u72ec\u7684\u754c\u9762\u3002 \u60a8\u63d0\u51fa\u4e86\u65b0\u7684\u7b97\u6cd5\u6216\u6570\u636e\u7ed3\u6784\uff0c\u82e5\u60a8\u4e0d\u80fd\u8bc1\u660e\u8be5\u5185\u5bb9\u5df2\u7ecf\u88ab\u7528\u4e8e\u89e3\u51b3\u7f16\u7a0b\u7ade\u8d5b\u4e2d\u7684\u67d0\u4e00\u7c7b\u95ee\u9898\uff0c\u5219 \u4e0d\u5e94 \u5c06\u5176\u63d0\u4ea4\u81f3 OI Wiki \u3002 OI Wiki \u4e0d\u662f\u65b0\u95fb\u7684\u6536\u96c6\u5904 \u00b6 \u4f5c\u4e3a\u6cdb\u4e2d\u6587\u4e3a\u4e3b\u8bed\u5883\u4e4b\u4e0b\u3001\u4ee5\u7f16\u7a0b\u7ade\u8d5b\u76f8\u5173\u5185\u5bb9\u4e3a\u4e3b\u7684\u77e5\u8bc6\u6574\u5408\u7ad9\u70b9\uff0c OI Wiki \u4fa7\u91cd\u4e8e\u63d0\u4f9b \u7a33\u5b9a\u6c89\u6dc0\u5e76\u5df2\u53d6\u5f97\u5e7f\u6cdb\u8ba4\u53ef \u7684\u4fe1\u606f\u3002 \u6362\u8a00\u4e4b\uff0c\u9664\u975e\u662f\u6743\u5a01\u673a\u6784\u53d1\u5e03\u7684\u4fe1\u606f\uff08\u5982\u4e2d\u56fd\u8ba1\u7b97\u673a\u534f\u4f1a\u53d1\u5e03\u7684\u8d5b\u5236\u66f4\u65b0\uff09\uff0c\u60a8\u6240\u8d21\u732e\u7684\u5185\u5bb9\u5e94\u5f53\u662f\u5df2\u7ecf\u7ecf\u8fc7\u68c0\u9a8c\u6c89\u6dc0\uff0c\u83b7\u5f97\u4e86\u5e7f\u6cdb\u8ba4\u53ef\uff0c\u4e14\u5728\u4e00\u6bb5\u65f6\u95f4\u5185\u4e0d\u4f1a\u4ea7\u751f\u65f6\u6548\u6027\u95ee\u9898\u7684\u4fe1\u606f\u3002\u4f8b\u5982\uff1a \u60a8\u53d1\u73b0 X \u535a\u58eb\u5728\u67d0\u4e2a\u4f4d\u7f6e\u53d1\u5e03\u4e86\u65b0\u7684\u7b97\u6cd5\uff0c\u82e5\u60a8\u60f3\u5c06\u5176\u52a0\u5165 OI Wiki \u4e2d\uff0c\u6b64\u65f6\u60a8\u5e94\u8be5\u89c2\u5bdf\u5176\u662f\u5426\u80fd\u83b7\u5f97\u5e7f\u6cdb\u8ba4\u53ef\uff08\u5982\u53ef\u4f5c\u4e3a\u6b63\u5f0f\u6bd4\u8d5b\u4e2d\u7684\u6cdb\u7528\u4f18\u79c0\u89e3\u6cd5\uff09\uff0c\u4e14\u4e0e OI Wiki \u4e2d\u73b0\u5b58\u7684\u7b97\u6cd5\u6709\u4e00\u5b9a\u7684\u533a\u5206\u6027\u3002 \u60a8\u53d1\u73b0 OI Wiki \u4e2d\u63d0\u5230\u7684\u67d0\u8f6f\u4ef6\u6216\u4eba\u7269\u51fa\u73b0\u4e86\u8206\u60c5\u95ee\u9898\uff0c\u6b64\u65f6\u8bf7\u60a8\u5173\u6ce8\u8bc4\u8bba\u533a\u7b49\u7684\u76f8\u5173\u516c\u544a\uff0c\u5207\u52ff\u91cd\u590d\u5f00 issue \u7b49\u8bf4\u660e\u95ee\u9898\u3002 OI Wiki \u7684\u76ee\u7684\u5728\u4e8e\u8bb0\u8f7d \u53ef\u957f\u4e45\u6d41\u4f20\u7684\u4fe1\u606f \uff0c\u800c\u4e0d\u662f \u5e26\u6709\u65f6\u6548\u6027\u7684\u4e34\u65f6\u4fe1\u606f \u3002 OI Wiki \u4e0d\u662f\u6863\u6848\u9986 \u00b6 OI Wiki \u4e3b\u7ad9\u4e0d\u4f1a\u6536\u5f55\u5404\u7c7b \u6587\u732e \u3001 \u8bfe\u4ef6 \u3001 \u8bb2\u4e49 \u3001 \u8bf4\u660e\u4e66 \u7b49\u8d44\u6599\uff0c\u82e5\u60a8\u60f3\u63d0\u4ea4\u6709\u5173\u7f16\u7a0b\u7ade\u8d5b\u7684\u8d44\u6599\uff0c\u8bf7\u79fb\u6b65\u81f3 OI-wiki/libs \u3002 OI Wiki \u4e0d\u662f\u5ba3\u4f20\u5de5\u5177 \u00b6 OI Wiki \u662f\u4e00\u4e2a\u77e5\u8bc6\u6574\u5408\u7ad9\u70b9\uff0c \u4e0d\u662f \u6f14\u8bb2\u53f0\u3001\u8bba\u575b\u3001\u5ba3\u4f20\u5de5\u5177\u7b49\uff0c\u56e0\u6b64\u5728\u6dfb\u52a0\u6216\u4fee\u6539\u6761\u76ee\u65f6\uff0c\u8bf7\u52ff\uff1a \u53d1\u8868\u89c2\u70b9\u6216\u8bc4\u8bba\uff1a OI Wiki \u7684\u5185\u5bb9\u5fc5\u987b \u5ba2\u89c2\u4e2d\u7acb \uff0c\u5982\u679c\u60a8\u60f3\u8981\u53d1\u8868\u4e0e OI Wiki \u6709\u5173\u7684\u89c2\u70b9\u4e0e\u8bc4\u8bba\uff0c\u8bf7\u79fb\u6b65\u81f3\u8bc4\u8bba\u533a\u6216 issue \u9875\u9762\u3002\u5982\u679c\u60a8\u60f3\u8981\u53d1\u8868\u7684\u89c2\u70b9\u4e0e\u8bc4\u8bba\u4e0e OI Wiki \u65e0\u5173\uff0c\u8bf7\u79fb\u6b65\u81f3\u4e2a\u4eba\u535a\u5ba2\u6216\u8bba\u575b\uff1b \u4f5c\u4efb\u4f55\u5f62\u5f0f\u7684\u5ba3\u4f20\u884c\u4e3a\uff1a\u51fa\u4e8e\u77e5\u8bc6\u6536\u5f55\u9700\u8981\uff0c OI Wiki \u53ef\u4ee5\u63a5\u53d7\u5bf9\u300c\u5728\u7f16\u7a0b\u7ade\u8d5b\u9886\u57df\u5df2\u7ecf \u5e7f\u4e3a\u4eba\u77e5 \u7684\u7f51\u7ad9\u6216\u8f6f\u4ef6\u300d\u7684\u4ecb\u7ecd\u3002\u9664\u6b64\u4e4b\u5916\uff0c OI Wiki \u4e0d\u4f1a\u63a5\u53d7\u4efb\u4f55\u975e\u8d5e\u52a9\u5546\u63d0\u4f9b\u7684\u4efb\u4f55\u5ba3\u4f20\u6027\u8d28\u7684\u5185\u5bb9\u3002 OI Wiki \u4e0d\u662f\u6743\u5a01\u673a\u6784 \u00b6 \u4f5c\u4e3a\u4e00\u4e2a\u4e3b\u8981\u4f9d\u9760\u7528\u6237\u8d21\u732e\u7684\u793e\u533a\u9879\u76ee\uff0c OI Wiki \u4e0d\u5177\u6709\u6743\u5a01\u6027\uff0c\u4e0d\u5e94\u4e5f\u6ca1\u6709\u80fd\u529b\u4f5c\u4e3a\u4e00\u4e2a\u6743\u5a01\u673a\u6784\u3002 OI Wiki \u53ef\u4ee5\u4f5c\u4e3a\u5b66\u4e60\u7f16\u7a0b\u7ade\u8d5b\u76f8\u5173\u77e5\u8bc6\u7684\u53c2\u8003\uff0c\u800c\u4e0d\u662f\u6807\u51c6\u6559\u79d1\u4e66\u3002\u4f5c\u4e3a\u4e00\u4e2a\u793e\u533a\u7ef4\u62a4\u7684\u53c2\u8003\u7ad9\u70b9\uff0c\u60a8\u4e0d\u5e94\u5c06 OI Wiki \u7528\u4f5c\u6700\u7ec8\u7684\u6743\u5a01\u6807\u51c6\uff08\u5982\u4f5c\u4e3a\u7f16\u7a0b\u7ade\u8d5b\u7684\u300c\u8003\u7eb2\u300d\uff09\uff0c\u4e5f\u4e0d\u5e94\u76f2\u76ee\u91c7\u4fe1\u6240\u6709 OI Wiki \u7684\u5185\u5bb9\u3002 OI Wiki \u4e0d\u5bf9\u7531\u4f7f\u7528 OI Wiki \u7684\u5185\u5bb9\u800c\u4ea7\u751f\u7684\u4efb\u4f55\u540e\u679c\u8d1f\u8d23\u3002 OI Wiki \u4e0d\u662f\u4e2a\u4eba\u535a\u5ba2 \u00b6 OI Wiki \u57fa\u4e8e\u300cWiki\u300d\u4e00\u8bcd\uff0c\u672c\u8d28\u4e0a\u662f\u4f9d\u9760\u7528\u6237 \u534f\u540c\u7f16\u8f91\u5185\u5bb9 \u7684\u793e\u533a\u3002\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u60a8\u6240\u63d0\u4f9b\u7684\u5185\u5bb9\u5e94\u5f53 \u5c3d\u91cf\u51cf\u8f7b\u4e2a\u4eba\u8272\u5f69 \uff0c\u670d\u52a1\u4e8e\u6574\u4e2a Wiki\uff0c\u5173\u6ce8\u60a8\u6240\u8d21\u732e\u7684\u76f8\u5173\u8bcd\u6761\u7684\u7ed3\u6784\u3002\u5207\u52ff\u4ee5\u64b0\u5199\u4e2a\u4eba\u535a\u5ba2\u6587\u7ae0\u7684\u601d\u7ef4\u5bf9\u5f85 Wiki \u4e2d\u7684\u6761\u76ee\u3002\u4f8b\u5982\uff1a \u60a8 \u4e0d\u5e94 \u5c06 OI Wiki \u4f5c\u4e3a\u60a8\u4e2a\u4eba\u535a\u5ba2\u7684\u5bfc\u822a\u7ad9\u70b9\uff1b \u60a8 \u4e0d\u5e94 \u5728\u8bcd\u6761\u7684\u63cf\u8ff0\u4e2d\u52a0\u5165\u6761\u76ee\u5386\u53f2\u3001\u4e2a\u4eba\u5410\u69fd\u3001\u51b7\u7b11\u8bdd\u7b49\u65e0\u5173\u5185\u5bb9\u3002 \u4ee5\u4e0a\u4f8b\u5b50\u7684\u53cd\u9762\u5747\u4e3a\u64b0\u5199\u4e2a\u4eba\u535a\u5ba2\u65f6\u7684\u5e38\u89c1\u601d\u7ef4\uff0c\u800c\u8fd9\u4e9b\u5728\u63d0\u5021\u5ba2\u89c2\u4e2d\u7acb\u7684 OI Wiki \u4e2d\u662f\u4e0d\u53d7\u6b22\u8fce\u7684\u3002 OI Wiki \u4e0d\u662f\u8bd1\u540d\u6807\u51c6\u59d4\u5458\u4f1a \u00b6 OI Wiki \u7684\u76ee\u6807\u7fa4\u4f53\u4e0d\u662f\u5386\u53f2\u5b66\u5bb6\u53ca\u8bed\u8a00\u5b66\u5bb6\uff0c\u56e0\u6b64\u5728\u5916\u6587\u540d\u8bcd\u7684\u7ffb\u8bd1\u4e2d\uff0c OI Wiki \u503e\u5411\u4e8e\u4f7f\u7528\u4e2d\u6587\u8bed\u5883\u4e0b \u5df2\u7ecf\u83b7\u5f97\u4e86\u5e7f\u6cdb\u8ba4\u540c \u7684\u8bd1\u6587\uff0c\u5373\u4f7f\u5b83\u4eec\u53ef\u80fd\u662f\u6709\u7455\u75b5\u7684\u3002 \u5728\u8bd1\u6587\u5df2\u7ecf\u83b7\u5f97\u4e86\u5e7f\u6cdb\u719f\u77e5\u8ba4\u540c\u7684\u57fa\u7840\u4e0a\uff0c\u76f2\u76ee\u56e0\u300c\u6b63\u786e\u6027\u300d\u800c\u4fee\u6539\u73b0\u6709\u7684\u8bd1\u6587\u53ea\u4f1a\u5f15\u53d1\u66f4\u5927\u7684\u6df7\u6dc6\u4e0e\u6df7\u4e71\uff0c\u4e0e\u4e4b\u5f15\u53d1\u7684\u6587\u5b57\u6e38\u620f\u4e5f\u4f1a\u5f71\u54cd\u6c9f\u901a\u6548\u7387\u3002 OI Wiki \u4e0d\u662f\u767e\u79d1\u5168\u4e66 \u00b6 OI Wiki \u6536\u5f55\u7684\u5185\u5bb9\u5e94\u9650\u5b9a\u5728\u300c\u5df2\u7ecf\u88ab\u5e94\u7528\u4e8e\u7f16\u7a0b\u7ade\u8d5b\u300d\u7684\u8ba1\u7b97\u673a\u79d1\u5b66\u3001\u6570\u5b66\u7b49\u9886\u57df\u7684\u90e8\u5206\u77e5\u8bc6\u3002\u5176\u4ed6\u4e0e\u7f16\u7a0b\u7ade\u8d5b\u65e0\u5173\u7684\u9886\u57df\u6216\u77e5\u8bc6\u5747\u4e0d\u9002\u5408\u6536\u5f55\u4e8e OI Wiki \u3002 \u4f8b\u5982\uff0c\u5982\u4e0b\u7684\u9886\u57df\u6216\u77e5\u8bc6 \u4e0d\u9002\u5408 \u6536\u5f55\u4e8e OI Wiki \uff1a \u5386\u53f2\uff0c\u827a\u672f\u7b49\u65e0\u5173\u9886\u57df\uff1b TBN \u77e9\u9635 \u7b49\u867d\u7136\u4ece\u5c5e\u4e8e\u6709\u5173\u9886\u57df\u4f46\u76ee\u524d\u4e0d\u80fd\u5e94\u7528\u4e8e\u7f16\u7a0b\u7ade\u8d5b\u7684\u77e5\u8bc6\uff1b PID \u63a7\u5236 \u3001 \u6709\u9650\u5143\u6cd5 \u7b49\u76ee\u524d\u4e0d\u80fd\u5e94\u7528\u4e8e\u7f16\u7a0b\u7ade\u8d5b\u7684\u9886\u57df\u7b97\u6cd5\uff1b \u6df1\u5ea6\u5b66\u4e60 \u3001 \u5f3a\u5316\u5b66\u4e60 \u7b49\u76ee\u524d\u4e0d\u80fd\u5e94\u7528\u4e8e\u7f16\u7a0b\u7ade\u8d5b\u7684\u901a\u7528\u7b97\u6cd5\u3002 OI Wiki \u4e0d\u662f\u7f16\u7a0b\u8bed\u8a00\u7684\u6587\u6863\u548c\u5b66\u4e60\u6307\u5357 \u00b6 OI Wiki \u6536\u5f55\u7684\u7b97\u6cd5\u76f8\u8f83\u4e8e\u4ee3\u7801\u5b9e\u73b0\uff0c\u5e94\u66f4\u5173\u5fc3\u7b97\u6cd5\u672c\u8eab\u3002\u7b97\u6cd5\u7684\u5177\u4f53\u5b9e\u73b0\u4ec5\u4f5c\u4e3a\u4e00\u79cd\u66f4\u52a0\u7ec6\u81f4\u7684\u7406\u89e3\u6216\u8005\u5b9e\u73b0\u63d0\u793a\uff0c\u800c\u4e0d\u662f\u7ed9\u5177\u4f53\u7684\u8bed\u8a00\u5b66\u4e60\u8005\u4ee5\u65b9\u4fbf\u3002\u5982\u679c\u60a8\u60f3\u8981\u5b66\u4e60\u67d0\u79cd\u8bed\u8a00\uff0c\u60a8\u5e94\u8be5\u9605\u8bfb\u8be5\u8bed\u8a00\u7684\u5b98\u65b9\u6587\u6863\u7b49\u8d44\u6599\u3002 \u51fa\u4e8e\u77e5\u8bc6\u6536\u5f55\u9700\u8981\uff0c OI Wiki \u53ef\u4ee5\u6536\u5f55\u7f16\u7a0b\u7ade\u8d5b\u5e38\u7528\u8bed\u8a00\u7684\u7b80\u5355\u4f7f\u7528\u6307\u5357\u3002\u9664\u6b64\u4e4b\u5916\uff0c OI Wiki \u4e0d\u4f1a\u6536\u5f55\u8bf8\u5982\u300c\u67d0\u7f16\u7a0b\u8bed\u8a00\u7684\u67d0\u6807\u51c6\u5e93\u91cc\u67d0\u51fd\u6570\u7684\u5b9e\u73b0\u7ec6\u8282\u7b49\u300d\u4e0e\u7f16\u7a0b\u7ade\u8d5b\u548c\u7b97\u6cd5\u5173\u7cfb\u4e0d\u5927\u7684\u5185\u5bb9\u3002","title":"What oi wiki is not"},{"location":"intro/what-oi-wiki-is-not.html#oi-wiki","text":"\u4f5c\u4e3a\u4e00\u4e2a Wiki\uff0c OI Wiki \u4e0d\u662f\u53d1\u8868 \u539f\u521b\u7814\u7a76 \uff08\u5982 \u65b0\u7406\u8bba\u53ca\u89e3\u6cd5 \u3001 \u539f\u521b\u89c2\u70b9 \u3001 \u81ea\u521b\u5b9a\u4e49\u6216\u8bcd\u8bed \u7b49\uff09\u7684\u573a\u6240\u3002\u4f8b\u5982\uff1a \u60a8\u53d1\u73b0\u4e86\u67d0\u9898\u76ee\u7684\u975e\u5e38\u89c4\u505a\u6cd5\uff0c\u82e5\u60a8\u4e0d\u80fd\u8bc1\u660e\u8be5\u505a\u6cd5\u5df2\u7ecf\u88ab\u5e94\u7528\u4e8e\u5176\u4ed6\u9898\u76ee\u4e2d\uff0c\u5219 \u4e0d\u5e94 \u5728 OI Wiki \u4e2d\u5f00\u8bbe\u5355\u72ec\u7684\u754c\u9762\u3002 \u60a8\u63d0\u51fa\u4e86\u65b0\u7684\u7b97\u6cd5\u6216\u6570\u636e\u7ed3\u6784\uff0c\u82e5\u60a8\u4e0d\u80fd\u8bc1\u660e\u8be5\u5185\u5bb9\u5df2\u7ecf\u88ab\u7528\u4e8e\u89e3\u51b3\u7f16\u7a0b\u7ade\u8d5b\u4e2d\u7684\u67d0\u4e00\u7c7b\u95ee\u9898\uff0c\u5219 \u4e0d\u5e94 \u5c06\u5176\u63d0\u4ea4\u81f3 OI Wiki \u3002","title":"OI Wiki \u4e0d\u662f\u53d1\u8868\u539f\u521b\u7814\u7a76\u7684\u573a\u6240"},{"location":"intro/what-oi-wiki-is-not.html#oi-wiki_1","text":"\u4f5c\u4e3a\u6cdb\u4e2d\u6587\u4e3a\u4e3b\u8bed\u5883\u4e4b\u4e0b\u3001\u4ee5\u7f16\u7a0b\u7ade\u8d5b\u76f8\u5173\u5185\u5bb9\u4e3a\u4e3b\u7684\u77e5\u8bc6\u6574\u5408\u7ad9\u70b9\uff0c OI Wiki \u4fa7\u91cd\u4e8e\u63d0\u4f9b \u7a33\u5b9a\u6c89\u6dc0\u5e76\u5df2\u53d6\u5f97\u5e7f\u6cdb\u8ba4\u53ef \u7684\u4fe1\u606f\u3002 \u6362\u8a00\u4e4b\uff0c\u9664\u975e\u662f\u6743\u5a01\u673a\u6784\u53d1\u5e03\u7684\u4fe1\u606f\uff08\u5982\u4e2d\u56fd\u8ba1\u7b97\u673a\u534f\u4f1a\u53d1\u5e03\u7684\u8d5b\u5236\u66f4\u65b0\uff09\uff0c\u60a8\u6240\u8d21\u732e\u7684\u5185\u5bb9\u5e94\u5f53\u662f\u5df2\u7ecf\u7ecf\u8fc7\u68c0\u9a8c\u6c89\u6dc0\uff0c\u83b7\u5f97\u4e86\u5e7f\u6cdb\u8ba4\u53ef\uff0c\u4e14\u5728\u4e00\u6bb5\u65f6\u95f4\u5185\u4e0d\u4f1a\u4ea7\u751f\u65f6\u6548\u6027\u95ee\u9898\u7684\u4fe1\u606f\u3002\u4f8b\u5982\uff1a \u60a8\u53d1\u73b0 X \u535a\u58eb\u5728\u67d0\u4e2a\u4f4d\u7f6e\u53d1\u5e03\u4e86\u65b0\u7684\u7b97\u6cd5\uff0c\u82e5\u60a8\u60f3\u5c06\u5176\u52a0\u5165 OI Wiki \u4e2d\uff0c\u6b64\u65f6\u60a8\u5e94\u8be5\u89c2\u5bdf\u5176\u662f\u5426\u80fd\u83b7\u5f97\u5e7f\u6cdb\u8ba4\u53ef\uff08\u5982\u53ef\u4f5c\u4e3a\u6b63\u5f0f\u6bd4\u8d5b\u4e2d\u7684\u6cdb\u7528\u4f18\u79c0\u89e3\u6cd5\uff09\uff0c\u4e14\u4e0e OI Wiki \u4e2d\u73b0\u5b58\u7684\u7b97\u6cd5\u6709\u4e00\u5b9a\u7684\u533a\u5206\u6027\u3002 \u60a8\u53d1\u73b0 OI Wiki \u4e2d\u63d0\u5230\u7684\u67d0\u8f6f\u4ef6\u6216\u4eba\u7269\u51fa\u73b0\u4e86\u8206\u60c5\u95ee\u9898\uff0c\u6b64\u65f6\u8bf7\u60a8\u5173\u6ce8\u8bc4\u8bba\u533a\u7b49\u7684\u76f8\u5173\u516c\u544a\uff0c\u5207\u52ff\u91cd\u590d\u5f00 issue \u7b49\u8bf4\u660e\u95ee\u9898\u3002 OI Wiki \u7684\u76ee\u7684\u5728\u4e8e\u8bb0\u8f7d \u53ef\u957f\u4e45\u6d41\u4f20\u7684\u4fe1\u606f \uff0c\u800c\u4e0d\u662f \u5e26\u6709\u65f6\u6548\u6027\u7684\u4e34\u65f6\u4fe1\u606f \u3002","title":"OI Wiki \u4e0d\u662f\u65b0\u95fb\u7684\u6536\u96c6\u5904"},{"location":"intro/what-oi-wiki-is-not.html#oi-wiki_2","text":"OI Wiki \u4e3b\u7ad9\u4e0d\u4f1a\u6536\u5f55\u5404\u7c7b \u6587\u732e \u3001 \u8bfe\u4ef6 \u3001 \u8bb2\u4e49 \u3001 \u8bf4\u660e\u4e66 \u7b49\u8d44\u6599\uff0c\u82e5\u60a8\u60f3\u63d0\u4ea4\u6709\u5173\u7f16\u7a0b\u7ade\u8d5b\u7684\u8d44\u6599\uff0c\u8bf7\u79fb\u6b65\u81f3 OI-wiki/libs \u3002","title":"OI Wiki \u4e0d\u662f\u6863\u6848\u9986"},{"location":"intro/what-oi-wiki-is-not.html#oi-wiki_3","text":"OI Wiki \u662f\u4e00\u4e2a\u77e5\u8bc6\u6574\u5408\u7ad9\u70b9\uff0c \u4e0d\u662f \u6f14\u8bb2\u53f0\u3001\u8bba\u575b\u3001\u5ba3\u4f20\u5de5\u5177\u7b49\uff0c\u56e0\u6b64\u5728\u6dfb\u52a0\u6216\u4fee\u6539\u6761\u76ee\u65f6\uff0c\u8bf7\u52ff\uff1a \u53d1\u8868\u89c2\u70b9\u6216\u8bc4\u8bba\uff1a OI Wiki \u7684\u5185\u5bb9\u5fc5\u987b \u5ba2\u89c2\u4e2d\u7acb \uff0c\u5982\u679c\u60a8\u60f3\u8981\u53d1\u8868\u4e0e OI Wiki \u6709\u5173\u7684\u89c2\u70b9\u4e0e\u8bc4\u8bba\uff0c\u8bf7\u79fb\u6b65\u81f3\u8bc4\u8bba\u533a\u6216 issue \u9875\u9762\u3002\u5982\u679c\u60a8\u60f3\u8981\u53d1\u8868\u7684\u89c2\u70b9\u4e0e\u8bc4\u8bba\u4e0e OI Wiki \u65e0\u5173\uff0c\u8bf7\u79fb\u6b65\u81f3\u4e2a\u4eba\u535a\u5ba2\u6216\u8bba\u575b\uff1b \u4f5c\u4efb\u4f55\u5f62\u5f0f\u7684\u5ba3\u4f20\u884c\u4e3a\uff1a\u51fa\u4e8e\u77e5\u8bc6\u6536\u5f55\u9700\u8981\uff0c OI Wiki \u53ef\u4ee5\u63a5\u53d7\u5bf9\u300c\u5728\u7f16\u7a0b\u7ade\u8d5b\u9886\u57df\u5df2\u7ecf \u5e7f\u4e3a\u4eba\u77e5 \u7684\u7f51\u7ad9\u6216\u8f6f\u4ef6\u300d\u7684\u4ecb\u7ecd\u3002\u9664\u6b64\u4e4b\u5916\uff0c OI Wiki \u4e0d\u4f1a\u63a5\u53d7\u4efb\u4f55\u975e\u8d5e\u52a9\u5546\u63d0\u4f9b\u7684\u4efb\u4f55\u5ba3\u4f20\u6027\u8d28\u7684\u5185\u5bb9\u3002","title":"OI Wiki \u4e0d\u662f\u5ba3\u4f20\u5de5\u5177"},{"location":"intro/what-oi-wiki-is-not.html#oi-wiki_4","text":"\u4f5c\u4e3a\u4e00\u4e2a\u4e3b\u8981\u4f9d\u9760\u7528\u6237\u8d21\u732e\u7684\u793e\u533a\u9879\u76ee\uff0c OI Wiki \u4e0d\u5177\u6709\u6743\u5a01\u6027\uff0c\u4e0d\u5e94\u4e5f\u6ca1\u6709\u80fd\u529b\u4f5c\u4e3a\u4e00\u4e2a\u6743\u5a01\u673a\u6784\u3002 OI Wiki \u53ef\u4ee5\u4f5c\u4e3a\u5b66\u4e60\u7f16\u7a0b\u7ade\u8d5b\u76f8\u5173\u77e5\u8bc6\u7684\u53c2\u8003\uff0c\u800c\u4e0d\u662f\u6807\u51c6\u6559\u79d1\u4e66\u3002\u4f5c\u4e3a\u4e00\u4e2a\u793e\u533a\u7ef4\u62a4\u7684\u53c2\u8003\u7ad9\u70b9\uff0c\u60a8\u4e0d\u5e94\u5c06 OI Wiki \u7528\u4f5c\u6700\u7ec8\u7684\u6743\u5a01\u6807\u51c6\uff08\u5982\u4f5c\u4e3a\u7f16\u7a0b\u7ade\u8d5b\u7684\u300c\u8003\u7eb2\u300d\uff09\uff0c\u4e5f\u4e0d\u5e94\u76f2\u76ee\u91c7\u4fe1\u6240\u6709 OI Wiki \u7684\u5185\u5bb9\u3002 OI Wiki \u4e0d\u5bf9\u7531\u4f7f\u7528 OI Wiki \u7684\u5185\u5bb9\u800c\u4ea7\u751f\u7684\u4efb\u4f55\u540e\u679c\u8d1f\u8d23\u3002","title":"OI Wiki \u4e0d\u662f\u6743\u5a01\u673a\u6784"},{"location":"intro/what-oi-wiki-is-not.html#oi-wiki_5","text":"OI Wiki \u57fa\u4e8e\u300cWiki\u300d\u4e00\u8bcd\uff0c\u672c\u8d28\u4e0a\u662f\u4f9d\u9760\u7528\u6237 \u534f\u540c\u7f16\u8f91\u5185\u5bb9 \u7684\u793e\u533a\u3002\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u60a8\u6240\u63d0\u4f9b\u7684\u5185\u5bb9\u5e94\u5f53 \u5c3d\u91cf\u51cf\u8f7b\u4e2a\u4eba\u8272\u5f69 \uff0c\u670d\u52a1\u4e8e\u6574\u4e2a Wiki\uff0c\u5173\u6ce8\u60a8\u6240\u8d21\u732e\u7684\u76f8\u5173\u8bcd\u6761\u7684\u7ed3\u6784\u3002\u5207\u52ff\u4ee5\u64b0\u5199\u4e2a\u4eba\u535a\u5ba2\u6587\u7ae0\u7684\u601d\u7ef4\u5bf9\u5f85 Wiki \u4e2d\u7684\u6761\u76ee\u3002\u4f8b\u5982\uff1a \u60a8 \u4e0d\u5e94 \u5c06 OI Wiki \u4f5c\u4e3a\u60a8\u4e2a\u4eba\u535a\u5ba2\u7684\u5bfc\u822a\u7ad9\u70b9\uff1b \u60a8 \u4e0d\u5e94 \u5728\u8bcd\u6761\u7684\u63cf\u8ff0\u4e2d\u52a0\u5165\u6761\u76ee\u5386\u53f2\u3001\u4e2a\u4eba\u5410\u69fd\u3001\u51b7\u7b11\u8bdd\u7b49\u65e0\u5173\u5185\u5bb9\u3002 \u4ee5\u4e0a\u4f8b\u5b50\u7684\u53cd\u9762\u5747\u4e3a\u64b0\u5199\u4e2a\u4eba\u535a\u5ba2\u65f6\u7684\u5e38\u89c1\u601d\u7ef4\uff0c\u800c\u8fd9\u4e9b\u5728\u63d0\u5021\u5ba2\u89c2\u4e2d\u7acb\u7684 OI Wiki \u4e2d\u662f\u4e0d\u53d7\u6b22\u8fce\u7684\u3002","title":"OI Wiki \u4e0d\u662f\u4e2a\u4eba\u535a\u5ba2"},{"location":"intro/what-oi-wiki-is-not.html#oi-wiki_6","text":"OI Wiki \u7684\u76ee\u6807\u7fa4\u4f53\u4e0d\u662f\u5386\u53f2\u5b66\u5bb6\u53ca\u8bed\u8a00\u5b66\u5bb6\uff0c\u56e0\u6b64\u5728\u5916\u6587\u540d\u8bcd\u7684\u7ffb\u8bd1\u4e2d\uff0c OI Wiki \u503e\u5411\u4e8e\u4f7f\u7528\u4e2d\u6587\u8bed\u5883\u4e0b \u5df2\u7ecf\u83b7\u5f97\u4e86\u5e7f\u6cdb\u8ba4\u540c \u7684\u8bd1\u6587\uff0c\u5373\u4f7f\u5b83\u4eec\u53ef\u80fd\u662f\u6709\u7455\u75b5\u7684\u3002 \u5728\u8bd1\u6587\u5df2\u7ecf\u83b7\u5f97\u4e86\u5e7f\u6cdb\u719f\u77e5\u8ba4\u540c\u7684\u57fa\u7840\u4e0a\uff0c\u76f2\u76ee\u56e0\u300c\u6b63\u786e\u6027\u300d\u800c\u4fee\u6539\u73b0\u6709\u7684\u8bd1\u6587\u53ea\u4f1a\u5f15\u53d1\u66f4\u5927\u7684\u6df7\u6dc6\u4e0e\u6df7\u4e71\uff0c\u4e0e\u4e4b\u5f15\u53d1\u7684\u6587\u5b57\u6e38\u620f\u4e5f\u4f1a\u5f71\u54cd\u6c9f\u901a\u6548\u7387\u3002","title":"OI Wiki \u4e0d\u662f\u8bd1\u540d\u6807\u51c6\u59d4\u5458\u4f1a"},{"location":"intro/what-oi-wiki-is-not.html#oi-wiki_7","text":"OI Wiki \u6536\u5f55\u7684\u5185\u5bb9\u5e94\u9650\u5b9a\u5728\u300c\u5df2\u7ecf\u88ab\u5e94\u7528\u4e8e\u7f16\u7a0b\u7ade\u8d5b\u300d\u7684\u8ba1\u7b97\u673a\u79d1\u5b66\u3001\u6570\u5b66\u7b49\u9886\u57df\u7684\u90e8\u5206\u77e5\u8bc6\u3002\u5176\u4ed6\u4e0e\u7f16\u7a0b\u7ade\u8d5b\u65e0\u5173\u7684\u9886\u57df\u6216\u77e5\u8bc6\u5747\u4e0d\u9002\u5408\u6536\u5f55\u4e8e OI Wiki \u3002 \u4f8b\u5982\uff0c\u5982\u4e0b\u7684\u9886\u57df\u6216\u77e5\u8bc6 \u4e0d\u9002\u5408 \u6536\u5f55\u4e8e OI Wiki \uff1a \u5386\u53f2\uff0c\u827a\u672f\u7b49\u65e0\u5173\u9886\u57df\uff1b TBN \u77e9\u9635 \u7b49\u867d\u7136\u4ece\u5c5e\u4e8e\u6709\u5173\u9886\u57df\u4f46\u76ee\u524d\u4e0d\u80fd\u5e94\u7528\u4e8e\u7f16\u7a0b\u7ade\u8d5b\u7684\u77e5\u8bc6\uff1b PID \u63a7\u5236 \u3001 \u6709\u9650\u5143\u6cd5 \u7b49\u76ee\u524d\u4e0d\u80fd\u5e94\u7528\u4e8e\u7f16\u7a0b\u7ade\u8d5b\u7684\u9886\u57df\u7b97\u6cd5\uff1b \u6df1\u5ea6\u5b66\u4e60 \u3001 \u5f3a\u5316\u5b66\u4e60 \u7b49\u76ee\u524d\u4e0d\u80fd\u5e94\u7528\u4e8e\u7f16\u7a0b\u7ade\u8d5b\u7684\u901a\u7528\u7b97\u6cd5\u3002","title":"OI Wiki \u4e0d\u662f\u767e\u79d1\u5168\u4e66"},{"location":"intro/what-oi-wiki-is-not.html#oi-wiki_8","text":"OI Wiki \u6536\u5f55\u7684\u7b97\u6cd5\u76f8\u8f83\u4e8e\u4ee3\u7801\u5b9e\u73b0\uff0c\u5e94\u66f4\u5173\u5fc3\u7b97\u6cd5\u672c\u8eab\u3002\u7b97\u6cd5\u7684\u5177\u4f53\u5b9e\u73b0\u4ec5\u4f5c\u4e3a\u4e00\u79cd\u66f4\u52a0\u7ec6\u81f4\u7684\u7406\u89e3\u6216\u8005\u5b9e\u73b0\u63d0\u793a\uff0c\u800c\u4e0d\u662f\u7ed9\u5177\u4f53\u7684\u8bed\u8a00\u5b66\u4e60\u8005\u4ee5\u65b9\u4fbf\u3002\u5982\u679c\u60a8\u60f3\u8981\u5b66\u4e60\u67d0\u79cd\u8bed\u8a00\uff0c\u60a8\u5e94\u8be5\u9605\u8bfb\u8be5\u8bed\u8a00\u7684\u5b98\u65b9\u6587\u6863\u7b49\u8d44\u6599\u3002 \u51fa\u4e8e\u77e5\u8bc6\u6536\u5f55\u9700\u8981\uff0c OI Wiki \u53ef\u4ee5\u6536\u5f55\u7f16\u7a0b\u7ade\u8d5b\u5e38\u7528\u8bed\u8a00\u7684\u7b80\u5355\u4f7f\u7528\u6307\u5357\u3002\u9664\u6b64\u4e4b\u5916\uff0c OI Wiki \u4e0d\u4f1a\u6536\u5f55\u8bf8\u5982\u300c\u67d0\u7f16\u7a0b\u8bed\u8a00\u7684\u67d0\u6807\u51c6\u5e93\u91cc\u67d0\u51fd\u6570\u7684\u5b9e\u73b0\u7ec6\u8282\u7b49\u300d\u4e0e\u7f16\u7a0b\u7ade\u8d5b\u548c\u7b97\u6cd5\u5173\u7cfb\u4e0d\u5927\u7684\u5185\u5bb9\u3002","title":"OI Wiki \u4e0d\u662f\u7f16\u7a0b\u8bed\u8a00\u7684\u6587\u6863\u548c\u5b66\u4e60\u6307\u5357"}]}